{"version":3,"sources":["builder/dictionary.ts"],"names":[],"mappings":"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","file":"dictionary.js","sourcesContent":["import { Data } from '../data';\nimport { Vector } from '../vector';\nimport { IntBuilder } from './int';\nimport { Dictionary, DataType } from '../type';\nimport { Builder, DataBuilderOptions } from './base';\n\ntype DictionaryHashFunction = (x: any) => string | number;\n\nexport interface DictionaryBuilderOptions<T extends DataType = any, TNull = any> extends DataBuilderOptions<T, TNull> {\n    dictionaryHashFunction?: DictionaryHashFunction;\n}\n\nexport class DictionaryBuilder<T extends Dictionary, TNull = any> extends Builder<T, TNull> {\n\n    protected _hash: DictionaryHashFunction;\n    protected hashmap = Object.create(null);\n    public readonly indices: IntBuilder<T['indices']>;\n    public readonly dictionary: Builder<T['dictionary']>;\n\n    constructor(options: DictionaryBuilderOptions<T, TNull>) {\n        super(options);\n        const { type, nullValues } = options;\n        this._hash = options.dictionaryHashFunction || defaultHashFunction;\n        this.indices = Builder.new({ type: type.indices, nullValues }) as IntBuilder<T['indices']>;\n        this.dictionary = Builder.new({ type: type.dictionary, nullValues: [] }) as Builder<T['dictionary']>;\n    }\n    public get values() { return this.indices && this.indices.values; }\n    public get nullBitmap() { return this.indices && this.indices.nullBitmap; }\n    public set values(values: T['TArray']) { this.indices && (this.indices.values = values); }\n    public set nullBitmap(nullBitmap: Uint8Array) { this.indices && (this.indices.nullBitmap = nullBitmap); }\n    public setHashFunction(hash: DictionaryHashFunction) {\n        this._hash = hash;\n        return this;\n    }\n    public reset() {\n        this.length = 0;\n        this.indices.reset();\n        this.dictionary.reset();\n        return this;\n    }\n    public flush() {\n        const indices = this.indices;\n        const data = indices.flush().clone(this.type);\n        this.length = indices.length;\n        return data;\n    }\n    public finish() {\n        this.type.dictionaryVector = Vector.new(this.dictionary.finish().flush());\n        return super.finish();\n    }\n    public write(value: any) {\n        this.indices.length = super.write(value).length;\n        return this;\n    }\n    public writeValid(isValid: boolean, index: number) {\n        return this.indices.writeValid(isValid, index);\n    }\n    public writeValue(value: T['TValue'], index: number) {\n        let id = this._hash(value);\n        let hashmap = this.hashmap;\n        if (hashmap[id] === undefined) {\n            hashmap[id] = this.dictionary.write(value).length - 1;\n        }\n        return this.indices.writeValue(hashmap[id], index);\n    }\n    public *readAll(source: Iterable<any>, chunkLength = Infinity) {\n        const chunks = [] as Data<T>[];\n        for (const chunk of super.readAll(source, chunkLength)) {\n            chunks.push(chunk);\n        }\n        yield* chunks;\n    }\n    public async *readAllAsync(source: Iterable<any> | AsyncIterable<any>, chunkLength = Infinity) {\n        const chunks = [] as Data<T>[];\n        for await (const chunk of super.readAllAsync(source, chunkLength)) {\n            chunks.push(chunk);\n        }\n        yield* chunks;\n    }\n}\n\nfunction defaultHashFunction(val: any) {\n    typeof val === 'string' || (val = `${val}`);\n    let h = 6, y = 9 * 9, i = val.length;\n    while (i > 0) {\n        h = Math.imul(h ^ val.charCodeAt(--i), y);\n    }\n    return (h ^ h >>> 9) as any;\n}\n"]}