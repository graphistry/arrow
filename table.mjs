// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
import * as tslib_1 from "tslib";
import { RecordBatch } from './recordbatch';
import { Col } from './predicate';
import { Schema, Field } from './type';
import { read, readAsync } from './ipc/reader/arrow';
import { isPromise, isAsyncIterable } from './util/compat';
import { DictionaryVector, IntVector } from './vector';
import { ChunkedView } from './vector/chunked';
export class Table {
    constructor(...args) {
        // List of inner Vectors, possibly spanning batches
        this._columns = [];
        let schema;
        let batches;
        if (args[0] instanceof Schema) {
            schema = args[0];
            batches = Array.isArray(args[1][0]) ? args[1][0] : args[1];
        }
        else if (args[0] instanceof RecordBatch) {
            schema = (batches = args)[0].schema;
        }
        else {
            schema = (batches = args[0])[0].schema;
        }
        this.schema = schema;
        this.batches = batches;
        this.batchesUnion = batches.reduce((union, batch) => union.concat(batch));
        // this.columns = schema.fields.map((_, i) => this.batchesUnion.getChildAt(i));
        this.length = this.batchesUnion.length;
        this.numCols = this.batchesUnion.numCols;
    }
    static empty() { return new Table(new Schema([]), []); }
    static from(sources) {
        if (sources) {
            let schema;
            let recordBatches = [];
            for (let recordBatch of read(sources)) {
                schema = schema || recordBatch.schema;
                recordBatches.push(recordBatch);
            }
            return new Table(schema || new Schema([]), recordBatches);
        }
        return Table.empty();
    }
    static fromAsync(sources) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (isAsyncIterable(sources)) {
                let schema;
                let recordBatches = [];
                try {
                    for (var _a = tslib_1.__asyncValues(readAsync(sources)), _b; _b = yield _a.next(), !_b.done;) {
                        let recordBatch = yield _b.value;
                        schema = schema || recordBatch.schema;
                        recordBatches.push(recordBatch);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return)) yield _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return new Table(schema || new Schema([]), recordBatches);
            }
            else if (isPromise(sources)) {
                return Table.from(yield sources);
            }
            else if (sources) {
                return Table.from(sources);
            }
            return Table.empty();
            var e_1, _c;
        });
    }
    static fromStruct(struct) {
        const schema = new Schema(struct.type.children);
        const chunks = struct.view instanceof ChunkedView ?
            struct.view.childVectors :
            [struct];
        return new Table(chunks.map((chunk) => new RecordBatch(schema, chunk.length, chunk.view.childData)));
    }
    get(index) {
        return this.batchesUnion.get(index);
    }
    getColumn(name) {
        return this.getColumnAt(this.getColumnIndex(name));
    }
    getColumnAt(index) {
        return this._columns[index] || (this._columns[index] = this.batchesUnion.getChildAt(index));
    }
    getColumnIndex(name) {
        return this.schema.fields.findIndex((f) => f.name === name);
    }
    [Symbol.iterator]() {
        return this.batchesUnion[Symbol.iterator]();
    }
    filter(predicate) {
        return new FilteredDataFrame(this.batches, predicate);
    }
    scan(next) {
        const batches = this.batches, numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches;) {
            // load batches
            const batch = batches[batchIndex];
            // yield all indices
            for (let index = -1, numRows = batch.length; ++index < numRows;) {
                next(index, batch);
            }
        }
    }
    count() { return this.length; }
    countBy(name) {
        const batches = this.batches, numBatches = batches.length;
        const count_by = typeof name === 'string' ? new Col(name) : name;
        // Assume that all dictionary batches are deltas, which means that the
        // last record batch has the most complete dictionary
        count_by.bind(batches[numBatches - 1]);
        const vector = count_by.vector;
        if (!(vector instanceof DictionaryVector)) {
            throw new Error('countBy currently only supports dictionary-encoded columns');
        }
        // TODO: Adjust array byte width based on overall length
        // (e.g. if this.length <= 255 use Uint8Array, etc...)
        const counts = new Uint32Array(vector.dictionary.length);
        for (let batchIndex = -1; ++batchIndex < numBatches;) {
            // load batches
            const batch = batches[batchIndex];
            // rebind the countBy Col
            count_by.bind(batch);
            const keys = count_by.vector.indicies;
            // yield all indices
            for (let index = -1, numRows = batch.length; ++index < numRows;) {
                let key = keys.get(index);
                if (key !== null) {
                    counts[key]++;
                }
            }
        }
        return new CountByResult(vector.dictionary, IntVector.from(counts));
    }
    select(...columnNames) {
        return new Table(this.batches.map((batch) => batch.select(...columnNames)));
    }
    toString(separator) {
        let str = '';
        for (const row of this.rowsToString(separator)) {
            str += row + '\n';
        }
        return str;
    }
    rowsToString(separator = ' | ') {
        return new TableToStringIterator(tableRowsToString(this, separator));
    }
}
class FilteredDataFrame {
    constructor(batches, predicate) {
        this.batches = batches;
        this.predicate = predicate;
    }
    scan(next) {
        // inlined version of this:
        // this.parent.scan((idx, columns) => {
        //     if (this.predicate(idx, columns)) next(idx, columns);
        // });
        const batches = this.batches;
        const numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches;) {
            // load batches
            const batch = batches[batchIndex];
            const predicate = this.predicate.bind(batch);
            // yield all indices
            for (let index = -1, numRows = batch.length; ++index < numRows;) {
                if (predicate(index, batch)) {
                    next(index, batch);
                }
            }
        }
    }
    count() {
        // inlined version of this:
        // let sum = 0;
        // this.parent.scan((idx, columns) => {
        //     if (this.predicate(idx, columns)) ++sum;
        // });
        // return sum;
        let sum = 0;
        const batches = this.batches;
        const numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches;) {
            // load batches
            const batch = batches[batchIndex];
            const predicate = this.predicate.bind(batch);
            // yield all indices
            for (let index = -1, numRows = batch.length; ++index < numRows;) {
                if (predicate(index, batch)) {
                    ++sum;
                }
            }
        }
        return sum;
    }
    filter(predicate) {
        return new FilteredDataFrame(this.batches, this.predicate.and(predicate));
    }
    countBy(name) {
        const batches = this.batches, numBatches = batches.length;
        const count_by = typeof name === 'string' ? new Col(name) : name;
        // Assume that all dictionary batches are deltas, which means that the
        // last record batch has the most complete dictionary
        count_by.bind(batches[numBatches - 1]);
        const vector = count_by.vector;
        if (!(vector instanceof DictionaryVector)) {
            throw new Error('countBy currently only supports dictionary-encoded columns');
        }
        // TODO: Adjust array byte width based on overall length
        // (e.g. if this.length <= 255 use Uint8Array, etc...)
        const counts = new Uint32Array(vector.dictionary.length);
        for (let batchIndex = -1; ++batchIndex < numBatches;) {
            // load batches
            const batch = batches[batchIndex];
            const predicate = this.predicate.bind(batch);
            // rebind the countBy Col
            count_by.bind(batch);
            const keys = count_by.vector.indicies;
            // yield all indices
            for (let index = -1, numRows = batch.length; ++index < numRows;) {
                let key = keys.get(index);
                if (key !== null && predicate(index, batch)) {
                    counts[key]++;
                }
            }
        }
        return new CountByResult(vector.dictionary, IntVector.from(counts));
    }
}
export class CountByResult extends Table {
    constructor(values, counts) {
        super(new RecordBatch(new Schema([
            new Field('values', values.type),
            new Field('counts', counts.type)
        ]), counts.length, [values, counts]));
    }
    toJSON() {
        const values = this.getColumnAt(0);
        const counts = this.getColumnAt(1);
        const result = {};
        for (let i = -1; ++i < this.length;) {
            result[values.get(i)] = counts.get(i);
        }
        return result;
    }
}
export class TableToStringIterator {
    constructor(iterator) {
        this.iterator = iterator;
    }
    [Symbol.iterator]() { return this.iterator; }
    next(value) { return this.iterator.next(value); }
    throw(error) { return this.iterator.throw && this.iterator.throw(error) || { done: true, value: '' }; }
    return(value) { return this.iterator.return && this.iterator.return(value) || { done: true, value: '' }; }
    pipe(stream) {
        let res;
        let write = () => {
            if (stream.writable) {
                do {
                    if ((res = this.next()).done) {
                        break;
                    }
                } while (stream.write(res.value + '\n', 'utf8'));
            }
            if (!res || !res.done) {
                stream.once('drain', write);
            }
            else if (!stream.isTTY) {
                stream.end('\n');
            }
        };
        write();
    }
}
function* tableRowsToString(table, separator = ' | ') {
    const fields = table.schema.fields;
    const header = ['row_id', ...fields.map((f) => `${f}`)].map(stringify);
    const maxColumnWidths = header.map(x => x.length);
    // Pass one to convert to strings and count max column widths
    for (let i = -1, n = table.length - 1; ++i < n;) {
        let val, row = [i, ...table.get(i)];
        for (let j = -1, k = row.length; ++j < k;) {
            val = stringify(row[j]);
            maxColumnWidths[j] = Math.max(maxColumnWidths[j], val.length);
        }
    }
    yield header.map((x, j) => leftPad(x, ' ', maxColumnWidths[j])).join(separator);
    for (let i = -1, n = table.length; ++i < n;) {
        yield [i, ...table.get(i)]
            .map((x) => stringify(x))
            .map((x, j) => leftPad(x, ' ', maxColumnWidths[j]))
            .join(separator);
    }
}
function leftPad(str, fill, n) {
    return (new Array(n + 1).join(fill) + str).slice(-1 * n);
}
function stringify(x) {
    return typeof x === 'string' ? `"${x}"` : ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ25HLENBQUMiLCJmaWxlIjoidGFibGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuaW1wb3J0IHsgUmVjb3JkQmF0Y2ggfSBmcm9tICcuL3JlY29yZGJhdGNoJztcbmltcG9ydCB7IENvbCwgUHJlZGljYXRlIH0gZnJvbSAnLi9wcmVkaWNhdGUnO1xuaW1wb3J0IHsgU2NoZW1hLCBGaWVsZCwgU3RydWN0IH0gZnJvbSAnLi90eXBlJztcbmltcG9ydCB7IHJlYWQsIHJlYWRBc3luYyB9IGZyb20gJy4vaXBjL3JlYWRlci9hcnJvdyc7XG5pbXBvcnQgeyBpc1Byb21pc2UsIGlzQXN5bmNJdGVyYWJsZSB9IGZyb20gJy4vdXRpbC9jb21wYXQnO1xuaW1wb3J0IHsgVmVjdG9yLCBEaWN0aW9uYXJ5VmVjdG9yLCBJbnRWZWN0b3IsIFN0cnVjdFZlY3RvciB9IGZyb20gJy4vdmVjdG9yJztcbmltcG9ydCB7IENodW5rZWRWaWV3IH0gZnJvbSAnLi92ZWN0b3IvY2h1bmtlZCc7XG5cbmV4cG9ydCB0eXBlIE5leHRGdW5jID0gKGlkeDogbnVtYmVyLCBjb2xzOiBSZWNvcmRCYXRjaCkgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBEYXRhRnJhbWUge1xuICAgIGZpbHRlcihwcmVkaWNhdGU6IFByZWRpY2F0ZSk6IERhdGFGcmFtZTtcbiAgICBzY2FuKG5leHQ6IE5leHRGdW5jKTogdm9pZDtcbiAgICBjb3VudCgpOiBudW1iZXI7XG4gICAgY291bnRCeShjb2w6IChDb2x8c3RyaW5nKSk6IENvdW50QnlSZXN1bHQ7XG59XG5cbmV4cG9ydCBjbGFzcyBUYWJsZSBpbXBsZW1lbnRzIERhdGFGcmFtZSB7XG4gICAgc3RhdGljIGVtcHR5KCkgeyByZXR1cm4gbmV3IFRhYmxlKG5ldyBTY2hlbWEoW10pLCBbXSk7IH1cbiAgICBzdGF0aWMgZnJvbShzb3VyY2VzPzogSXRlcmFibGU8VWludDhBcnJheSB8IEJ1ZmZlciB8IHN0cmluZz4gfCBvYmplY3QgfCBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHNvdXJjZXMpIHtcbiAgICAgICAgICAgIGxldCBzY2hlbWE6IFNjaGVtYSB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCByZWNvcmRCYXRjaGVzOiBSZWNvcmRCYXRjaFtdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCByZWNvcmRCYXRjaCBvZiByZWFkKHNvdXJjZXMpKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hIHx8IHJlY29yZEJhdGNoLnNjaGVtYTtcbiAgICAgICAgICAgICAgICByZWNvcmRCYXRjaGVzLnB1c2gocmVjb3JkQmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZShzY2hlbWEgfHwgbmV3IFNjaGVtYShbXSksIHJlY29yZEJhdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUYWJsZS5lbXB0eSgpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUFzeW5jKHNvdXJjZXM/OiBBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBzdHJpbmc+KSB7XG4gICAgICAgIGlmIChpc0FzeW5jSXRlcmFibGUoc291cmNlcykpIHtcbiAgICAgICAgICAgIGxldCBzY2hlbWE6IFNjaGVtYSB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCByZWNvcmRCYXRjaGVzOiBSZWNvcmRCYXRjaFtdID0gW107XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGxldCByZWNvcmRCYXRjaCBvZiByZWFkQXN5bmMoc291cmNlcykpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEgfHwgcmVjb3JkQmF0Y2guc2NoZW1hO1xuICAgICAgICAgICAgICAgIHJlY29yZEJhdGNoZXMucHVzaChyZWNvcmRCYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhYmxlKHNjaGVtYSB8fCBuZXcgU2NoZW1hKFtdKSwgcmVjb3JkQmF0Y2hlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHNvdXJjZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gVGFibGUuZnJvbShhd2FpdCBzb3VyY2VzKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gVGFibGUuZnJvbShzb3VyY2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVGFibGUuZW1wdHkoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJ1Y3Qoc3RydWN0OiBTdHJ1Y3RWZWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYShzdHJ1Y3QudHlwZS5jaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IGNodW5rcyA9IHN0cnVjdC52aWV3IGluc3RhbmNlb2YgQ2h1bmtlZFZpZXcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdHJ1Y3Qudmlldy5jaGlsZFZlY3RvcnMgYXMgU3RydWN0VmVjdG9yW10pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RydWN0XTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZShjaHVua3MubWFwKChjaHVuayk9Pm5ldyBSZWNvcmRCYXRjaChzY2hlbWEsIGNodW5rLmxlbmd0aCwgY2h1bmsudmlldy5jaGlsZERhdGEpKSk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlYWRvbmx5IHNjaGVtYTogU2NoZW1hO1xuICAgIHB1YmxpYyByZWFkb25seSBsZW5ndGg6IG51bWJlcjtcbiAgICBwdWJsaWMgcmVhZG9ubHkgbnVtQ29sczogbnVtYmVyO1xuICAgIC8vIExpc3Qgb2YgaW5uZXIgUmVjb3JkQmF0Y2hlc1xuICAgIHB1YmxpYyByZWFkb25seSBiYXRjaGVzOiBSZWNvcmRCYXRjaFtdO1xuICAgIC8vIExpc3Qgb2YgaW5uZXIgVmVjdG9ycywgcG9zc2libHkgc3Bhbm5pbmcgYmF0Y2hlc1xuICAgIHByb3RlY3RlZCByZWFkb25seSBfY29sdW1uczogVmVjdG9yPGFueT5bXSA9IFtdO1xuICAgIC8vIFVuaW9uIG9mIGFsbCBpbm5lciBSZWNvcmRCYXRjaGVzIGludG8gb25lIFJlY29yZEJhdGNoLCBwb3NzaWJseSBjaHVua2VkLlxuICAgIC8vIElmIHRoZSBUYWJsZSBoYXMganVzdCBvbmUgaW5uZXIgUmVjb3JkQmF0Y2gsIHRoaXMgcG9pbnRzIHRvIHRoYXQuXG4gICAgLy8gSWYgdGhlIFRhYmxlIGhhcyBtdWx0aXBsZSBpbm5lciBSZWNvcmRCYXRjaGVzLCB0aGVuIHRoaXMgaXMgYSBDaHVua2VkIHZpZXdcbiAgICAvLyBvdmVyIHRoZSBsaXN0IG9mIFJlY29yZEJhdGNoZXMuIFRoaXMgYWxsb3dzIHVzIHRvIGRlbGVnYXRlIHRoZSByZXNwb25zaWJpbGl0eVxuICAgIC8vIG9mIGluZGV4aW5nLCBpdGVyYXRpbmcsIHNsaWNpbmcsIGFuZCB2aXNpdGluZyB0byB0aGUgTmVzdGVkL0NodW5rZWQgRGF0YS9WaWV3cy5cbiAgICBwdWJsaWMgcmVhZG9ubHkgYmF0Y2hlc1VuaW9uOiBSZWNvcmRCYXRjaDtcblxuICAgIGNvbnN0cnVjdG9yKGJhdGNoZXM6IFJlY29yZEJhdGNoW10pO1xuICAgIGNvbnN0cnVjdG9yKC4uLmJhdGNoZXM6IFJlY29yZEJhdGNoW10pO1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYTogU2NoZW1hLCBiYXRjaGVzOiBSZWNvcmRCYXRjaFtdKTtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWE6IFNjaGVtYSwgLi4uYmF0Y2hlczogUmVjb3JkQmF0Y2hbXSk7XG4gICAgY29uc3RydWN0b3IoLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgbGV0IHNjaGVtYTogU2NoZW1hO1xuICAgICAgICBsZXQgYmF0Y2hlczogUmVjb3JkQmF0Y2hbXTtcbiAgICAgICAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBTY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IGFyZ3NbMF07XG4gICAgICAgICAgICBiYXRjaGVzID0gQXJyYXkuaXNBcnJheShhcmdzWzFdWzBdKSA/IGFyZ3NbMV1bMF0gOiBhcmdzWzFdO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBSZWNvcmRCYXRjaCkge1xuICAgICAgICAgICAgc2NoZW1hID0gKGJhdGNoZXMgPSBhcmdzKVswXS5zY2hlbWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2hlbWEgPSAoYmF0Y2hlcyA9IGFyZ3NbMF0pWzBdLnNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gYmF0Y2hlcztcbiAgICAgICAgdGhpcy5iYXRjaGVzVW5pb24gPSBiYXRjaGVzLnJlZHVjZSgodW5pb24sIGJhdGNoKSA9PiB1bmlvbi5jb25jYXQoYmF0Y2gpKTtcbiAgICAgICAgLy8gdGhpcy5jb2x1bW5zID0gc2NoZW1hLmZpZWxkcy5tYXAoKF8sIGkpID0+IHRoaXMuYmF0Y2hlc1VuaW9uLmdldENoaWxkQXQoaSkpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYmF0Y2hlc1VuaW9uLmxlbmd0aDtcbiAgICAgICAgdGhpcy5udW1Db2xzID0gdGhpcy5iYXRjaGVzVW5pb24ubnVtQ29scztcbiAgICB9XG4gICAgcHVibGljIGdldChpbmRleDogbnVtYmVyKTogU3RydWN0WydUVmFsdWUnXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhdGNoZXNVbmlvbi5nZXQoaW5kZXgpITtcbiAgICB9XG4gICAgcHVibGljIGdldENvbHVtbihuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uQXQodGhpcy5nZXRDb2x1bW5JbmRleChuYW1lKSk7XG4gICAgfVxuICAgIHB1YmxpYyBnZXRDb2x1bW5BdChpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zW2luZGV4XSB8fCAoXG4gICAgICAgICAgICAgICB0aGlzLl9jb2x1bW5zW2luZGV4XSA9IHRoaXMuYmF0Y2hlc1VuaW9uLmdldENoaWxkQXQoaW5kZXgpKTtcbiAgICB9XG4gICAgcHVibGljIGdldENvbHVtbkluZGV4KG5hbWU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEuZmllbGRzLmZpbmRJbmRleCgoZikgPT4gZi5uYW1lID09PSBuYW1lKTtcbiAgICB9XG4gICAgcHVibGljIFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8U3RydWN0WydUVmFsdWUnXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaGVzVW5pb25bU3ltYm9sLml0ZXJhdG9yXSgpIGFzIGFueTtcbiAgICB9XG4gICAgcHVibGljIGZpbHRlcihwcmVkaWNhdGU6IFByZWRpY2F0ZSk6IERhdGFGcmFtZSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsdGVyZWREYXRhRnJhbWUodGhpcy5iYXRjaGVzLCBwcmVkaWNhdGUpO1xuICAgIH1cbiAgICBwdWJsaWMgc2NhbihuZXh0OiBOZXh0RnVuYykge1xuICAgICAgICBjb25zdCBiYXRjaGVzID0gdGhpcy5iYXRjaGVzLCBudW1CYXRjaGVzID0gYmF0Y2hlcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGJhdGNoSW5kZXggPSAtMTsgKytiYXRjaEluZGV4IDwgbnVtQmF0Y2hlczspIHtcbiAgICAgICAgICAgIC8vIGxvYWQgYmF0Y2hlc1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBiYXRjaGVzW2JhdGNoSW5kZXhdO1xuICAgICAgICAgICAgLy8geWllbGQgYWxsIGluZGljZXNcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gLTEsIG51bVJvd3MgPSBiYXRjaC5sZW5ndGg7ICsraW5kZXggPCBudW1Sb3dzOykge1xuICAgICAgICAgICAgICAgIG5leHQoaW5kZXgsIGJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgY291bnQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMubGVuZ3RoOyB9XG4gICAgcHVibGljIGNvdW50QnkobmFtZTogQ29sIHwgc3RyaW5nKTogQ291bnRCeVJlc3VsdCB7XG4gICAgICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLmJhdGNoZXMsIG51bUJhdGNoZXMgPSBiYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRfYnkgPSB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgPyBuZXcgQ29sKG5hbWUpIDogbmFtZTtcbiAgICAgICAgLy8gQXNzdW1lIHRoYXQgYWxsIGRpY3Rpb25hcnkgYmF0Y2hlcyBhcmUgZGVsdGFzLCB3aGljaCBtZWFucyB0aGF0IHRoZVxuICAgICAgICAvLyBsYXN0IHJlY29yZCBiYXRjaCBoYXMgdGhlIG1vc3QgY29tcGxldGUgZGljdGlvbmFyeVxuICAgICAgICBjb3VudF9ieS5iaW5kKGJhdGNoZXNbbnVtQmF0Y2hlcyAtIDFdKTtcbiAgICAgICAgY29uc3QgdmVjdG9yID0gY291bnRfYnkudmVjdG9yIGFzIERpY3Rpb25hcnlWZWN0b3I7XG4gICAgICAgIGlmICghKHZlY3RvciBpbnN0YW5jZW9mIERpY3Rpb25hcnlWZWN0b3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdW50QnkgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgZGljdGlvbmFyeS1lbmNvZGVkIGNvbHVtbnMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBBZGp1c3QgYXJyYXkgYnl0ZSB3aWR0aCBiYXNlZCBvbiBvdmVyYWxsIGxlbmd0aFxuICAgICAgICAvLyAoZS5nLiBpZiB0aGlzLmxlbmd0aCA8PSAyNTUgdXNlIFVpbnQ4QXJyYXksIGV0Yy4uLilcbiAgICAgICAgY29uc3QgY291bnRzOiBVaW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSh2ZWN0b3IuZGljdGlvbmFyeS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBiYXRjaEluZGV4ID0gLTE7ICsrYmF0Y2hJbmRleCA8IG51bUJhdGNoZXM7KSB7XG4gICAgICAgICAgICAvLyBsb2FkIGJhdGNoZXNcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tiYXRjaEluZGV4XTtcbiAgICAgICAgICAgIC8vIHJlYmluZCB0aGUgY291bnRCeSBDb2xcbiAgICAgICAgICAgIGNvdW50X2J5LmJpbmQoYmF0Y2gpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IChjb3VudF9ieS52ZWN0b3IgYXMgRGljdGlvbmFyeVZlY3RvcikuaW5kaWNpZXM7XG4gICAgICAgICAgICAvLyB5aWVsZCBhbGwgaW5kaWNlc1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAtMSwgbnVtUm93cyA9IGJhdGNoLmxlbmd0aDsgKytpbmRleCA8IG51bVJvd3M7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IGtleXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7IGNvdW50c1trZXldKys7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvdW50QnlSZXN1bHQodmVjdG9yLmRpY3Rpb25hcnksIEludFZlY3Rvci5mcm9tKGNvdW50cykpO1xuICAgIH1cbiAgICBwdWJsaWMgc2VsZWN0KC4uLmNvbHVtbk5hbWVzOiBzdHJpbmdbXSkge1xuICAgICAgICByZXR1cm4gbmV3IFRhYmxlKHRoaXMuYmF0Y2hlcy5tYXAoKGJhdGNoKSA9PiBiYXRjaC5zZWxlY3QoLi4uY29sdW1uTmFtZXMpKSk7XG4gICAgfVxuICAgIHB1YmxpYyB0b1N0cmluZyhzZXBhcmF0b3I/OiBzdHJpbmcpIHtcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLnJvd3NUb1N0cmluZyhzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICBzdHIgKz0gcm93ICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcHVibGljIHJvd3NUb1N0cmluZyhzZXBhcmF0b3IgPSAnIHwgJyk6IFRhYmxlVG9TdHJpbmdJdGVyYXRvciB7XG4gICAgICAgIHJldHVybiBuZXcgVGFibGVUb1N0cmluZ0l0ZXJhdG9yKHRhYmxlUm93c1RvU3RyaW5nKHRoaXMsIHNlcGFyYXRvcikpO1xuICAgIH1cbn1cblxuY2xhc3MgRmlsdGVyZWREYXRhRnJhbWUgaW1wbGVtZW50cyBEYXRhRnJhbWUge1xuICAgIHByaXZhdGUgcHJlZGljYXRlOiBQcmVkaWNhdGU7XG4gICAgcHJpdmF0ZSBiYXRjaGVzOiBSZWNvcmRCYXRjaFtdO1xuICAgIGNvbnN0cnVjdG9yIChiYXRjaGVzOiBSZWNvcmRCYXRjaFtdLCBwcmVkaWNhdGU6IFByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLmJhdGNoZXMgPSBiYXRjaGVzO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB9XG4gICAgcHVibGljIHNjYW4obmV4dDogTmV4dEZ1bmMpIHtcbiAgICAgICAgLy8gaW5saW5lZCB2ZXJzaW9uIG9mIHRoaXM6XG4gICAgICAgIC8vIHRoaXMucGFyZW50LnNjYW4oKGlkeCwgY29sdW1ucykgPT4ge1xuICAgICAgICAvLyAgICAgaWYgKHRoaXMucHJlZGljYXRlKGlkeCwgY29sdW1ucykpIG5leHQoaWR4LCBjb2x1bW5zKTtcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLmJhdGNoZXM7XG4gICAgICAgIGNvbnN0IG51bUJhdGNoZXMgPSBiYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgYmF0Y2hJbmRleCA9IC0xOyArK2JhdGNoSW5kZXggPCBudW1CYXRjaGVzOykge1xuICAgICAgICAgICAgLy8gbG9hZCBiYXRjaGVzXG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbYmF0Y2hJbmRleF07XG4gICAgICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSB0aGlzLnByZWRpY2F0ZS5iaW5kKGJhdGNoKTtcbiAgICAgICAgICAgIC8vIHlpZWxkIGFsbCBpbmRpY2VzXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IC0xLCBudW1Sb3dzID0gYmF0Y2gubGVuZ3RoOyArK2luZGV4IDwgbnVtUm93czspIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKGluZGV4LCBiYXRjaCkpIHsgbmV4dChpbmRleCwgYmF0Y2gpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVibGljIGNvdW50KCk6IG51bWJlciB7XG4gICAgICAgIC8vIGlubGluZWQgdmVyc2lvbiBvZiB0aGlzOlxuICAgICAgICAvLyBsZXQgc3VtID0gMDtcbiAgICAgICAgLy8gdGhpcy5wYXJlbnQuc2NhbigoaWR4LCBjb2x1bW5zKSA9PiB7XG4gICAgICAgIC8vICAgICBpZiAodGhpcy5wcmVkaWNhdGUoaWR4LCBjb2x1bW5zKSkgKytzdW07XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyByZXR1cm4gc3VtO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IHRoaXMuYmF0Y2hlcztcbiAgICAgICAgY29uc3QgbnVtQmF0Y2hlcyA9IGJhdGNoZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBiYXRjaEluZGV4ID0gLTE7ICsrYmF0Y2hJbmRleCA8IG51bUJhdGNoZXM7KSB7XG4gICAgICAgICAgICAvLyBsb2FkIGJhdGNoZXNcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tiYXRjaEluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHRoaXMucHJlZGljYXRlLmJpbmQoYmF0Y2gpO1xuICAgICAgICAgICAgLy8geWllbGQgYWxsIGluZGljZXNcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gLTEsIG51bVJvd3MgPSBiYXRjaC5sZW5ndGg7ICsraW5kZXggPCBudW1Sb3dzOykge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoaW5kZXgsIGJhdGNoKSkgeyArK3N1bTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuICAgIHB1YmxpYyBmaWx0ZXIocHJlZGljYXRlOiBQcmVkaWNhdGUpOiBEYXRhRnJhbWUge1xuICAgICAgICByZXR1cm4gbmV3IEZpbHRlcmVkRGF0YUZyYW1lKFxuICAgICAgICAgICAgdGhpcy5iYXRjaGVzLFxuICAgICAgICAgICAgdGhpcy5wcmVkaWNhdGUuYW5kKHByZWRpY2F0ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcHVibGljIGNvdW50QnkobmFtZTogQ29sIHwgc3RyaW5nKTogQ291bnRCeVJlc3VsdCB7XG4gICAgICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLmJhdGNoZXMsIG51bUJhdGNoZXMgPSBiYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRfYnkgPSB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgPyBuZXcgQ29sKG5hbWUpIDogbmFtZTtcbiAgICAgICAgLy8gQXNzdW1lIHRoYXQgYWxsIGRpY3Rpb25hcnkgYmF0Y2hlcyBhcmUgZGVsdGFzLCB3aGljaCBtZWFucyB0aGF0IHRoZVxuICAgICAgICAvLyBsYXN0IHJlY29yZCBiYXRjaCBoYXMgdGhlIG1vc3QgY29tcGxldGUgZGljdGlvbmFyeVxuICAgICAgICBjb3VudF9ieS5iaW5kKGJhdGNoZXNbbnVtQmF0Y2hlcyAtIDFdKTtcbiAgICAgICAgY29uc3QgdmVjdG9yID0gY291bnRfYnkudmVjdG9yIGFzIERpY3Rpb25hcnlWZWN0b3I7XG4gICAgICAgIGlmICghKHZlY3RvciBpbnN0YW5jZW9mIERpY3Rpb25hcnlWZWN0b3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdW50QnkgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgZGljdGlvbmFyeS1lbmNvZGVkIGNvbHVtbnMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBBZGp1c3QgYXJyYXkgYnl0ZSB3aWR0aCBiYXNlZCBvbiBvdmVyYWxsIGxlbmd0aFxuICAgICAgICAvLyAoZS5nLiBpZiB0aGlzLmxlbmd0aCA8PSAyNTUgdXNlIFVpbnQ4QXJyYXksIGV0Yy4uLilcbiAgICAgICAgY29uc3QgY291bnRzOiBVaW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSh2ZWN0b3IuZGljdGlvbmFyeS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBiYXRjaEluZGV4ID0gLTE7ICsrYmF0Y2hJbmRleCA8IG51bUJhdGNoZXM7KSB7XG4gICAgICAgICAgICAvLyBsb2FkIGJhdGNoZXNcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tiYXRjaEluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHRoaXMucHJlZGljYXRlLmJpbmQoYmF0Y2gpO1xuICAgICAgICAgICAgLy8gcmViaW5kIHRoZSBjb3VudEJ5IENvbFxuICAgICAgICAgICAgY291bnRfYnkuYmluZChiYXRjaCk7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gKGNvdW50X2J5LnZlY3RvciBhcyBEaWN0aW9uYXJ5VmVjdG9yKS5pbmRpY2llcztcbiAgICAgICAgICAgIC8vIHlpZWxkIGFsbCBpbmRpY2VzXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IC0xLCBudW1Sb3dzID0gYmF0Y2gubGVuZ3RoOyArK2luZGV4IDwgbnVtUm93czspIHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0ga2V5cy5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IG51bGwgJiYgcHJlZGljYXRlKGluZGV4LCBiYXRjaCkpIHsgY291bnRzW2tleV0rKzsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ291bnRCeVJlc3VsdCh2ZWN0b3IuZGljdGlvbmFyeSwgSW50VmVjdG9yLmZyb20oY291bnRzKSk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ291bnRCeVJlc3VsdCBleHRlbmRzIFRhYmxlIGltcGxlbWVudHMgRGF0YUZyYW1lIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXM6IFZlY3RvciwgY291bnRzOiBJbnRWZWN0b3I8YW55Pikge1xuICAgICAgICBzdXBlcihcbiAgICAgICAgICAgIG5ldyBSZWNvcmRCYXRjaChuZXcgU2NoZW1hKFtcbiAgICAgICAgICAgICAgICBuZXcgRmllbGQoJ3ZhbHVlcycsIHZhbHVlcy50eXBlKSxcbiAgICAgICAgICAgICAgICBuZXcgRmllbGQoJ2NvdW50cycsIGNvdW50cy50eXBlKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBjb3VudHMubGVuZ3RoLCBbdmFsdWVzLCBjb3VudHNdXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBwdWJsaWMgdG9KU09OKCk6IE9iamVjdCB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0Q29sdW1uQXQoMCk7XG4gICAgICAgIGNvbnN0IGNvdW50cyA9IHRoaXMuZ2V0Q29sdW1uQXQoMSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9IGFzIHsgW2s6IHN0cmluZ106IG51bWJlciB8IG51bGwgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IC0xOyArK2kgPCB0aGlzLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdFt2YWx1ZXMuZ2V0KGkpXSA9IGNvdW50cy5nZXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUYWJsZVRvU3RyaW5nSXRlcmF0b3IgaW1wbGVtZW50cyBJdGVyYWJsZUl0ZXJhdG9yPHN0cmluZz4ge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaXRlcmF0b3I6IEl0ZXJhYmxlSXRlcmF0b3I8c3RyaW5nPikge31cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHsgcmV0dXJuIHRoaXMuaXRlcmF0b3I7IH1cbiAgICBuZXh0KHZhbHVlPzogYW55KSB7IHJldHVybiB0aGlzLml0ZXJhdG9yLm5leHQodmFsdWUpOyB9XG4gICAgdGhyb3coZXJyb3I/OiBhbnkpIHsgcmV0dXJuIHRoaXMuaXRlcmF0b3IudGhyb3cgJiYgdGhpcy5pdGVyYXRvci50aHJvdyhlcnJvcikgfHwgeyBkb25lOiB0cnVlLCB2YWx1ZTogJycgfTsgfVxuICAgIHJldHVybih2YWx1ZT86IGFueSkgeyByZXR1cm4gdGhpcy5pdGVyYXRvci5yZXR1cm4gJiYgdGhpcy5pdGVyYXRvci5yZXR1cm4odmFsdWUpIHx8IHsgZG9uZTogdHJ1ZSwgdmFsdWU6ICcnIH07IH1cbiAgICBwaXBlKHN0cmVhbTogTm9kZUpTLldyaXRhYmxlU3RyZWFtKSB7XG4gICAgICAgIGxldCByZXM6IEl0ZXJhdG9yUmVzdWx0PHN0cmluZz47XG4gICAgICAgIGxldCB3cml0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0ud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocmVzID0gdGhpcy5uZXh0KCkpLmRvbmUpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChzdHJlYW0ud3JpdGUocmVzLnZhbHVlICsgJ1xcbicsICd1dGY4JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXMgfHwgIXJlcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoJ2RyYWluJywgd3JpdGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0cmVhbSBhcyBhbnkpLmlzVFRZKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVuZCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdyaXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiogdGFibGVSb3dzVG9TdHJpbmcodGFibGU6IFRhYmxlLCBzZXBhcmF0b3IgPSAnIHwgJykge1xuICAgIGNvbnN0IGZpZWxkcyA9IHRhYmxlLnNjaGVtYS5maWVsZHM7XG4gICAgY29uc3QgaGVhZGVyID0gWydyb3dfaWQnLCAuLi5maWVsZHMubWFwKChmKSA9PiBgJHtmfWApXS5tYXAoc3RyaW5naWZ5KTtcbiAgICBjb25zdCBtYXhDb2x1bW5XaWR0aHMgPSBoZWFkZXIubWFwKHggPT4geC5sZW5ndGgpO1xuICAgIC8vIFBhc3Mgb25lIHRvIGNvbnZlcnQgdG8gc3RyaW5ncyBhbmQgY291bnQgbWF4IGNvbHVtbiB3aWR0aHNcbiAgICBmb3IgKGxldCBpID0gLTEsIG4gPSB0YWJsZS5sZW5ndGggLSAxOyArK2kgPCBuOykge1xuICAgICAgICBsZXQgdmFsLCByb3cgPSBbaSwgLi4udGFibGUuZ2V0KGkpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IC0xLCBrID0gcm93Lmxlbmd0aDsgKytqIDwgazsgKSB7XG4gICAgICAgICAgICB2YWwgPSBzdHJpbmdpZnkocm93W2pdKTtcbiAgICAgICAgICAgIG1heENvbHVtbldpZHRoc1tqXSA9IE1hdGgubWF4KG1heENvbHVtbldpZHRoc1tqXSwgdmFsLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgeWllbGQgaGVhZGVyLm1hcCgoeCwgaikgPT4gbGVmdFBhZCh4LCAnICcsIG1heENvbHVtbldpZHRoc1tqXSkpLmpvaW4oc2VwYXJhdG9yKTtcbiAgICBmb3IgKGxldCBpID0gLTEsIG4gPSB0YWJsZS5sZW5ndGg7ICsraSA8IG47KSB7XG4gICAgICAgIHlpZWxkIFtpLCAuLi50YWJsZS5nZXQoaSldXG4gICAgICAgICAgICAubWFwKCh4KSA9PiBzdHJpbmdpZnkoeCkpXG4gICAgICAgICAgICAubWFwKCh4LCBqKSA9PiBsZWZ0UGFkKHgsICcgJywgbWF4Q29sdW1uV2lkdGhzW2pdKSlcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsZWZ0UGFkKHN0cjogc3RyaW5nLCBmaWxsOiBzdHJpbmcsIG46IG51bWJlcikge1xuICAgIHJldHVybiAobmV3IEFycmF5KG4gKyAxKS5qb2luKGZpbGwpICsgc3RyKS5zbGljZSgtMSAqIG4pO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoeDogYW55KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJyA/IGBcIiR7eH1cImAgOiBBcnJheUJ1ZmZlci5pc1ZpZXcoeCkgPyBgWyR7eH1dYCA6IEpTT04uc3RyaW5naWZ5KHgpO1xufVxuIl19
