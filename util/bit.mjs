// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
/** @ignore */
export function getBool(_data, _index, byte, bit) {
    return (byte & 1 << bit) !== 0;
}
/** @ignore */
export function getBit(_data, _index, byte, bit) {
    return (byte & 1 << bit) >> bit;
}
/** @ignore */
export function setBool(bytes, index, value) {
    return value ?
        !!(bytes[index >> 3] |= (1 << (index % 8))) || true :
        !(bytes[index >> 3] &= ~(1 << (index % 8))) && false;
}
/** @ignore */
export function truncateBitmap(offset, length, bitmap) {
    const alignedSize = (bitmap.byteLength + 7) & ~7;
    if (offset > 0 || bitmap.byteLength < alignedSize) {
        const bytes = new Uint8Array(alignedSize);
        bytes.set((offset % 8 === 0)
            // If the offset is a multiple of 8 bits, it's safe to slice the bitmap
            ? bitmap.subarray(offset >> 3)
            // Otherwise iterate each bit from the offset and return a new one
            : packBools(iterateBits(bitmap, offset, length, null, getBool)));
        return bytes;
    }
    return bitmap;
}
/** @ignore */
export function packBools(values) {
    let n = 0, i = 0;
    let xs = [];
    let bit = 0, byte = 0;
    for (const value of values) {
        value && (byte |= 1 << bit);
        if (++bit === 8) {
            xs[i++] = byte;
            byte = bit = 0;
        }
    }
    if (i === 0 || bit > 0) {
        xs[i++] = byte;
    }
    if (i % 8 && (n = i + 8 - i % 8)) {
        do {
            xs[i] = 0;
        } while (++i < n);
    }
    return new Uint8Array(xs);
}
/** @ignore */
export function* iterateBits(bytes, begin, length, context, get) {
    let bit = begin % 8;
    let byteIndex = begin >> 3;
    let index = 0, remaining = length;
    for (; remaining > 0; bit = 0) {
        let byte = bytes[byteIndex++];
        do {
            yield get(context, index++, byte, bit);
        } while (--remaining > 0 && ++bit < 8);
    }
}
/**
 * Compute the population count (the number of bits set to 1) for a range of bits in a Uint8Array.
 * @param vector The Uint8Array of bits for which to compute the population count.
 * @param lhs The range's left-hand side (or start) bit
 * @param rhs The range's right-hand side (or end) bit
 */
/** @ignore */
export function popcnt_bit_range(data, lhs, rhs) {
    if (rhs - lhs <= 0) {
        return 0;
    }
    // If the bit range is less than one byte, sum the 1 bits in the bit range
    if (rhs - lhs < 8) {
        let sum = 0;
        for (const bit of iterateBits(data, lhs, rhs - lhs, data, getBit)) {
            sum += bit;
        }
        return sum;
    }
    // Get the next lowest multiple of 8 from the right hand side
    const rhsInside = rhs >> 3 << 3;
    // Get the next highest multiple of 8 from the left hand side
    const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
    return (
    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    popcnt_bit_range(data, lhs, lhsInside) +
        // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
        popcnt_bit_range(data, rhsInside, rhs) +
        // Get the popcnt of all bits between the left and right hand sides' multiples of 8
        popcnt_array(data, lhsInside >> 3, (rhsInside - lhsInside) >> 3));
}
/** @ignore */
export function popcnt_array(arr, byteOffset, byteLength) {
    let cnt = 0, pos = byteOffset | 0;
    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
    while (len - pos >= 4) {
        cnt += popcnt_uint32(view.getUint32(pos));
        pos += 4;
    }
    while (len - pos >= 2) {
        cnt += popcnt_uint32(view.getUint16(pos));
        pos += 2;
    }
    while (len - pos >= 1) {
        cnt += popcnt_uint32(view.getUint8(pos));
        pos += 1;
    }
    return cnt;
}
/** @ignore */
export function popcnt_uint32(uint32) {
    let i = uint32 | 0;
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    return (((i + (i >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUFDLEdBQUcsVUFBVSxDQUFDLENBQUM7SUFDaEQsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDaEUsQ0FBQyIsImZpbGUiOiJ1dGlsL2JpdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvb2woX2RhdGE6IGFueSwgX2luZGV4OiBudW1iZXIsIGJ5dGU6IG51bWJlciwgYml0OiBudW1iZXIpIHtcbiAgICByZXR1cm4gKGJ5dGUgJiAxIDw8IGJpdCkgIT09IDA7XG59XG5cbi8qKiBAaWdub3JlICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qml0KF9kYXRhOiBhbnksIF9pbmRleDogbnVtYmVyLCBieXRlOiBudW1iZXIsIGJpdDogbnVtYmVyKTogMCB8IDEge1xuICAgIHJldHVybiAoYnl0ZSAmIDEgPDwgYml0KSA+PiBiaXQgYXMgKDAgfCAxKTtcbn1cblxuLyoqIEBpZ25vcmUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRCb29sKGJ5dGVzOiBVaW50OEFycmF5LCBpbmRleDogbnVtYmVyLCB2YWx1ZTogYW55KSB7XG4gICAgcmV0dXJuIHZhbHVlID9cbiAgICAgICAgISEoYnl0ZXNbaW5kZXggPj4gM10gfD0gICgxIDw8IChpbmRleCAlIDgpKSkgfHwgdHJ1ZSA6XG4gICAgICAgICEoYnl0ZXNbaW5kZXggPj4gM10gJj0gfigxIDw8IChpbmRleCAlIDgpKSkgJiYgZmFsc2UgO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRydW5jYXRlQml0bWFwKG9mZnNldDogbnVtYmVyLCBsZW5ndGg6IG51bWJlciwgYml0bWFwOiBVaW50OEFycmF5KSB7XG4gICAgY29uc3QgYWxpZ25lZFNpemUgPSAoYml0bWFwLmJ5dGVMZW5ndGggKyA3KSAmIH43O1xuICAgIGlmIChvZmZzZXQgPiAwIHx8IGJpdG1hcC5ieXRlTGVuZ3RoIDwgYWxpZ25lZFNpemUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhbGlnbmVkU2l6ZSk7XG4gICAgICAgIGJ5dGVzLnNldCgob2Zmc2V0ICUgOCA9PT0gMClcbiAgICAgICAgICAgIC8vIElmIHRoZSBvZmZzZXQgaXMgYSBtdWx0aXBsZSBvZiA4IGJpdHMsIGl0J3Mgc2FmZSB0byBzbGljZSB0aGUgYml0bWFwXG4gICAgICAgICAgICA/IGJpdG1hcC5zdWJhcnJheShvZmZzZXQgPj4gMylcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdGVyYXRlIGVhY2ggYml0IGZyb20gdGhlIG9mZnNldCBhbmQgcmV0dXJuIGEgbmV3IG9uZVxuICAgICAgICAgICAgOiBwYWNrQm9vbHMoaXRlcmF0ZUJpdHMoYml0bWFwLCBvZmZzZXQsIGxlbmd0aCwgbnVsbCwgZ2V0Qm9vbCkpKTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICByZXR1cm4gYml0bWFwO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2tCb29scyh2YWx1ZXM6IEl0ZXJhYmxlPGFueT4pIHtcbiAgICBsZXQgbiA9IDAsIGkgPSAwO1xuICAgIGxldCB4czogbnVtYmVyW10gPSBbXTtcbiAgICBsZXQgYml0ID0gMCwgYnl0ZSA9IDA7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWUgJiYgKGJ5dGUgfD0gMSA8PCBiaXQpO1xuICAgICAgICBpZiAoKytiaXQgPT09IDgpIHtcbiAgICAgICAgICAgIHhzW2krK10gPSBieXRlO1xuICAgICAgICAgICAgYnl0ZSA9IGJpdCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IDAgfHwgYml0ID4gMCkgeyB4c1tpKytdID0gYnl0ZTsgfVxuICAgIGlmIChpICUgOCAmJiAobiA9IGkgKyA4IC0gaSAlIDgpKSB7XG4gICAgICAgIGRvIHsgeHNbaV0gPSAwOyB9IHdoaWxlICgrK2kgPCBuKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhzKTtcbn1cblxuLyoqIEBpZ25vcmUgKi9cbmV4cG9ydCBmdW5jdGlvbiogaXRlcmF0ZUJpdHM8VD4oYnl0ZXM6IFVpbnQ4QXJyYXksIGJlZ2luOiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBjb250ZXh0OiBhbnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKGNvbnRleHQ6IGFueSwgaW5kZXg6IG51bWJlciwgYnl0ZTogbnVtYmVyLCBiaXQ6IG51bWJlcikgPT4gVCkge1xuICAgIGxldCBiaXQgPSBiZWdpbiAlIDg7XG4gICAgbGV0IGJ5dGVJbmRleCA9IGJlZ2luID4+IDM7XG4gICAgbGV0IGluZGV4ID0gMCwgcmVtYWluaW5nID0gbGVuZ3RoO1xuICAgIGZvciAoOyByZW1haW5pbmcgPiAwOyBiaXQgPSAwKSB7XG4gICAgICAgIGxldCBieXRlID0gYnl0ZXNbYnl0ZUluZGV4KytdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB5aWVsZCBnZXQoY29udGV4dCwgaW5kZXgrKywgYnl0ZSwgYml0KTtcbiAgICAgICAgfSB3aGlsZSAoLS1yZW1haW5pbmcgPiAwICYmICsrYml0IDwgOCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHBvcHVsYXRpb24gY291bnQgKHRoZSBudW1iZXIgb2YgYml0cyBzZXQgdG8gMSkgZm9yIGEgcmFuZ2Ugb2YgYml0cyBpbiBhIFVpbnQ4QXJyYXkuXG4gKiBAcGFyYW0gdmVjdG9yIFRoZSBVaW50OEFycmF5IG9mIGJpdHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIHBvcHVsYXRpb24gY291bnQuXG4gKiBAcGFyYW0gbGhzIFRoZSByYW5nZSdzIGxlZnQtaGFuZCBzaWRlIChvciBzdGFydCkgYml0XG4gKiBAcGFyYW0gcmhzIFRoZSByYW5nZSdzIHJpZ2h0LWhhbmQgc2lkZSAob3IgZW5kKSBiaXRcbiAqL1xuLyoqIEBpZ25vcmUgKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3BjbnRfYml0X3JhbmdlKGRhdGE6IFVpbnQ4QXJyYXksIGxoczogbnVtYmVyLCByaHM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHJocyAtIGxocyA8PSAwKSB7IHJldHVybiAwOyB9XG4gICAgLy8gSWYgdGhlIGJpdCByYW5nZSBpcyBsZXNzIHRoYW4gb25lIGJ5dGUsIHN1bSB0aGUgMSBiaXRzIGluIHRoZSBiaXQgcmFuZ2VcbiAgICBpZiAocmhzIC0gbGhzIDwgOCkge1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBiaXQgb2YgaXRlcmF0ZUJpdHMoZGF0YSwgbGhzLCByaHMgLSBsaHMsIGRhdGEsIGdldEJpdCkpIHtcbiAgICAgICAgICAgIHN1bSArPSBiaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBuZXh0IGxvd2VzdCBtdWx0aXBsZSBvZiA4IGZyb20gdGhlIHJpZ2h0IGhhbmQgc2lkZVxuICAgIGNvbnN0IHJoc0luc2lkZSA9IHJocyA+PiAzIDw8IDM7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgbXVsdGlwbGUgb2YgOCBmcm9tIHRoZSBsZWZ0IGhhbmQgc2lkZVxuICAgIGNvbnN0IGxoc0luc2lkZSA9IGxocyArIChsaHMgJSA4ID09PSAwID8gMCA6IDggLSBsaHMgJSA4KTtcbiAgICByZXR1cm4gKFxuICAgICAgICAvLyBHZXQgdGhlIHBvcGNudCBvZiBiaXRzIGJldHdlZW4gdGhlIGxlZnQgaGFuZCBzaWRlLCBhbmQgdGhlIG5leHQgaGlnaGVzdCBtdWx0aXBsZSBvZiA4XG4gICAgICAgIHBvcGNudF9iaXRfcmFuZ2UoZGF0YSwgbGhzLCBsaHNJbnNpZGUpICtcbiAgICAgICAgLy8gR2V0IHRoZSBwb3BjbnQgb2YgYml0cyBiZXR3ZWVuIHRoZSByaWdodCBoYW5kIHNpZGUsIGFuZCB0aGUgbmV4dCBsb3dlc3QgbXVsdGlwbGUgb2YgOFxuICAgICAgICBwb3BjbnRfYml0X3JhbmdlKGRhdGEsIHJoc0luc2lkZSwgcmhzKSArXG4gICAgICAgIC8vIEdldCB0aGUgcG9wY250IG9mIGFsbCBiaXRzIGJldHdlZW4gdGhlIGxlZnQgYW5kIHJpZ2h0IGhhbmQgc2lkZXMnIG11bHRpcGxlcyBvZiA4XG4gICAgICAgIHBvcGNudF9hcnJheShkYXRhLCBsaHNJbnNpZGUgPj4gMywgKHJoc0luc2lkZSAtIGxoc0luc2lkZSkgPj4gMylcbiAgICApO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvcGNudF9hcnJheShhcnI6IEFycmF5QnVmZmVyVmlldywgYnl0ZU9mZnNldD86IG51bWJlciwgYnl0ZUxlbmd0aD86IG51bWJlcikge1xuICAgIGxldCBjbnQgPSAwLCBwb3MgPSBieXRlT2Zmc2V0ISB8IDA7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IGxlbiA9ICBieXRlTGVuZ3RoID09PSB2b2lkIDAgPyBhcnIuYnl0ZUxlbmd0aCA6IHBvcyArIGJ5dGVMZW5ndGg7XG4gICAgd2hpbGUgKGxlbiAtIHBvcyA+PSA0KSB7XG4gICAgICAgIGNudCArPSBwb3BjbnRfdWludDMyKHZpZXcuZ2V0VWludDMyKHBvcykpO1xuICAgICAgICBwb3MgKz0gNDtcbiAgICB9XG4gICAgd2hpbGUgKGxlbiAtIHBvcyA+PSAyKSB7XG4gICAgICAgIGNudCArPSBwb3BjbnRfdWludDMyKHZpZXcuZ2V0VWludDE2KHBvcykpO1xuICAgICAgICBwb3MgKz0gMjtcbiAgICB9XG4gICAgd2hpbGUgKGxlbiAtIHBvcyA+PSAxKSB7XG4gICAgICAgIGNudCArPSBwb3BjbnRfdWludDMyKHZpZXcuZ2V0VWludDgocG9zKSk7XG4gICAgICAgIHBvcyArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gY250O1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvcGNudF91aW50MzIodWludDMyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBpID0gdWludDMyIHwgMDtcbiAgICBpID0gaSAtICgoaSA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgICBpID0gKGkgJiAweDMzMzMzMzMzKSArICgoaSA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgICByZXR1cm4gKCgoaSArIChpID4+PiA0KSkgJiAweDBGMEYwRjBGKSAqIDB4MDEwMTAxMDEpID4+PiAyNDtcbn1cbiJdfQ==
