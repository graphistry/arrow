"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const flatbuffers_1 = require("flatbuffers");
const utf8_1 = require("../util/utf8");
var ByteBuffer = flatbuffers_1.flatbuffers.ByteBuffer;
const compat_1 = require("./compat");
/** @ignore */
const SharedArrayBuf = (typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer);
/** @ignore */
function collapseContiguousByteRanges(chunks) {
    for (let x, y, i = 0; ++i < chunks.length;) {
        x = chunks[i - 1];
        y = chunks[i - 0];
        // continue x and y don't share the same underlying ArrayBuffer
        if (!x || !y || x.buffer !== y.buffer) {
            continue;
        }
        const { byteOffset: xOffset, byteLength: xLen } = x;
        const { byteOffset: yOffset, byteLength: yLen } = y;
        // continue if the byte ranges of x and y aren't contiguous
        if ((xOffset + xLen) < yOffset || (yOffset + yLen) < xOffset) {
            continue;
        }
        chunks.splice(--i, 2, new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen));
    }
    return chunks;
}
/** @ignore */
function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
}
exports.memcpy = memcpy;
/** @ignore */
function joinUint8Arrays(chunks, size) {
    // collapse chunks that share the same underlying ArrayBuffer and whose byte ranges overlap,
    // to avoid unnecessarily copying the bytes to do this buffer join. This is a common case during
    // streaming, where we may be reading partial byte ranges out of the same underlying ArrayBuffer
    chunks = collapseContiguousByteRanges(chunks);
    let offset = 0, index = -1, numChunks = chunks.length;
    let chunksLen = chunks.reduce((x, y) => x + y.byteLength, 0);
    let source, sliced, buffer;
    let length = Math.min(chunksLen, typeof size === 'number' ? size : Infinity);
    while (++index < numChunks) {
        source = chunks[index];
        sliced = source.subarray(0, Math.min(source.length, length - offset));
        if (length <= (offset + sliced.length)) {
            if (sliced.length < source.length) {
                chunks[index] = source.subarray(sliced.length);
            }
            else if (sliced.length === source.length) {
                index++;
            }
            buffer ? memcpy(buffer, sliced, offset) : (buffer = sliced);
            break;
        }
        (buffer || (buffer = new Uint8Array(length))).set(sliced, offset);
        offset += sliced.length;
    }
    return [buffer || new Uint8Array(0), chunks.slice(index)];
}
exports.joinUint8Arrays = joinUint8Arrays;
/** @ignore */
function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = compat_1.isIteratorResult(input) ? input.value : input;
    if (!value) {
        return new ArrayBufferViewCtor(0);
    }
    if (typeof value === 'string') {
        value = utf8_1.encodeUtf8(value);
    }
    if (value instanceof ArrayBufferViewCtor) {
        return value.constructor === ArrayBufferViewCtor ? value :
            // Node's `Buffer` class passes the `instanceof Uint8Array` check, but we need
            // a real Uint8Array, since Buffer#slice isn't the same as Uint8Array#slice :/
            new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
    }
    if (value instanceof ArrayBuffer) {
        return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
        return new ArrayBufferViewCtor(value);
    }
    if (value instanceof ByteBuffer) {
        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0)
        : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
}
exports.toArrayBufferView = toArrayBufferView;
/** @ignore */ exports.toInt8Array = (input) => toArrayBufferView(Int8Array, input);
/** @ignore */ exports.toInt16Array = (input) => toArrayBufferView(Int16Array, input);
/** @ignore */ exports.toInt32Array = (input) => toArrayBufferView(Int32Array, input);
/** @ignore */ exports.toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
/** @ignore */ exports.toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
/** @ignore */ exports.toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
/** @ignore */ exports.toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
/** @ignore */ exports.toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
/** @ignore */ exports.toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
/** @ignore */
const pump = (iterator) => { iterator.next(); return iterator; };
/** @ignore */
function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) { yield x; };
    const buffers = (typeof source === 'string') ? wrap(source)
        : (ArrayBuffer.isView(source)) ? wrap(source)
            : (source instanceof ArrayBuffer) ? wrap(source)
                : (source instanceof SharedArrayBuf) ? wrap(source)
                    : !compat_1.isIterable(source) ? wrap(source) : source;
    yield* pump((function* (it) {
        let r = null;
        do {
            r = it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
    })(buffers[Symbol.iterator]()));
}
exports.toArrayBufferViewIterator = toArrayBufferViewIterator;
/** @ignore */ exports.toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
/** @ignore */ exports.toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
/** @ignore */ exports.toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
/** @ignore */ exports.toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
/** @ignore */ exports.toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
/** @ignore */ exports.toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
/** @ignore */ exports.toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
/** @ignore */ exports.toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
/** @ignore */ exports.toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
/** @ignore */
function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    return tslib_1.__asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
        // if a Promise, unwrap the Promise and iterate the resolved value
        if (compat_1.isPromise(source)) {
            return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield tslib_1.__await(source))))));
        }
        const wrap = function (x) { return tslib_1.__asyncGenerator(this, arguments, function* () { yield yield tslib_1.__await(yield tslib_1.__await(x)); }); };
        const emit = function (source) {
            return tslib_1.__asyncGenerator(this, arguments, function* () {
                yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump((function* (it) {
                    let r = null;
                    do {
                        r = it.next(yield r && r.value);
                    } while (!r.done);
                })(source[Symbol.iterator]())))));
            });
        };
        const buffers = (typeof source === 'string') ? wrap(source) // if string, wrap in an AsyncIterableIterator
            : (ArrayBuffer.isView(source)) ? wrap(source) // if TypedArray, wrap in an AsyncIterableIterator
                : (source instanceof ArrayBuffer) ? wrap(source) // if ArrayBuffer, wrap in an AsyncIterableIterator
                    : (source instanceof SharedArrayBuf) ? wrap(source) // if SharedArrayBuffer, wrap in an AsyncIterableIterator
                        : compat_1.isIterable(source) ? emit(source) // If Iterable, wrap in an AsyncIterableIterator and compose the `next` values
                            : !compat_1.isAsyncIterable(source) ? wrap(source) // If not an AsyncIterable, treat as a sentinel and wrap in an AsyncIterableIterator
                                : source; // otherwise if AsyncIterable, use it
        yield tslib_1.__await(// otherwise if AsyncIterable, use it
        yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump((function (it) {
            return tslib_1.__asyncGenerator(this, arguments, function* () {
                let r = null;
                do {
                    r = yield tslib_1.__await(it.next(yield yield tslib_1.__await(toArrayBufferView(ArrayCtor, r))));
                } while (!r.done);
            });
        })(buffers[Symbol.asyncIterator]())))));
    });
}
exports.toArrayBufferViewAsyncIterator = toArrayBufferViewAsyncIterator;
/** @ignore */ exports.toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
/** @ignore */ exports.toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
/** @ignore */ exports.toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
/** @ignore */ exports.toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
/** @ignore */ exports.toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
/** @ignore */ exports.toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
/** @ignore */ exports.toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
/** @ignore */ exports.toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
/** @ignore */ exports.toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
/** @ignore */
function rebaseValueOffsets(offset, length, valueOffsets) {
    // If we have a non-zero offset, create a new offsets array with the values
    // shifted by the start offset, such that the new start offset is 0
    if (offset !== 0) {
        valueOffsets = valueOffsets.slice(0, length + 1);
        for (let i = -1; ++i <= length;) {
            valueOffsets[i] += offset;
        }
    }
    return valueOffsets;
}
exports.rebaseValueOffsets = rebaseValueOffsets;
/** @ignore */
function compareArrayLike(a, b) {
    let i = 0, n = a.length;
    if (n !== b.length) {
        return false;
    }
    if (n > 0) {
        do {
            if (a[i] !== b[i]) {
                return false;
            }
        } while (++i < n);
    }
    return true;
}
exports.compareArrayLike = compareArrayLike;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUFLLENBQUMsQ0FBQyxNQUFNLEVBQUU7UUFBRSxPQUFPLEtBQUssQ0FBQztLQUFFO0lBQ3JDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNQLEdBQUc7WUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7YUFBRTtTQUFFLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0tBQy9EO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDaEIsQ0FBQztBQVBELDRDQU9DIiwiZmlsZSI6InV0aWwvYnVmZmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmltcG9ydCB7IGZsYXRidWZmZXJzIH0gZnJvbSAnZmxhdGJ1ZmZlcnMnO1xuaW1wb3J0IHsgZW5jb2RlVXRmOCB9IGZyb20gJy4uL3V0aWwvdXRmOCc7XG5pbXBvcnQgQnl0ZUJ1ZmZlciA9IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXI7XG5pbXBvcnQgeyBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvciB9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgaXNQcm9taXNlLCBpc0l0ZXJhYmxlLCBpc0FzeW5jSXRlcmFibGUsIGlzSXRlcmF0b3JSZXN1bHQgfSBmcm9tICcuL2NvbXBhdCc7XG5cbi8qKiBAaWdub3JlICovXG5jb25zdCBTaGFyZWRBcnJheUJ1ZiA9ICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiBBcnJheUJ1ZmZlcik7XG5cbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBjb2xsYXBzZUNvbnRpZ3VvdXNCeXRlUmFuZ2VzKGNodW5rczogVWludDhBcnJheVtdKSB7XG4gICAgZm9yIChsZXQgeCwgeSwgaSA9IDA7ICsraSA8IGNodW5rcy5sZW5ndGg7KSB7XG4gICAgICAgIHggPSBjaHVua3NbaSAtIDFdO1xuICAgICAgICB5ID0gY2h1bmtzW2kgLSAwXTtcbiAgICAgICAgLy8gY29udGludWUgeCBhbmQgeSBkb24ndCBzaGFyZSB0aGUgc2FtZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG4gICAgICAgIGlmICgheCB8fCAheSB8fCB4LmJ1ZmZlciAhPT0geS5idWZmZXIpIHsgY29udGludWU7IH1cbiAgICAgICAgY29uc3QgeyBieXRlT2Zmc2V0OiB4T2Zmc2V0LCBieXRlTGVuZ3RoOiB4TGVuIH0gPSB4O1xuICAgICAgICBjb25zdCB7IGJ5dGVPZmZzZXQ6IHlPZmZzZXQsIGJ5dGVMZW5ndGg6IHlMZW4gfSA9IHk7XG4gICAgICAgIC8vIGNvbnRpbnVlIGlmIHRoZSBieXRlIHJhbmdlcyBvZiB4IGFuZCB5IGFyZW4ndCBjb250aWd1b3VzXG4gICAgICAgIGlmICgoeE9mZnNldCArIHhMZW4pIDwgeU9mZnNldCB8fCAoeU9mZnNldCArIHlMZW4pIDwgeE9mZnNldCkgeyBjb250aW51ZTsgfVxuICAgICAgICBjaHVua3Muc3BsaWNlKC0taSwgMiwgbmV3IFVpbnQ4QXJyYXkoeC5idWZmZXIsIHhPZmZzZXQsIHlPZmZzZXQgLSB4T2Zmc2V0ICsgeUxlbikpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bmtzO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbWNweTxUVGFyZ2V0IGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3LCBUU291cmNlIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3Pih0YXJnZXQ6IFRUYXJnZXQsIHNvdXJjZTogVFNvdXJjZSwgdGFyZ2V0Qnl0ZU9mZnNldCA9IDAsIHNvdXJjZUJ5dGVMZW5ndGggPSBzb3VyY2UuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IHRhcmdldEJ5dGVMZW5ndGggPSB0YXJnZXQuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBkc3QgPSBuZXcgVWludDhBcnJheSh0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgdGFyZ2V0Qnl0ZUxlbmd0aCk7XG4gICAgY29uc3Qgc3JjID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIE1hdGgubWluKHNvdXJjZUJ5dGVMZW5ndGgsIHRhcmdldEJ5dGVMZW5ndGgpKTtcbiAgICBkc3Quc2V0KHNyYywgdGFyZ2V0Qnl0ZU9mZnNldCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqIEBpZ25vcmUgKi9cbmV4cG9ydCBmdW5jdGlvbiBqb2luVWludDhBcnJheXMoY2h1bmtzOiBVaW50OEFycmF5W10sIHNpemU/OiBudW1iZXIgfCBudWxsKTogW1VpbnQ4QXJyYXksIFVpbnQ4QXJyYXlbXV0ge1xuICAgIC8vIGNvbGxhcHNlIGNodW5rcyB0aGF0IHNoYXJlIHRoZSBzYW1lIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIgYW5kIHdob3NlIGJ5dGUgcmFuZ2VzIG92ZXJsYXAsXG4gICAgLy8gdG8gYXZvaWQgdW5uZWNlc3NhcmlseSBjb3B5aW5nIHRoZSBieXRlcyB0byBkbyB0aGlzIGJ1ZmZlciBqb2luLiBUaGlzIGlzIGEgY29tbW9uIGNhc2UgZHVyaW5nXG4gICAgLy8gc3RyZWFtaW5nLCB3aGVyZSB3ZSBtYXkgYmUgcmVhZGluZyBwYXJ0aWFsIGJ5dGUgcmFuZ2VzIG91dCBvZiB0aGUgc2FtZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG4gICAgY2h1bmtzID0gY29sbGFwc2VDb250aWd1b3VzQnl0ZVJhbmdlcyhjaHVua3MpO1xuICAgIGxldCBvZmZzZXQgPSAwLCBpbmRleCA9IC0xLCBudW1DaHVua3MgPSBjaHVua3MubGVuZ3RoO1xuICAgIGxldCBjaHVua3NMZW4gPSBjaHVua3MucmVkdWNlKCh4LCB5KSA9PiB4ICsgeS5ieXRlTGVuZ3RoLCAwKTtcbiAgICBsZXQgc291cmNlOiBVaW50OEFycmF5LCBzbGljZWQ6IFVpbnQ4QXJyYXksIGJ1ZmZlcjogVWludDhBcnJheSB8IHZvaWQ7XG4gICAgbGV0IGxlbmd0aCA9IE1hdGgubWluKGNodW5rc0xlbiwgdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IEluZmluaXR5KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IG51bUNodW5rcykge1xuICAgICAgICBzb3VyY2UgPSBjaHVua3NbaW5kZXhdO1xuICAgICAgICBzbGljZWQgPSBzb3VyY2Uuc3ViYXJyYXkoMCwgTWF0aC5taW4oc291cmNlLmxlbmd0aCwgbGVuZ3RoIC0gb2Zmc2V0KSk7XG4gICAgICAgIGlmIChsZW5ndGggPD0gKG9mZnNldCArIHNsaWNlZC5sZW5ndGgpKSB7XG4gICAgICAgICAgICBpZiAoc2xpY2VkLmxlbmd0aCA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaHVua3NbaW5kZXhdID0gc291cmNlLnN1YmFycmF5KHNsaWNlZC5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzbGljZWQubGVuZ3RoID09PSBzb3VyY2UubGVuZ3RoKSB7IGluZGV4Kys7IH1cbiAgICAgICAgICAgIGJ1ZmZlciA/IG1lbWNweShidWZmZXIsIHNsaWNlZCwgb2Zmc2V0KSA6IChidWZmZXIgPSBzbGljZWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgKGJ1ZmZlciB8fCAoYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSkpLnNldChzbGljZWQsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBzbGljZWQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gW2J1ZmZlciB8fCBuZXcgVWludDhBcnJheSgwKSwgY2h1bmtzLnNsaWNlKGluZGV4KV07XG59XG5cbi8qKiBAaWdub3JlICovXG5leHBvcnQgdHlwZSBBcnJheUJ1ZmZlclZpZXdJbnB1dCA9IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyTGlrZSB8IEFycmF5QnVmZmVyVmlldyB8IEl0ZXJhYmxlPG51bWJlcj4gfCBBcnJheUxpa2U8bnVtYmVyPiB8IEJ5dGVCdWZmZXIgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkICB8XG4gICAgICAgICAgICAgICAgICAgIEl0ZXJhdG9yUmVzdWx0PEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyTGlrZSB8IEFycmF5QnVmZmVyVmlldyB8IEl0ZXJhYmxlPG51bWJlcj4gfCBBcnJheUxpa2U8bnVtYmVyPiB8IEJ5dGVCdWZmZXIgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPiB8XG4gICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkUmVzdWx0PEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyTGlrZSB8IEFycmF5QnVmZmVyVmlldyB8IEl0ZXJhYmxlPG51bWJlcj4gfCBBcnJheUxpa2U8bnVtYmVyPiB8IEJ5dGVCdWZmZXIgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPiA7XG5cbi8qKiBAaWdub3JlICovXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheUJ1ZmZlclZpZXc8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4oQXJyYXlCdWZmZXJWaWV3Q3RvcjogQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3I8VD4sIGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCk6IFQge1xuXG4gICAgbGV0IHZhbHVlOiBhbnkgPSBpc0l0ZXJhdG9yUmVzdWx0KGlucHV0KSA/IGlucHV0LnZhbHVlIDogaW5wdXQ7XG5cbiAgICBpZiAoIXZhbHVlKSB7IHJldHVybiBuZXcgQXJyYXlCdWZmZXJWaWV3Q3RvcigwKTsgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7IHZhbHVlID0gZW5jb2RlVXRmOCh2YWx1ZSk7IH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclZpZXdDdG9yKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXJWaWV3Q3RvciA/IHZhbHVlIDpcbiAgICAgICAgICAgIC8vIE5vZGUncyBgQnVmZmVyYCBjbGFzcyBwYXNzZXMgdGhlIGBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlgIGNoZWNrLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYSByZWFsIFVpbnQ4QXJyYXksIHNpbmNlIEJ1ZmZlciNzbGljZSBpc24ndCB0aGUgc2FtZSBhcyBVaW50OEFycmF5I3NsaWNlIDovXG4gICAgICAgICAgICBuZXcgQXJyYXlCdWZmZXJWaWV3Q3Rvcih2YWx1ZS5idWZmZXIsIHZhbHVlLmJ5dGVPZmZzZXQsIHZhbHVlLmJ5dGVMZW5ndGggLyBBcnJheUJ1ZmZlclZpZXdDdG9yLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlclZpZXdDdG9yKHZhbHVlKTsgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmKSB7IHJldHVybiBuZXcgQXJyYXlCdWZmZXJWaWV3Q3Rvcih2YWx1ZSk7IH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCeXRlQnVmZmVyKSB7IHJldHVybiB0b0FycmF5QnVmZmVyVmlldyhBcnJheUJ1ZmZlclZpZXdDdG9yLCB2YWx1ZS5ieXRlcygpKTsgfVxuICAgIHJldHVybiAhQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSA/IEFycmF5QnVmZmVyVmlld0N0b3IuZnJvbSh2YWx1ZSkgOiB2YWx1ZS5ieXRlTGVuZ3RoIDw9IDAgPyBuZXcgQXJyYXlCdWZmZXJWaWV3Q3RvcigwKVxuICAgICAgICA6IG5ldyBBcnJheUJ1ZmZlclZpZXdDdG9yKHZhbHVlLmJ1ZmZlciwgdmFsdWUuYnl0ZU9mZnNldCwgdmFsdWUuYnl0ZUxlbmd0aCAvIEFycmF5QnVmZmVyVmlld0N0b3IuQllURVNfUEVSX0VMRU1FTlQpO1xufVxuXG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9JbnQ4QXJyYXkgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlldyhJbnQ4QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDE2QXJyYXkgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlldyhJbnQxNkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9JbnQzMkFycmF5ID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXcoSW50MzJBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDhBcnJheSA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3KFVpbnQ4QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b1VpbnQxNkFycmF5ID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXcoVWludDE2QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b1VpbnQzMkFycmF5ID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXcoVWludDMyQXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0Zsb2F0MzJBcnJheSA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3KEZsb2F0MzJBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvRmxvYXQ2NEFycmF5ID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXcoRmxvYXQ2NEFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50OENsYW1wZWRBcnJheSA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3KFVpbnQ4Q2xhbXBlZEFycmF5LCBpbnB1dCk7XG5cbi8qKiBAaWdub3JlICovXG50eXBlIEFycmF5QnVmZmVyVmlld0l0ZXJhdG9ySW5wdXQgPSBJdGVyYWJsZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4gfCBBcnJheUJ1ZmZlclZpZXdJbnB1dDtcblxuLyoqIEBpZ25vcmUgKi9cbmNvbnN0IHB1bXAgPSA8VCBleHRlbmRzIEl0ZXJhdG9yPGFueT4gfCBBc3luY0l0ZXJhdG9yPGFueT4+KGl0ZXJhdG9yOiBUKSA9PiB7IGl0ZXJhdG9yLm5leHQoKTsgcmV0dXJuIGl0ZXJhdG9yOyB9O1xuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uKiB0b0FycmF5QnVmZmVyVmlld0l0ZXJhdG9yPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KEFycmF5Q3RvcjogQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3I8VD4sIHNvdXJjZTogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkge1xuXG4gICAgY29uc3Qgd3JhcCA9IGZ1bmN0aW9uKjxUPih4OiBUKSB7IHlpZWxkIHg7IH07XG4gICAgY29uc3QgYnVmZmVyczogSXRlcmFibGU8QXJyYXlCdWZmZXJWaWV3SW5wdXQ+ID1cbiAgICAgICAgICAgICAgICAgICAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpID8gd3JhcChzb3VyY2UpXG4gICAgICAgICAgICAgICAgIDogKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSA/IHdyYXAoc291cmNlKVxuICAgICAgICAgICAgICA6IChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgPyB3cmFwKHNvdXJjZSlcbiAgICAgICAgICAgOiAoc291cmNlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWYpID8gd3JhcChzb3VyY2UpXG4gICAgOiAhaXNJdGVyYWJsZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4oc291cmNlKSA/IHdyYXAoc291cmNlKSA6IHNvdXJjZTtcblxuICAgIHlpZWxkKiBwdW1wKChmdW5jdGlvbiogKGl0KSB7XG4gICAgICAgIGxldCByOiBJdGVyYXRvclJlc3VsdDxhbnk+ID0gPGFueT4gbnVsbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgciA9IGl0Lm5leHQoeWllbGQgdG9BcnJheUJ1ZmZlclZpZXcoQXJyYXlDdG9yLCByKSk7XG4gICAgICAgIH0gd2hpbGUgKCFyLmRvbmUpO1xuICAgIH0pKGJ1ZmZlcnNbU3ltYm9sLml0ZXJhdG9yXSgpKSk7XG59XG5cbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDhBcnJheUl0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0l0ZXJhdG9yKEludDhBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50MTZBcnJheUl0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0l0ZXJhdG9yKEludDE2QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDMyQXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihJbnQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50OEFycmF5SXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3IoVWludDhBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDE2QXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihVaW50MTZBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDMyQXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihVaW50MzJBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvRmxvYXQzMkFycmF5SXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3IoRmxvYXQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9GbG9hdDY0QXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihGbG9hdDY0QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b1VpbnQ4Q2xhbXBlZEFycmF5SXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3IoVWludDhDbGFtcGVkQXJyYXksIGlucHV0KTtcblxuLyoqIEBpZ25vcmUgKi9cbnR5cGUgQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcklucHV0ID0gQXN5bmNJdGVyYWJsZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4gfCBJdGVyYWJsZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4gfCBQcm9taXNlTGlrZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4gfCBBcnJheUJ1ZmZlclZpZXdJbnB1dDtcblxuLyoqIEBpZ25vcmUgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KEFycmF5Q3RvcjogQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3I8VD4sIHNvdXJjZTogQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcklucHV0KTogQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFQ+IHtcblxuICAgIC8vIGlmIGEgUHJvbWlzZSwgdW53cmFwIHRoZSBQcm9taXNlIGFuZCBpdGVyYXRlIHRoZSByZXNvbHZlZCB2YWx1ZVxuICAgIGlmIChpc1Byb21pc2U8QXJyYXlCdWZmZXJWaWV3SW5wdXQ+KHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0b0FycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3IoQXJyYXlDdG9yLCBhd2FpdCBzb3VyY2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHdyYXAgPSBhc3luYyBmdW5jdGlvbio8VD4oeDogVCkgeyB5aWVsZCBhd2FpdCB4OyB9O1xuICAgIGNvbnN0IGVtaXQgPSBhc3luYyBmdW5jdGlvbiogPFQgZXh0ZW5kcyBJdGVyYWJsZTxhbnk+Pihzb3VyY2U6IFQpIHtcbiAgICAgICAgeWllbGQqIHB1bXAoKGZ1bmN0aW9uKihpdDogSXRlcmF0b3I8YW55Pikge1xuICAgICAgICAgICAgbGV0IHI6IEl0ZXJhdG9yUmVzdWx0PGFueT4gPSA8YW55PiBudWxsO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHIgPSBpdC5uZXh0KHlpZWxkIHIgJiYgci52YWx1ZSk7XG4gICAgICAgICAgICB9IHdoaWxlICghci5kb25lKTtcbiAgICAgICAgfSkoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0oKSkpO1xuICAgIH07XG5cbiAgICBjb25zdCBidWZmZXJzOiBBc3luY0l0ZXJhYmxlPEFycmF5QnVmZmVyVmlld0lucHV0PiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpID8gd3JhcChzb3VyY2UpIC8vIGlmIHN0cmluZywgd3JhcCBpbiBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICA6IChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkgPyB3cmFwKHNvdXJjZSkgLy8gaWYgVHlwZWRBcnJheSwgd3JhcCBpbiBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3JcbiAgICAgICAgICAgICAgICAgICA6IChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgPyB3cmFwKHNvdXJjZSkgLy8gaWYgQXJyYXlCdWZmZXIsIHdyYXAgaW4gYW4gQXN5bmNJdGVyYWJsZUl0ZXJhdG9yXG4gICAgICAgICAgICAgICAgOiAoc291cmNlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWYpID8gd3JhcChzb3VyY2UpIC8vIGlmIFNoYXJlZEFycmF5QnVmZmVyLCB3cmFwIGluIGFuIEFzeW5jSXRlcmFibGVJdGVyYXRvclxuICAgICAgICAgIDogaXNJdGVyYWJsZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4oc291cmNlKSA/IGVtaXQoc291cmNlKSAvLyBJZiBJdGVyYWJsZSwgd3JhcCBpbiBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3IgYW5kIGNvbXBvc2UgdGhlIGBuZXh0YCB2YWx1ZXNcbiAgICA6ICFpc0FzeW5jSXRlcmFibGU8QXJyYXlCdWZmZXJWaWV3SW5wdXQ+KHNvdXJjZSkgPyB3cmFwKHNvdXJjZSkgLy8gSWYgbm90IGFuIEFzeW5jSXRlcmFibGUsIHRyZWF0IGFzIGEgc2VudGluZWwgYW5kIHdyYXAgaW4gYW4gQXN5bmNJdGVyYWJsZUl0ZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc291cmNlOyAvLyBvdGhlcndpc2UgaWYgQXN5bmNJdGVyYWJsZSwgdXNlIGl0XG5cbiAgICB5aWVsZCogcHVtcCgoYXN5bmMgZnVuY3Rpb24qIChpdCkge1xuICAgICAgICBsZXQgcjogSXRlcmF0b3JSZXN1bHQ8YW55PiA9IDxhbnk+IG51bGw7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHIgPSBhd2FpdCBpdC5uZXh0KHlpZWxkIHRvQXJyYXlCdWZmZXJWaWV3KEFycmF5Q3RvciwgcikpO1xuICAgICAgICB9IHdoaWxlICghci5kb25lKTtcbiAgICB9KShidWZmZXJzW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpKSk7XG59XG5cbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDhBcnJheUFzeW5jSXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yKEludDhBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50MTZBcnJheUFzeW5jSXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yKEludDE2QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDMyQXJyYXlBc3luY0l0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihJbnQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50OEFycmF5QXN5bmNJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3IoVWludDhBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDE2QXJyYXlBc3luY0l0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihVaW50MTZBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDMyQXJyYXlBc3luY0l0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihVaW50MzJBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvRmxvYXQzMkFycmF5QXN5bmNJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3IoRmxvYXQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9GbG9hdDY0QXJyYXlBc3luY0l0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihGbG9hdDY0QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b1VpbnQ4Q2xhbXBlZEFycmF5QXN5bmNJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3IoVWludDhDbGFtcGVkQXJyYXksIGlucHV0KTtcblxuLyoqIEBpZ25vcmUgKi9cbmV4cG9ydCBmdW5jdGlvbiByZWJhc2VWYWx1ZU9mZnNldHMob2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCB2YWx1ZU9mZnNldHM6IEludDMyQXJyYXkpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgbm9uLXplcm8gb2Zmc2V0LCBjcmVhdGUgYSBuZXcgb2Zmc2V0cyBhcnJheSB3aXRoIHRoZSB2YWx1ZXNcbiAgICAvLyBzaGlmdGVkIGJ5IHRoZSBzdGFydCBvZmZzZXQsIHN1Y2ggdGhhdCB0aGUgbmV3IHN0YXJ0IG9mZnNldCBpcyAwXG4gICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICB2YWx1ZU9mZnNldHMgPSB2YWx1ZU9mZnNldHMuc2xpY2UoMCwgbGVuZ3RoICsgMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAtMTsgKytpIDw9IGxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhbHVlT2Zmc2V0c1tpXSArPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlT2Zmc2V0cztcbn1cblxuLyoqIEBpZ25vcmUgKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQXJyYXlMaWtlPFQgZXh0ZW5kcyBBcnJheUxpa2U8YW55Pj4oYTogVCwgYjogVCkge1xuICAgIGxldCBpID0gMCwgbiA9IGEubGVuZ3RoO1xuICAgIGlmIChuICE9PSBiLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAobiA+IDApIHtcbiAgICAgICAgZG8geyBpZiAoYVtpXSAhPT0gYltpXSkgeyByZXR1cm4gZmFsc2U7IH0gfSB3aGlsZSAoKytpIDwgbik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuIl19
