// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
import { flatbuffers } from 'flatbuffers';
var ByteBuffer = flatbuffers.ByteBuffer;
import { isPromise, isIterable, isAsyncIterable, isIteratorResult } from './compat';
function collapseContiguousByteRanges(chunks) {
    for (let x, y, i = 0; ++i < chunks.length;) {
        x = chunks[i - 1];
        y = chunks[i - 0];
        // continue x and y don't share the same underlying ArrayBuffer
        if (!x || !y || x.buffer !== y.buffer) {
            continue;
        }
        const { byteOffset: xOffset, byteLength: xLen } = x;
        const { byteOffset: yOffset, byteLength: yLen } = y;
        // continue if the byte ranges of x and y aren't contiguous
        if ((xOffset + xLen) < yOffset || (yOffset + yLen) < xOffset) {
            continue;
        }
        chunks.splice(--i, 2, new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen));
    }
    return chunks;
}
/**
 * @ignore
 */
export function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
}
/**
 * @ignore
 */
export function joinUint8Arrays(chunks, size) {
    // collapse chunks that share the same underlying ArrayBuffer and whose byte ranges overlap,
    // to avoid unnecessarily copying the bytes to do this buffer join. This is a common case during
    // streaming, where we may be reading partial byte ranges out of the same underlying ArrayBuffer
    chunks = collapseContiguousByteRanges(chunks);
    let offset = 0, index = -1, chunksLen = chunks.length;
    let source, sliced, buffer;
    let length = typeof size === 'number' ? size : chunks.reduce((x, y) => x + y.length, 0);
    while (++index < chunksLen) {
        source = chunks[index];
        sliced = source.subarray(0, Math.min(source.length, length - offset));
        if (length <= (offset + sliced.length)) {
            if (sliced.length < source.length) {
                chunks[index] = source.subarray(sliced.length);
            }
            else if (sliced.length === source.length) {
                index++;
            }
            buffer ? memcpy(buffer, sliced, offset) : (buffer = sliced);
            break;
        }
        (buffer || (buffer = new Uint8Array(length))).set(sliced, offset);
        offset += sliced.length;
    }
    return [buffer || new Uint8Array(0), chunks.slice(index)];
}
/**
 * @ignore
 */
export function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = isIteratorResult(input) ? input.value : input;
    if (!value) {
        return new ArrayBufferViewCtor(0);
    }
    if (typeof value === 'string') {
        value = decodeUtf8(value);
    }
    if (value instanceof ArrayBufferViewCtor) {
        return value;
    }
    if (value instanceof ArrayBuffer) {
        return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuffer) {
        return new ArrayBufferViewCtor(value);
    }
    if (value instanceof ByteBuffer) {
        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0)
        : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
}
/** @ignore */ export const toInt8Array = (input) => toArrayBufferView(Int8Array, input);
/** @ignore */ export const toInt16Array = (input) => toArrayBufferView(Int16Array, input);
/** @ignore */ export const toInt32Array = (input) => toArrayBufferView(Int32Array, input);
/** @ignore */ export const toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
/** @ignore */ export const toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
/** @ignore */ export const toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
/** @ignore */ export const toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
/** @ignore */ export const toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
/** @ignore */ export const toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
const pump = (iterator) => { iterator.next(); return iterator; };
/** @ignore */
export function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) { yield x; };
    const buffers = (typeof source === 'string') ? wrap(source)
        : (ArrayBuffer.isView(source)) ? wrap(source)
            : (source instanceof ArrayBuffer) ? wrap(source)
                : (source instanceof SharedArrayBuffer) ? wrap(source)
                    : !isIterable(source) ? wrap(source) : source;
    yield* pump((function* (it) {
        let r = null;
        do {
            r = it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
    })(buffers[Symbol.iterator]()));
}
/** @ignore */ export const toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
/** @ignore */ export const toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
/** @ignore */ export const toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
/** @ignore */ export const toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
/** @ignore */ export const toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
/** @ignore */ export const toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
/** @ignore */ export const toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
/** @ignore */ export const toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
/** @ignore */ export const toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
/** @ignore */
export async function* toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    // if a Promise, unwrap the Promise and iterate the resolved value
    if (isPromise(source)) {
        return yield* toArrayBufferViewAsyncIterator(ArrayCtor, await source);
    }
    const wrap = async function* (x) { yield await x; };
    const emit = async function* (source) {
        yield* pump((function* (it) {
            let r = null;
            do {
                r = it.next(yield r && r.value);
            } while (!r.done);
        })(source[Symbol.iterator]()));
    };
    const buffers = (typeof source === 'string') ? wrap(source) // if string, wrap in an AsyncIterableIterator
        : (ArrayBuffer.isView(source)) ? wrap(source) // if TypedArray, wrap in an AsyncIterableIterator
            : (source instanceof ArrayBuffer) ? wrap(source) // if ArrayBuffer, wrap in an AsyncIterableIterator
                : (source instanceof SharedArrayBuffer) ? wrap(source) // if SharedArrayBuffer, wrap in an AsyncIterableIterator
                    : isIterable(source) ? emit(source) // If Iterable, wrap in an AsyncIterableIterator and compose the `next` values
                        : !isAsyncIterable(source) ? wrap(source) // If not an AsyncIterable, treat as a sentinel and wrap in an AsyncIterableIterator
                            : source; // otherwise if AsyncIterable, use it
    yield* pump((async function* (it) {
        let r = null;
        do {
            r = await it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
    })(buffers[Symbol.asyncIterator]()));
}
/** @ignore */ export const toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
/** @ignore */ export const toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
/** @ignore */ export const toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
/** @ignore */ export const toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
/** @ignore */ export const toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
/** @ignore */ export const toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
/** @ignore */ export const toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
/** @ignore */ export const toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
/** @ignore */ export const toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
/**
 * @ignore
 */
function decodeUtf8(chunk) {
    const bytes = new Uint8Array(chunk.length);
    for (let i = -1, n = chunk.length; ++i < n;) {
        bytes[i] = chunk.charCodeAt(i);
    }
    return bytes;
}
/**
 * @ignore
 */
export function rebaseValueOffsets(offset, length, valueOffsets) {
    // If we have a non-zero offset, create a new offsets array with the values
    // shifted by the start offset, such that the new start offset is 0
    if (offset !== 0) {
        valueOffsets = valueOffsets.slice(0, length + 1);
        for (let i = -1; ++i <= length;) {
            valueOffsets[i] += offset;
        }
    }
    return valueOffsets;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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ZXNDb250ZW50IjpbIi8vIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5pbXBvcnQgeyBmbGF0YnVmZmVycyB9IGZyb20gJ2ZsYXRidWZmZXJzJztcbmltcG9ydCBCeXRlQnVmZmVyID0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcjtcbmltcG9ydCB7IEFycmF5QnVmZmVyVmlld0NvbnN0cnVjdG9yIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBpc1Byb21pc2UsIGlzSXRlcmFibGUsIGlzQXN5bmNJdGVyYWJsZSwgaXNJdGVyYXRvclJlc3VsdCB9IGZyb20gJy4vY29tcGF0JztcblxuZnVuY3Rpb24gY29sbGFwc2VDb250aWd1b3VzQnl0ZVJhbmdlcyhjaHVua3M6IFVpbnQ4QXJyYXlbXSkge1xuICAgIGZvciAobGV0IHgsIHksIGkgPSAwOyArK2kgPCBjaHVua3MubGVuZ3RoOykge1xuICAgICAgICB4ID0gY2h1bmtzW2kgLSAxXTtcbiAgICAgICAgeSA9IGNodW5rc1tpIC0gMF07XG4gICAgICAgIC8vIGNvbnRpbnVlIHggYW5kIHkgZG9uJ3Qgc2hhcmUgdGhlIHNhbWUgdW5kZXJseWluZyBBcnJheUJ1ZmZlclxuICAgICAgICBpZiAoIXggfHwgIXkgfHwgeC5idWZmZXIgIT09IHkuYnVmZmVyKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGNvbnN0IHsgYnl0ZU9mZnNldDogeE9mZnNldCwgYnl0ZUxlbmd0aDogeExlbiB9ID0geDtcbiAgICAgICAgY29uc3QgeyBieXRlT2Zmc2V0OiB5T2Zmc2V0LCBieXRlTGVuZ3RoOiB5TGVuIH0gPSB5O1xuICAgICAgICAvLyBjb250aW51ZSBpZiB0aGUgYnl0ZSByYW5nZXMgb2YgeCBhbmQgeSBhcmVuJ3QgY29udGlndW91c1xuICAgICAgICBpZiAoKHhPZmZzZXQgKyB4TGVuKSA8IHlPZmZzZXQgfHwgKHlPZmZzZXQgKyB5TGVuKSA8IHhPZmZzZXQpIHsgY29udGludWU7IH1cbiAgICAgICAgY2h1bmtzLnNwbGljZSgtLWksIDIsIG5ldyBVaW50OEFycmF5KHguYnVmZmVyLCB4T2Zmc2V0LCB5T2Zmc2V0IC0geE9mZnNldCArIHlMZW4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rcztcbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1jcHk8VFRhcmdldCBleHRlbmRzIEFycmF5QnVmZmVyVmlldywgVFNvdXJjZSBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4odGFyZ2V0OiBUVGFyZ2V0LCBzb3VyY2U6IFRTb3VyY2UsIHRhcmdldEJ5dGVPZmZzZXQgPSAwLCBzb3VyY2VCeXRlTGVuZ3RoID0gc291cmNlLmJ5dGVMZW5ndGgpIHtcbiAgICBjb25zdCB0YXJnZXRCeXRlTGVuZ3RoID0gdGFyZ2V0LmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZHN0ID0gbmV3IFVpbnQ4QXJyYXkodGFyZ2V0LmJ1ZmZlciwgdGFyZ2V0LmJ5dGVPZmZzZXQsIHRhcmdldEJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IHNyYyA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBNYXRoLm1pbihzb3VyY2VCeXRlTGVuZ3RoLCB0YXJnZXRCeXRlTGVuZ3RoKSk7XG4gICAgZHN0LnNldChzcmMsIHRhcmdldEJ5dGVPZmZzZXQpO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gam9pblVpbnQ4QXJyYXlzKGNodW5rczogVWludDhBcnJheVtdLCBzaXplPzogbnVtYmVyIHwgbnVsbCk6IFtVaW50OEFycmF5LCBVaW50OEFycmF5W11dIHtcbiAgICAvLyBjb2xsYXBzZSBjaHVua3MgdGhhdCBzaGFyZSB0aGUgc2FtZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyIGFuZCB3aG9zZSBieXRlIHJhbmdlcyBvdmVybGFwLFxuICAgIC8vIHRvIGF2b2lkIHVubmVjZXNzYXJpbHkgY29weWluZyB0aGUgYnl0ZXMgdG8gZG8gdGhpcyBidWZmZXIgam9pbi4gVGhpcyBpcyBhIGNvbW1vbiBjYXNlIGR1cmluZ1xuICAgIC8vIHN0cmVhbWluZywgd2hlcmUgd2UgbWF5IGJlIHJlYWRpbmcgcGFydGlhbCBieXRlIHJhbmdlcyBvdXQgb2YgdGhlIHNhbWUgdW5kZXJseWluZyBBcnJheUJ1ZmZlclxuICAgIGNodW5rcyA9IGNvbGxhcHNlQ29udGlndW91c0J5dGVSYW5nZXMoY2h1bmtzKTtcbiAgICBsZXQgb2Zmc2V0ID0gMCwgaW5kZXggPSAtMSwgY2h1bmtzTGVuID0gY2h1bmtzLmxlbmd0aDtcbiAgICBsZXQgc291cmNlOiBVaW50OEFycmF5LCBzbGljZWQ6IFVpbnQ4QXJyYXksIGJ1ZmZlcjogVWludDhBcnJheSB8IHZvaWQ7XG4gICAgbGV0IGxlbmd0aCA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiBjaHVua3MucmVkdWNlKCh4LCB5KSA9PiB4ICsgeS5sZW5ndGgsIDApO1xuICAgIHdoaWxlICgrK2luZGV4IDwgY2h1bmtzTGVuKSB7XG4gICAgICAgIHNvdXJjZSA9IGNodW5rc1tpbmRleF07XG4gICAgICAgIHNsaWNlZCA9IHNvdXJjZS5zdWJhcnJheSgwLCBNYXRoLm1pbihzb3VyY2UubGVuZ3RoLCBsZW5ndGggLSBvZmZzZXQpKTtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAob2Zmc2V0ICsgc2xpY2VkLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGlmIChzbGljZWQubGVuZ3RoIDwgc291cmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNodW5rc1tpbmRleF0gPSBzb3VyY2Uuc3ViYXJyYXkoc2xpY2VkLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNsaWNlZC5sZW5ndGggPT09IHNvdXJjZS5sZW5ndGgpIHsgaW5kZXgrKzsgfVxuICAgICAgICAgICAgYnVmZmVyID8gbWVtY3B5KGJ1ZmZlciwgc2xpY2VkLCBvZmZzZXQpIDogKGJ1ZmZlciA9IHNsaWNlZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAoYnVmZmVyIHx8IChidWZmZXIgPSBuZXcgVWludDhBcnJheShsZW5ndGgpKSkuc2V0KHNsaWNlZCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHNsaWNlZC5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBbYnVmZmVyIHx8IG5ldyBVaW50OEFycmF5KDApLCBjaHVua3Muc2xpY2UoaW5kZXgpXTtcbn1cblxuZXhwb3J0IHR5cGUgQXJyYXlCdWZmZXJWaWV3SW5wdXQgPSBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlckxpa2UgfCBBcnJheUJ1ZmZlclZpZXcgfCBJdGVyYWJsZTxudW1iZXI+IHwgQXJyYXlMaWtlPG51bWJlcj4gfCBCeXRlQnVmZmVyIHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCAgfFxuICAgICAgICAgICAgICAgICAgICBJdGVyYXRvclJlc3VsdDxBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlckxpa2UgfCBBcnJheUJ1ZmZlclZpZXcgfCBJdGVyYWJsZTxudW1iZXI+IHwgQXJyYXlMaWtlPG51bWJlcj4gfCBCeXRlQnVmZmVyIHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD4gfFxuICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZFJlc3VsdDxBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlckxpa2UgfCBBcnJheUJ1ZmZlclZpZXcgfCBJdGVyYWJsZTxudW1iZXI+IHwgQXJyYXlMaWtlPG51bWJlcj4gfCBCeXRlQnVmZmVyIHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD4gO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXJWaWV3PFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KEFycmF5QnVmZmVyVmlld0N0b3I6IEFycmF5QnVmZmVyVmlld0NvbnN0cnVjdG9yPFQ+LCBpbnB1dDogQXJyYXlCdWZmZXJWaWV3SW5wdXQpOiBUIHtcblxuICAgIGxldCB2YWx1ZTogYW55ID0gaXNJdGVyYXRvclJlc3VsdChpbnB1dCkgPyBpbnB1dC52YWx1ZSA6IGlucHV0O1xuXG4gICAgaWYgKCF2YWx1ZSkgeyByZXR1cm4gbmV3IEFycmF5QnVmZmVyVmlld0N0b3IoMCk7IH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgeyB2YWx1ZSA9IGRlY29kZVV0ZjgodmFsdWUpOyB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJWaWV3Q3RvcikgeyByZXR1cm4gdmFsdWU7IH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgeyByZXR1cm4gbmV3IEFycmF5QnVmZmVyVmlld0N0b3IodmFsdWUpOyB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpIHsgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlclZpZXdDdG9yKHZhbHVlKTsgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpIHsgcmV0dXJuIHRvQXJyYXlCdWZmZXJWaWV3KEFycmF5QnVmZmVyVmlld0N0b3IsIHZhbHVlLmJ5dGVzKCkpOyB9XG4gICAgcmV0dXJuICFBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpID8gQXJyYXlCdWZmZXJWaWV3Q3Rvci5mcm9tKHZhbHVlKSA6IHZhbHVlLmJ5dGVMZW5ndGggPD0gMCA/IG5ldyBBcnJheUJ1ZmZlclZpZXdDdG9yKDApXG4gICAgICAgIDogbmV3IEFycmF5QnVmZmVyVmlld0N0b3IodmFsdWUuYnVmZmVyLCB2YWx1ZS5ieXRlT2Zmc2V0LCB2YWx1ZS5ieXRlTGVuZ3RoIC8gQXJyYXlCdWZmZXJWaWV3Q3Rvci5CWVRFU19QRVJfRUxFTUVOVCk7XG59XG5cbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDhBcnJheSA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3KEludDhBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50MTZBcnJheSA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3KEludDE2QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDMyQXJyYXkgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlldyhJbnQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50OEFycmF5ID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXcoVWludDhBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDE2QXJyYXkgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlldyhVaW50MTZBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDMyQXJyYXkgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlldyhVaW50MzJBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvRmxvYXQzMkFycmF5ID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXcoRmxvYXQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9GbG9hdDY0QXJyYXkgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlldyhGbG9hdDY0QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b1VpbnQ4Q2xhbXBlZEFycmF5ID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXcoVWludDhDbGFtcGVkQXJyYXksIGlucHV0KTtcblxudHlwZSBBcnJheUJ1ZmZlclZpZXdJdGVyYXRvcklucHV0ID0gSXRlcmFibGU8QXJyYXlCdWZmZXJWaWV3SW5wdXQ+IHwgQXJyYXlCdWZmZXJWaWV3SW5wdXQ7XG5cbmNvbnN0IHB1bXAgPSA8VCBleHRlbmRzIEl0ZXJhdG9yPGFueT4gfCBBc3luY0l0ZXJhdG9yPGFueT4+KGl0ZXJhdG9yOiBUKSA9PiB7IGl0ZXJhdG9yLm5leHQoKTsgcmV0dXJuIGl0ZXJhdG9yOyB9O1xuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uKiB0b0FycmF5QnVmZmVyVmlld0l0ZXJhdG9yPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KEFycmF5Q3RvcjogQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3I8VD4sIHNvdXJjZTogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkge1xuXG4gICAgY29uc3Qgd3JhcCA9IGZ1bmN0aW9uKjxUPih4OiBUKSB7IHlpZWxkIHg7IH07XG4gICAgY29uc3QgYnVmZmVyczogSXRlcmFibGU8QXJyYXlCdWZmZXJWaWV3SW5wdXQ+ID1cbiAgICAgICAgICAgICAgICAgICAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpID8gd3JhcChzb3VyY2UpXG4gICAgICAgICAgICAgICAgIDogKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSA/IHdyYXAoc291cmNlKVxuICAgICAgICAgICAgICA6IChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgPyB3cmFwKHNvdXJjZSlcbiAgICAgICAgOiAoc291cmNlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpID8gd3JhcChzb3VyY2UpXG4gICAgOiAhaXNJdGVyYWJsZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4oc291cmNlKSA/IHdyYXAoc291cmNlKSA6IHNvdXJjZTtcblxuICAgIHlpZWxkKiBwdW1wKChmdW5jdGlvbiogKGl0KSB7XG4gICAgICAgIGxldCByOiBJdGVyYXRvclJlc3VsdDxhbnk+ID0gPGFueT4gbnVsbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgciA9IGl0Lm5leHQoeWllbGQgdG9BcnJheUJ1ZmZlclZpZXcoQXJyYXlDdG9yLCByKSk7XG4gICAgICAgIH0gd2hpbGUgKCFyLmRvbmUpO1xuICAgIH0pKGJ1ZmZlcnNbU3ltYm9sLml0ZXJhdG9yXSgpKSk7XG59XG5cbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDhBcnJheUl0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0l0ZXJhdG9yKEludDhBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50MTZBcnJheUl0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0l0ZXJhdG9yKEludDE2QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDMyQXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihJbnQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50OEFycmF5SXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3IoVWludDhBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDE2QXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihVaW50MTZBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDMyQXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihVaW50MzJBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvRmxvYXQzMkFycmF5SXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3IoRmxvYXQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9GbG9hdDY0QXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihGbG9hdDY0QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b1VpbnQ4Q2xhbXBlZEFycmF5SXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3IoVWludDhDbGFtcGVkQXJyYXksIGlucHV0KTtcblxudHlwZSBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQgPSBBc3luY0l0ZXJhYmxlPEFycmF5QnVmZmVyVmlld0lucHV0PiB8IEl0ZXJhYmxlPEFycmF5QnVmZmVyVmlld0lucHV0PiB8IFByb21pc2VMaWtlPEFycmF5QnVmZmVyVmlld0lucHV0PiB8IEFycmF5QnVmZmVyVmlld0lucHV0O1xuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiB0b0FycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3I8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4oQXJyYXlDdG9yOiBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPiwgc291cmNlOiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpOiBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8VD4ge1xuXG4gICAgLy8gaWYgYSBQcm9taXNlLCB1bndyYXAgdGhlIFByb21pc2UgYW5kIGl0ZXJhdGUgdGhlIHJlc29sdmVkIHZhbHVlXG4gICAgaWYgKGlzUHJvbWlzZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4oc291cmNlKSkge1xuICAgICAgICByZXR1cm4geWllbGQqIHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihBcnJheUN0b3IsIGF3YWl0IHNvdXJjZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgd3JhcCA9IGFzeW5jIGZ1bmN0aW9uKjxUPih4OiBUKSB7IHlpZWxkIGF3YWl0IHg7IH07XG4gICAgY29uc3QgZW1pdCA9IGFzeW5jIGZ1bmN0aW9uKiA8VCBleHRlbmRzIEl0ZXJhYmxlPGFueT4+KHNvdXJjZTogVCkge1xuICAgICAgICB5aWVsZCogcHVtcCgoZnVuY3Rpb24qKGl0OiBJdGVyYXRvcjxhbnk+KSB7XG4gICAgICAgICAgICBsZXQgcjogSXRlcmF0b3JSZXN1bHQ8YW55PiA9IDxhbnk+IG51bGw7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgciA9IGl0Lm5leHQoeWllbGQgciAmJiByLnZhbHVlKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKCFyLmRvbmUpO1xuICAgICAgICB9KShzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSgpKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGJ1ZmZlcnM6IEFzeW5jSXRlcmFibGU8QXJyYXlCdWZmZXJWaWV3SW5wdXQ+ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykgPyB3cmFwKHNvdXJjZSkgLy8gaWYgc3RyaW5nLCB3cmFwIGluIGFuIEFzeW5jSXRlcmFibGVJdGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAgIDogKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSA/IHdyYXAoc291cmNlKSAvLyBpZiBUeXBlZEFycmF5LCB3cmFwIGluIGFuIEFzeW5jSXRlcmFibGVJdGVyYXRvclxuICAgICAgICAgICAgICAgICAgIDogKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSA/IHdyYXAoc291cmNlKSAvLyBpZiBBcnJheUJ1ZmZlciwgd3JhcCBpbiBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3JcbiAgICAgICAgICAgICA6IChzb3VyY2UgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikgPyB3cmFwKHNvdXJjZSkgLy8gaWYgU2hhcmVkQXJyYXlCdWZmZXIsIHdyYXAgaW4gYW4gQXN5bmNJdGVyYWJsZUl0ZXJhdG9yXG4gICAgICAgICAgOiBpc0l0ZXJhYmxlPEFycmF5QnVmZmVyVmlld0lucHV0Pihzb3VyY2UpID8gZW1pdChzb3VyY2UpIC8vIElmIEl0ZXJhYmxlLCB3cmFwIGluIGFuIEFzeW5jSXRlcmFibGVJdGVyYXRvciBhbmQgY29tcG9zZSB0aGUgYG5leHRgIHZhbHVlc1xuICAgIDogIWlzQXN5bmNJdGVyYWJsZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4oc291cmNlKSA/IHdyYXAoc291cmNlKSAvLyBJZiBub3QgYW4gQXN5bmNJdGVyYWJsZSwgdHJlYXQgYXMgYSBzZW50aW5lbCBhbmQgd3JhcCBpbiBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzb3VyY2U7IC8vIG90aGVyd2lzZSBpZiBBc3luY0l0ZXJhYmxlLCB1c2UgaXRcblxuICAgIHlpZWxkKiBwdW1wKChhc3luYyBmdW5jdGlvbiogKGl0KSB7XG4gICAgICAgIGxldCByOiBJdGVyYXRvclJlc3VsdDxhbnk+ID0gPGFueT4gbnVsbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgciA9IGF3YWl0IGl0Lm5leHQoeWllbGQgdG9BcnJheUJ1ZmZlclZpZXcoQXJyYXlDdG9yLCByKSk7XG4gICAgICAgIH0gd2hpbGUgKCFyLmRvbmUpO1xuICAgIH0pKGJ1ZmZlcnNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpKTtcbn1cblxuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50OEFycmF5QXN5bmNJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3IoSW50OEFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9JbnQxNkFycmF5QXN5bmNJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3IoSW50MTZBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50MzJBcnJheUFzeW5jSXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yKEludDMyQXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b1VpbnQ4QXJyYXlBc3luY0l0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihVaW50OEFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50MTZBcnJheUFzeW5jSXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yKFVpbnQxNkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50MzJBcnJheUFzeW5jSXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yKFVpbnQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9GbG9hdDMyQXJyYXlBc3luY0l0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihGbG9hdDMyQXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0Zsb2F0NjRBcnJheUFzeW5jSXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yKEZsb2F0NjRBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDhDbGFtcGVkQXJyYXlBc3luY0l0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihVaW50OENsYW1wZWRBcnJheSwgaW5wdXQpO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlVXRmOChjaHVuazogc3RyaW5nKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjaHVuay5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAtMSwgbiA9IGNodW5rLmxlbmd0aDsgKytpIDwgbjspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBjaHVuay5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmViYXNlVmFsdWVPZmZzZXRzKG9mZnNldDogbnVtYmVyLCBsZW5ndGg6IG51bWJlciwgdmFsdWVPZmZzZXRzOiBJbnQzMkFycmF5KSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIG5vbi16ZXJvIG9mZnNldCwgY3JlYXRlIGEgbmV3IG9mZnNldHMgYXJyYXkgd2l0aCB0aGUgdmFsdWVzXG4gICAgLy8gc2hpZnRlZCBieSB0aGUgc3RhcnQgb2Zmc2V0LCBzdWNoIHRoYXQgdGhlIG5ldyBzdGFydCBvZmZzZXQgaXMgMFxuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgICAgdmFsdWVPZmZzZXRzID0gdmFsdWVPZmZzZXRzLnNsaWNlKDAsIGxlbmd0aCArIDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gLTE7ICsraSA8PSBsZW5ndGg7KSB7XG4gICAgICAgICAgICB2YWx1ZU9mZnNldHNbaV0gKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZU9mZnNldHM7XG59XG4iXX0=
