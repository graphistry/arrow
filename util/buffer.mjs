// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
import { flatbuffers } from 'flatbuffers';
import { encodeUtf8 } from '../util/utf8';
var ByteBuffer = flatbuffers.ByteBuffer;
import { isPromise, isIterable, isAsyncIterable, isIteratorResult } from './compat';
/** @ignore */
const SharedArrayBuf = (typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer);
/** @ignore */
function collapseContiguousByteRanges(chunks) {
    let result = chunks[0] ? [chunks[0]] : [];
    let xOffset, yOffset, xLen, yLen;
    for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n;) {
        x = result[j];
        y = chunks[i];
        // continue x and y don't share the same underlying ArrayBuffer
        if (!x || !y || x.buffer !== y.buffer) {
            y && (result[++j] = y);
            continue;
        }
        // swap if y starts before x
        if (y.byteOffset < x.byteOffset) {
            x = chunks[i];
            y = result[j];
        }
        ({ byteOffset: xOffset, byteLength: xLen } = x);
        ({ byteOffset: yOffset, byteLength: yLen } = y);
        // continue if the byte ranges of x and y aren't contiguous
        if ((xOffset + xLen) < yOffset || (yOffset + yLen) < xOffset) {
            y && (result[++j] = y);
            continue;
        }
        result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
    }
    return result;
}
/** @ignore */
export function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
}
/** @ignore */
export function joinUint8Arrays(chunks, size) {
    // collapse chunks that share the same underlying ArrayBuffer and whose byte ranges overlap,
    // to avoid unnecessarily copying the bytes to do this buffer join. This is a common case during
    // streaming, where we may be reading partial byte ranges out of the same underlying ArrayBuffer
    let result = collapseContiguousByteRanges(chunks);
    let byteLength = result.reduce((x, b) => x + b.byteLength, 0);
    let source, sliced, buffer;
    let offset = 0, index = -1, length = Math.min(size || Infinity, byteLength);
    for (let n = result.length; ++index < n;) {
        source = result[index];
        sliced = source.subarray(0, Math.min(source.length, length - offset));
        if (length <= (offset + sliced.length)) {
            if (sliced.length < source.length) {
                result[index] = source.subarray(sliced.length);
            }
            else if (sliced.length === source.length) {
                index++;
            }
            buffer ? memcpy(buffer, sliced, offset) : (buffer = sliced);
            break;
        }
        memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
        offset += sliced.length;
    }
    return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
}
/** @ignore */
export function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = isIteratorResult(input) ? input.value : input;
    if (!value) {
        return new ArrayBufferViewCtor(0);
    }
    if (typeof value === 'string') {
        value = encodeUtf8(value);
    }
    if (value instanceof ArrayBufferViewCtor) {
        return value.constructor === ArrayBufferViewCtor ? value :
            // Node's `Buffer` class passes the `instanceof Uint8Array` check, but we need
            // a real Uint8Array, since Buffer#slice isn't the same as Uint8Array#slice :/
            new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
    }
    if (value instanceof ArrayBuffer) {
        return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
        return new ArrayBufferViewCtor(value);
    }
    if (value instanceof ByteBuffer) {
        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0)
        : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
}
/** @ignore */ export const toInt8Array = (input) => toArrayBufferView(Int8Array, input);
/** @ignore */ export const toInt16Array = (input) => toArrayBufferView(Int16Array, input);
/** @ignore */ export const toInt32Array = (input) => toArrayBufferView(Int32Array, input);
/** @ignore */ export const toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
/** @ignore */ export const toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
/** @ignore */ export const toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
/** @ignore */ export const toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
/** @ignore */ export const toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
/** @ignore */ export const toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
/** @ignore */
const pump = (iterator) => { iterator.next(); return iterator; };
/** @ignore */
export function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) { yield x; };
    const buffers = (typeof source === 'string') ? wrap(source)
        : (ArrayBuffer.isView(source)) ? wrap(source)
            : (source instanceof ArrayBuffer) ? wrap(source)
                : (source instanceof SharedArrayBuf) ? wrap(source)
                    : !isIterable(source) ? wrap(source) : source;
    yield* pump((function* (it) {
        let r = null;
        do {
            r = it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
    })(buffers[Symbol.iterator]()));
}
/** @ignore */ export const toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
/** @ignore */ export const toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
/** @ignore */ export const toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
/** @ignore */ export const toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
/** @ignore */ export const toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
/** @ignore */ export const toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
/** @ignore */ export const toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
/** @ignore */ export const toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
/** @ignore */ export const toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
/** @ignore */
export async function* toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    // if a Promise, unwrap the Promise and iterate the resolved value
    if (isPromise(source)) {
        return yield* toArrayBufferViewAsyncIterator(ArrayCtor, await source);
    }
    const wrap = async function* (x) { yield await x; };
    const emit = async function* (source) {
        yield* pump((function* (it) {
            let r = null;
            do {
                r = it.next(yield r && r.value);
            } while (!r.done);
        })(source[Symbol.iterator]()));
    };
    const buffers = (typeof source === 'string') ? wrap(source) // if string, wrap in an AsyncIterableIterator
        : (ArrayBuffer.isView(source)) ? wrap(source) // if TypedArray, wrap in an AsyncIterableIterator
            : (source instanceof ArrayBuffer) ? wrap(source) // if ArrayBuffer, wrap in an AsyncIterableIterator
                : (source instanceof SharedArrayBuf) ? wrap(source) // if SharedArrayBuffer, wrap in an AsyncIterableIterator
                    : isIterable(source) ? emit(source) // If Iterable, wrap in an AsyncIterableIterator and compose the `next` values
                        : !isAsyncIterable(source) ? wrap(source) // If not an AsyncIterable, treat as a sentinel and wrap in an AsyncIterableIterator
                            : source; // otherwise if AsyncIterable, use it
    yield* pump((async function* (it) {
        let r = null;
        do {
            r = await it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
    })(buffers[Symbol.asyncIterator]()));
}
/** @ignore */ export const toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
/** @ignore */ export const toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
/** @ignore */ export const toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
/** @ignore */ export const toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
/** @ignore */ export const toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
/** @ignore */ export const toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
/** @ignore */ export const toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
/** @ignore */ export const toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
/** @ignore */ export const toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
/** @ignore */
export function rebaseValueOffsets(offset, length, valueOffsets) {
    // If we have a non-zero offset, create a new offsets array with the values
    // shifted by the start offset, such that the new start offset is 0
    if (offset !== 0) {
        valueOffsets = valueOffsets.slice(0, length + 1);
        for (let i = -1; ++i <= length;) {
            valueOffsets[i] += offset;
        }
    }
    return valueOffsets;
}
/** @ignore */
export function compareArrayLike(a, b) {
    let i = 0, n = a.length;
    if (n !== b.length) {
        return false;
    }
    if (n > 0) {
        do {
            if (a[i] !== b[i]) {
                return false;
            }
        } while (++i < n);
    }
    return true;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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LE1BQU0sQ0FBQyxNQUFNLEVBQUUsRUFBRSxLQUFLLEdBQUcsQ0FBQyxHQUFHO1FBQ3RDLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdkIsTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN0RSxJQUFJLE1BQU0sSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDcEMsSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUU7Z0JBQy9CLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNsRDtpQkFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLE1BQU0sRUFBRTtnQkFBRSxLQUFLLEVBQUUsQ0FBQzthQUFFO1lBQ3hELE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxDQUFDO1lBQzVELE1BQU07U0FDVDtRQUNELE1BQU0sQ0FBQyxNQUFNLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDcEUsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUM7S0FDM0I7SUFDRCxPQUFPLENBQUMsTUFBTSxJQUFJLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsVUFBVSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxD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QUMvRDtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUMiLCJmaWxlIjoidXRpbC9idWZmZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuaW1wb3J0IHsgZmxhdGJ1ZmZlcnMgfSBmcm9tICdmbGF0YnVmZmVycyc7XG5pbXBvcnQgeyBlbmNvZGVVdGY4IH0gZnJvbSAnLi4vdXRpbC91dGY4JztcbmltcG9ydCBCeXRlQnVmZmVyID0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcjtcbmltcG9ydCB7IEFycmF5QnVmZmVyVmlld0NvbnN0cnVjdG9yIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBpc1Byb21pc2UsIGlzSXRlcmFibGUsIGlzQXN5bmNJdGVyYWJsZSwgaXNJdGVyYXRvclJlc3VsdCB9IGZyb20gJy4vY29tcGF0JztcblxuLyoqIEBpZ25vcmUgKi9cbmNvbnN0IFNoYXJlZEFycmF5QnVmID0gKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IEFycmF5QnVmZmVyKTtcblxuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGNvbGxhcHNlQ29udGlndW91c0J5dGVSYW5nZXMoY2h1bmtzOiBVaW50OEFycmF5W10pIHtcbiAgICBsZXQgcmVzdWx0ID0gY2h1bmtzWzBdID8gW2NodW5rc1swXV0gOiBbXTtcbiAgICBsZXQgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIsIHhMZW46IG51bWJlciwgeUxlbjogbnVtYmVyO1xuICAgIGZvciAobGV0IHgsIHksIGkgPSAwLCBqID0gMCwgbiA9IGNodW5rcy5sZW5ndGg7ICsraSA8IG47KSB7XG4gICAgICAgIHggPSByZXN1bHRbal07XG4gICAgICAgIHkgPSBjaHVua3NbaV07XG4gICAgICAgIC8vIGNvbnRpbnVlIHggYW5kIHkgZG9uJ3Qgc2hhcmUgdGhlIHNhbWUgdW5kZXJseWluZyBBcnJheUJ1ZmZlclxuICAgICAgICBpZiAoIXggfHwgIXkgfHwgeC5idWZmZXIgIT09IHkuYnVmZmVyKSB7XG4gICAgICAgICAgICB5ICYmIChyZXN1bHRbKytqXSA9IHkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3dhcCBpZiB5IHN0YXJ0cyBiZWZvcmUgeFxuICAgICAgICBpZiAoeS5ieXRlT2Zmc2V0IDwgeC5ieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICB4ID0gY2h1bmtzW2ldOyB5ID0gcmVzdWx0W2pdO1xuICAgICAgICB9XG4gICAgICAgICh7IGJ5dGVPZmZzZXQ6IHhPZmZzZXQsIGJ5dGVMZW5ndGg6IHhMZW4gfSA9IHgpO1xuICAgICAgICAoeyBieXRlT2Zmc2V0OiB5T2Zmc2V0LCBieXRlTGVuZ3RoOiB5TGVuIH0gPSB5KTtcbiAgICAgICAgLy8gY29udGludWUgaWYgdGhlIGJ5dGUgcmFuZ2VzIG9mIHggYW5kIHkgYXJlbid0IGNvbnRpZ3VvdXNcbiAgICAgICAgaWYgKCh4T2Zmc2V0ICsgeExlbikgPCB5T2Zmc2V0IHx8ICh5T2Zmc2V0ICsgeUxlbikgPCB4T2Zmc2V0KSB7XG4gICAgICAgICAgICB5ICYmIChyZXN1bHRbKytqXSA9IHkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2pdID0gbmV3IFVpbnQ4QXJyYXkoeC5idWZmZXIsIHhPZmZzZXQsIHlPZmZzZXQgLSB4T2Zmc2V0ICsgeUxlbik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAaWdub3JlICovXG5leHBvcnQgZnVuY3Rpb24gbWVtY3B5PFRUYXJnZXQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXcsIFRTb3VyY2UgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KHRhcmdldDogVFRhcmdldCwgc291cmNlOiBUU291cmNlLCB0YXJnZXRCeXRlT2Zmc2V0ID0gMCwgc291cmNlQnl0ZUxlbmd0aCA9IHNvdXJjZS5ieXRlTGVuZ3RoKSB7XG4gICAgY29uc3QgdGFyZ2V0Qnl0ZUxlbmd0aCA9IHRhcmdldC5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGRzdCA9IG5ldyBVaW50OEFycmF5KHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCB0YXJnZXRCeXRlTGVuZ3RoKTtcbiAgICBjb25zdCBzcmMgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgTWF0aC5taW4oc291cmNlQnl0ZUxlbmd0aCwgdGFyZ2V0Qnl0ZUxlbmd0aCkpO1xuICAgIGRzdC5zZXQoc3JjLCB0YXJnZXRCeXRlT2Zmc2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpvaW5VaW50OEFycmF5cyhjaHVua3M6IFVpbnQ4QXJyYXlbXSwgc2l6ZT86IG51bWJlciB8IG51bGwpOiBbVWludDhBcnJheSwgVWludDhBcnJheVtdLCBudW1iZXJdIHtcbiAgICAvLyBjb2xsYXBzZSBjaHVua3MgdGhhdCBzaGFyZSB0aGUgc2FtZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyIGFuZCB3aG9zZSBieXRlIHJhbmdlcyBvdmVybGFwLFxuICAgIC8vIHRvIGF2b2lkIHVubmVjZXNzYXJpbHkgY29weWluZyB0aGUgYnl0ZXMgdG8gZG8gdGhpcyBidWZmZXIgam9pbi4gVGhpcyBpcyBhIGNvbW1vbiBjYXNlIGR1cmluZ1xuICAgIC8vIHN0cmVhbWluZywgd2hlcmUgd2UgbWF5IGJlIHJlYWRpbmcgcGFydGlhbCBieXRlIHJhbmdlcyBvdXQgb2YgdGhlIHNhbWUgdW5kZXJseWluZyBBcnJheUJ1ZmZlclxuICAgIGxldCByZXN1bHQgPSBjb2xsYXBzZUNvbnRpZ3VvdXNCeXRlUmFuZ2VzKGNodW5rcyk7XG4gICAgbGV0IGJ5dGVMZW5ndGggPSByZXN1bHQucmVkdWNlKCh4LCBiKSA9PiB4ICsgYi5ieXRlTGVuZ3RoLCAwKTtcbiAgICBsZXQgc291cmNlOiBVaW50OEFycmF5LCBzbGljZWQ6IFVpbnQ4QXJyYXksIGJ1ZmZlcjogVWludDhBcnJheSB8IHZvaWQ7XG4gICAgbGV0IG9mZnNldCA9IDAsIGluZGV4ID0gLTEsIGxlbmd0aCA9IE1hdGgubWluKHNpemUgfHwgSW5maW5pdHksIGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IG4gPSByZXN1bHQubGVuZ3RoOyArK2luZGV4IDwgbjspIHtcbiAgICAgICAgc291cmNlID0gcmVzdWx0W2luZGV4XTtcbiAgICAgICAgc2xpY2VkID0gc291cmNlLnN1YmFycmF5KDAsIE1hdGgubWluKHNvdXJjZS5sZW5ndGgsIGxlbmd0aCAtIG9mZnNldCkpO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IChvZmZzZXQgKyBzbGljZWQubGVuZ3RoKSkge1xuICAgICAgICAgICAgaWYgKHNsaWNlZC5sZW5ndGggPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHNvdXJjZS5zdWJhcnJheShzbGljZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xpY2VkLmxlbmd0aCA9PT0gc291cmNlLmxlbmd0aCkgeyBpbmRleCsrOyB9XG4gICAgICAgICAgICBidWZmZXIgPyBtZW1jcHkoYnVmZmVyLCBzbGljZWQsIG9mZnNldCkgOiAoYnVmZmVyID0gc2xpY2VkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1lbWNweShidWZmZXIgfHwgKGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCkpLCBzbGljZWQsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBzbGljZWQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gW2J1ZmZlciB8fCBuZXcgVWludDhBcnJheSgwKSwgcmVzdWx0LnNsaWNlKGluZGV4KSwgYnl0ZUxlbmd0aCAtIChidWZmZXIgPyBidWZmZXIuYnl0ZUxlbmd0aCA6IDApXTtcbn1cblxuLyoqIEBpZ25vcmUgKi9cbmV4cG9ydCB0eXBlIEFycmF5QnVmZmVyVmlld0lucHV0ID0gQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXJMaWtlIHwgQXJyYXlCdWZmZXJWaWV3IHwgSXRlcmFibGU8bnVtYmVyPiB8IEFycmF5TGlrZTxudW1iZXI+IHwgQnl0ZUJ1ZmZlciB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQgIHxcbiAgICAgICAgICAgICAgICAgICAgSXRlcmF0b3JSZXN1bHQ8QXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXJMaWtlIHwgQXJyYXlCdWZmZXJWaWV3IHwgSXRlcmFibGU8bnVtYmVyPiB8IEFycmF5TGlrZTxudW1iZXI+IHwgQnl0ZUJ1ZmZlciB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+IHxcbiAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRSZXN1bHQ8QXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXJMaWtlIHwgQXJyYXlCdWZmZXJWaWV3IHwgSXRlcmFibGU8bnVtYmVyPiB8IEFycmF5TGlrZTxudW1iZXI+IHwgQnl0ZUJ1ZmZlciB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+IDtcblxuLyoqIEBpZ25vcmUgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5QnVmZmVyVmlldzxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PihBcnJheUJ1ZmZlclZpZXdDdG9yOiBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPiwgaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KTogVCB7XG5cbiAgICBsZXQgdmFsdWU6IGFueSA9IGlzSXRlcmF0b3JSZXN1bHQoaW5wdXQpID8gaW5wdXQudmFsdWUgOiBpbnB1dDtcblxuICAgIGlmICghdmFsdWUpIHsgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlclZpZXdDdG9yKDApOyB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsgdmFsdWUgPSBlbmNvZGVVdGY4KHZhbHVlKTsgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyVmlld0N0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlclZpZXdDdG9yID8gdmFsdWUgOlxuICAgICAgICAgICAgLy8gTm9kZSdzIGBCdWZmZXJgIGNsYXNzIHBhc3NlcyB0aGUgYGluc3RhbmNlb2YgVWludDhBcnJheWAgY2hlY2ssIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhIHJlYWwgVWludDhBcnJheSwgc2luY2UgQnVmZmVyI3NsaWNlIGlzbid0IHRoZSBzYW1lIGFzIFVpbnQ4QXJyYXkjc2xpY2UgOi9cbiAgICAgICAgICAgIG5ldyBBcnJheUJ1ZmZlclZpZXdDdG9yKHZhbHVlLmJ1ZmZlciwgdmFsdWUuYnl0ZU9mZnNldCwgdmFsdWUuYnl0ZUxlbmd0aCAvIEFycmF5QnVmZmVyVmlld0N0b3IuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgeyByZXR1cm4gbmV3IEFycmF5QnVmZmVyVmlld0N0b3IodmFsdWUpOyB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWYpIHsgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlclZpZXdDdG9yKHZhbHVlKTsgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpIHsgcmV0dXJuIHRvQXJyYXlCdWZmZXJWaWV3KEFycmF5QnVmZmVyVmlld0N0b3IsIHZhbHVlLmJ5dGVzKCkpOyB9XG4gICAgcmV0dXJuICFBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpID8gQXJyYXlCdWZmZXJWaWV3Q3Rvci5mcm9tKHZhbHVlKSA6IHZhbHVlLmJ5dGVMZW5ndGggPD0gMCA/IG5ldyBBcnJheUJ1ZmZlclZpZXdDdG9yKDApXG4gICAgICAgIDogbmV3IEFycmF5QnVmZmVyVmlld0N0b3IodmFsdWUuYnVmZmVyLCB2YWx1ZS5ieXRlT2Zmc2V0LCB2YWx1ZS5ieXRlTGVuZ3RoIC8gQXJyYXlCdWZmZXJWaWV3Q3Rvci5CWVRFU19QRVJfRUxFTUVOVCk7XG59XG5cbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDhBcnJheSA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3KEludDhBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50MTZBcnJheSA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3KEludDE2QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0ludDMyQXJyYXkgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlldyhJbnQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50OEFycmF5ID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXcoVWludDhBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDE2QXJyYXkgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlldyhVaW50MTZBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDMyQXJyYXkgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlldyhVaW50MzJBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvRmxvYXQzMkFycmF5ID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXcoRmxvYXQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9GbG9hdDY0QXJyYXkgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0lucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlldyhGbG9hdDY0QXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b1VpbnQ4Q2xhbXBlZEFycmF5ID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXcoVWludDhDbGFtcGVkQXJyYXksIGlucHV0KTtcblxuLyoqIEBpZ25vcmUgKi9cbnR5cGUgQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCA9IEl0ZXJhYmxlPEFycmF5QnVmZmVyVmlld0lucHV0PiB8IEFycmF5QnVmZmVyVmlld0lucHV0O1xuXG4vKiogQGlnbm9yZSAqL1xuY29uc3QgcHVtcCA9IDxUIGV4dGVuZHMgSXRlcmF0b3I8YW55PiB8IEFzeW5jSXRlcmF0b3I8YW55Pj4oaXRlcmF0b3I6IFQpID0+IHsgaXRlcmF0b3IubmV4dCgpOyByZXR1cm4gaXRlcmF0b3I7IH07XG5cbi8qKiBAaWdub3JlICovXG5leHBvcnQgZnVuY3Rpb24qIHRvQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3I8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4oQXJyYXlDdG9yOiBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPiwgc291cmNlOiBBcnJheUJ1ZmZlclZpZXdJdGVyYXRvcklucHV0KSB7XG5cbiAgICBjb25zdCB3cmFwID0gZnVuY3Rpb24qPFQ+KHg6IFQpIHsgeWllbGQgeDsgfTtcbiAgICBjb25zdCBidWZmZXJzOiBJdGVyYWJsZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4gPVxuICAgICAgICAgICAgICAgICAgICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykgPyB3cmFwKHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgOiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpID8gd3JhcChzb3VyY2UpXG4gICAgICAgICAgICAgIDogKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSA/IHdyYXAoc291cmNlKVxuICAgICAgICAgICA6IChzb3VyY2UgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZikgPyB3cmFwKHNvdXJjZSlcbiAgICA6ICFpc0l0ZXJhYmxlPEFycmF5QnVmZmVyVmlld0lucHV0Pihzb3VyY2UpID8gd3JhcChzb3VyY2UpIDogc291cmNlO1xuXG4gICAgeWllbGQqIHB1bXAoKGZ1bmN0aW9uKiAoaXQpIHtcbiAgICAgICAgbGV0IHI6IEl0ZXJhdG9yUmVzdWx0PGFueT4gPSA8YW55PiBudWxsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByID0gaXQubmV4dCh5aWVsZCB0b0FycmF5QnVmZmVyVmlldyhBcnJheUN0b3IsIHIpKTtcbiAgICAgICAgfSB3aGlsZSAoIXIuZG9uZSk7XG4gICAgfSkoYnVmZmVyc1tTeW1ib2wuaXRlcmF0b3JdKCkpKTtcbn1cblxuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50OEFycmF5SXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3IoSW50OEFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9JbnQxNkFycmF5SXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3IoSW50MTZBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50MzJBcnJheUl0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0l0ZXJhdG9yKEludDMyQXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b1VpbnQ4QXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihVaW50OEFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50MTZBcnJheUl0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0l0ZXJhdG9yKFVpbnQxNkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50MzJBcnJheUl0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0l0ZXJhdG9yKFVpbnQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9GbG9hdDMyQXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihGbG9hdDMyQXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0Zsb2F0NjRBcnJheUl0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0l0ZXJhdG9yKEZsb2F0NjRBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDhDbGFtcGVkQXJyYXlJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3SXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdJdGVyYXRvcihVaW50OENsYW1wZWRBcnJheSwgaW5wdXQpO1xuXG4vKiogQGlnbm9yZSAqL1xudHlwZSBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQgPSBBc3luY0l0ZXJhYmxlPEFycmF5QnVmZmVyVmlld0lucHV0PiB8IEl0ZXJhYmxlPEFycmF5QnVmZmVyVmlld0lucHV0PiB8IFByb21pc2VMaWtlPEFycmF5QnVmZmVyVmlld0lucHV0PiB8IEFycmF5QnVmZmVyVmlld0lucHV0O1xuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiB0b0FycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3I8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4oQXJyYXlDdG9yOiBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPiwgc291cmNlOiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpOiBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8VD4ge1xuXG4gICAgLy8gaWYgYSBQcm9taXNlLCB1bndyYXAgdGhlIFByb21pc2UgYW5kIGl0ZXJhdGUgdGhlIHJlc29sdmVkIHZhbHVlXG4gICAgaWYgKGlzUHJvbWlzZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4oc291cmNlKSkge1xuICAgICAgICByZXR1cm4geWllbGQqIHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihBcnJheUN0b3IsIGF3YWl0IHNvdXJjZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgd3JhcCA9IGFzeW5jIGZ1bmN0aW9uKjxUPih4OiBUKSB7IHlpZWxkIGF3YWl0IHg7IH07XG4gICAgY29uc3QgZW1pdCA9IGFzeW5jIGZ1bmN0aW9uKiA8VCBleHRlbmRzIEl0ZXJhYmxlPGFueT4+KHNvdXJjZTogVCkge1xuICAgICAgICB5aWVsZCogcHVtcCgoZnVuY3Rpb24qKGl0OiBJdGVyYXRvcjxhbnk+KSB7XG4gICAgICAgICAgICBsZXQgcjogSXRlcmF0b3JSZXN1bHQ8YW55PiA9IDxhbnk+IG51bGw7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgciA9IGl0Lm5leHQoeWllbGQgciAmJiByLnZhbHVlKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKCFyLmRvbmUpO1xuICAgICAgICB9KShzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSgpKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGJ1ZmZlcnM6IEFzeW5jSXRlcmFibGU8QXJyYXlCdWZmZXJWaWV3SW5wdXQ+ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykgPyB3cmFwKHNvdXJjZSkgLy8gaWYgc3RyaW5nLCB3cmFwIGluIGFuIEFzeW5jSXRlcmFibGVJdGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAgIDogKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSA/IHdyYXAoc291cmNlKSAvLyBpZiBUeXBlZEFycmF5LCB3cmFwIGluIGFuIEFzeW5jSXRlcmFibGVJdGVyYXRvclxuICAgICAgICAgICAgICAgICAgIDogKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSA/IHdyYXAoc291cmNlKSAvLyBpZiBBcnJheUJ1ZmZlciwgd3JhcCBpbiBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3JcbiAgICAgICAgICAgICAgICA6IChzb3VyY2UgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZikgPyB3cmFwKHNvdXJjZSkgLy8gaWYgU2hhcmVkQXJyYXlCdWZmZXIsIHdyYXAgaW4gYW4gQXN5bmNJdGVyYWJsZUl0ZXJhdG9yXG4gICAgICAgICAgOiBpc0l0ZXJhYmxlPEFycmF5QnVmZmVyVmlld0lucHV0Pihzb3VyY2UpID8gZW1pdChzb3VyY2UpIC8vIElmIEl0ZXJhYmxlLCB3cmFwIGluIGFuIEFzeW5jSXRlcmFibGVJdGVyYXRvciBhbmQgY29tcG9zZSB0aGUgYG5leHRgIHZhbHVlc1xuICAgIDogIWlzQXN5bmNJdGVyYWJsZTxBcnJheUJ1ZmZlclZpZXdJbnB1dD4oc291cmNlKSA/IHdyYXAoc291cmNlKSAvLyBJZiBub3QgYW4gQXN5bmNJdGVyYWJsZSwgdHJlYXQgYXMgYSBzZW50aW5lbCBhbmQgd3JhcCBpbiBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzb3VyY2U7IC8vIG90aGVyd2lzZSBpZiBBc3luY0l0ZXJhYmxlLCB1c2UgaXRcblxuICAgIHlpZWxkKiBwdW1wKChhc3luYyBmdW5jdGlvbiogKGl0KSB7XG4gICAgICAgIGxldCByOiBJdGVyYXRvclJlc3VsdDxhbnk+ID0gPGFueT4gbnVsbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgciA9IGF3YWl0IGl0Lm5leHQoeWllbGQgdG9BcnJheUJ1ZmZlclZpZXcoQXJyYXlDdG9yLCByKSk7XG4gICAgICAgIH0gd2hpbGUgKCFyLmRvbmUpO1xuICAgIH0pKGJ1ZmZlcnNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpKTtcbn1cblxuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50OEFycmF5QXN5bmNJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3IoSW50OEFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9JbnQxNkFycmF5QXN5bmNJdGVyYXRvciA9IChpbnB1dDogQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcklucHV0KSA9PiB0b0FycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3IoSW50MTZBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvSW50MzJBcnJheUFzeW5jSXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yKEludDMyQXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b1VpbnQ4QXJyYXlBc3luY0l0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihVaW50OEFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50MTZBcnJheUFzeW5jSXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yKFVpbnQxNkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9VaW50MzJBcnJheUFzeW5jSXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yKFVpbnQzMkFycmF5LCBpbnB1dCk7XG4vKiogQGlnbm9yZSAqLyBleHBvcnQgY29uc3QgdG9GbG9hdDMyQXJyYXlBc3luY0l0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihGbG9hdDMyQXJyYXksIGlucHV0KTtcbi8qKiBAaWdub3JlICovIGV4cG9ydCBjb25zdCB0b0Zsb2F0NjRBcnJheUFzeW5jSXRlcmF0b3IgPSAoaW5wdXQ6IEFycmF5QnVmZmVyVmlld0FzeW5jSXRlcmF0b3JJbnB1dCkgPT4gdG9BcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9yKEZsb2F0NjRBcnJheSwgaW5wdXQpO1xuLyoqIEBpZ25vcmUgKi8gZXhwb3J0IGNvbnN0IHRvVWludDhDbGFtcGVkQXJyYXlBc3luY0l0ZXJhdG9yID0gKGlucHV0OiBBcnJheUJ1ZmZlclZpZXdBc3luY0l0ZXJhdG9ySW5wdXQpID0+IHRvQXJyYXlCdWZmZXJWaWV3QXN5bmNJdGVyYXRvcihVaW50OENsYW1wZWRBcnJheSwgaW5wdXQpO1xuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYmFzZVZhbHVlT2Zmc2V0cyhvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIHZhbHVlT2Zmc2V0czogSW50MzJBcnJheSkge1xuICAgIC8vIElmIHdlIGhhdmUgYSBub24temVybyBvZmZzZXQsIGNyZWF0ZSBhIG5ldyBvZmZzZXRzIGFycmF5IHdpdGggdGhlIHZhbHVlc1xuICAgIC8vIHNoaWZ0ZWQgYnkgdGhlIHN0YXJ0IG9mZnNldCwgc3VjaCB0aGF0IHRoZSBuZXcgc3RhcnQgb2Zmc2V0IGlzIDBcbiAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIHZhbHVlT2Zmc2V0cyA9IHZhbHVlT2Zmc2V0cy5zbGljZSgwLCBsZW5ndGggKyAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IC0xOyArK2kgPD0gbGVuZ3RoOykge1xuICAgICAgICAgICAgdmFsdWVPZmZzZXRzW2ldICs9IG9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVPZmZzZXRzO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVBcnJheUxpa2U8VCBleHRlbmRzIEFycmF5TGlrZTxhbnk+PihhOiBULCBiOiBUKSB7XG4gICAgbGV0IGkgPSAwLCBuID0gYS5sZW5ndGg7XG4gICAgaWYgKG4gIT09IGIubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChuID4gMCkge1xuICAgICAgICBkbyB7IGlmIChhW2ldICE9PSBiW2ldKSB7IHJldHVybiBmYWxzZTsgfSB9IHdoaWxlICgrK2kgPCBuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4iXX0=
