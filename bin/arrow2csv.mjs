#! /usr/bin/env node
import * as fs from 'fs';
import * as stream from 'stream';
import { valueToString } from '../util/pretty';
import { RecordBatchReader, AsyncByteQueue } from '../Arrow.node';
const padLeft = require('pad-left');
const bignumJSONParse = require('json-bignum').parse;
const pipeline = require('util').promisify(stream.pipeline);
const argv = require(`command-line-args`)(cliOpts(), { partial: true });
const files = argv.help ? [] : [...(argv.file || []), ...(argv._unknown || [])].filter(Boolean);
const state = { ...argv, closed: false, hasRecords: false };
(async () => {
    const sources = argv.help ? [] : [
        ...files.map((file) => () => fs.createReadStream(file)),
        ...(process.stdin.isTTY ? [] : [() => process.stdin])
    ].filter(Boolean);
    let reader;
    for (const source of sources) {
        if (state.closed) {
            break;
        }
        if (reader = await createRecordBatchReader(source)) {
            await pipeline(reader.toNodeStream(), recordBatchRowsToString(state), process.stdout).catch(() => state.closed = true);
        }
        if (state.closed) {
            break;
        }
    }
    return state.hasRecords ? 0 : print_usage();
})()
    .then((x) => +x || 0, (err) => {
    if (err) {
        console.error(`${err && err.stack || err}`);
    }
    return process.exitCode || 1;
}).then((code) => process.exit(code));
async function createRecordBatchReader(createSourceStream) {
    let json = new AsyncByteQueue();
    let stream = new AsyncByteQueue();
    let source = createSourceStream();
    let reader = null;
    // tee the input source, just in case it's JSON
    source.on('end', () => [stream, json].forEach((y) => y.close()))
        .on('data', (x) => [stream, json].forEach((y) => y.write(x)))
        .on('error', (e) => [stream, json].forEach((y) => y.abort(e)));
    try {
        reader = await (await RecordBatchReader.from(stream)).open();
    }
    catch (e) {
        reader = null;
    }
    if (!reader || reader.closed) {
        reader = null;
        await json.closed;
        if (source instanceof fs.ReadStream) {
            source.close();
        }
        // If the data in the `json` ByteQueue parses to JSON, then assume it's Arrow JSON from a file or stdin
        try {
            reader = await (await RecordBatchReader.from(bignumJSONParse(await json.toString()))).open();
        }
        catch (e) {
            reader = null;
        }
    }
    return (reader && !reader.closed) ? reader : null;
}
function recordBatchRowsToString(state) {
    let rowId = 0, maxColWidths = [15], separator = `${state.separator || ' |'} `;
    return new stream.Transform({ transform, encoding: 'utf8', writableObjectMode: true, readableObjectMode: false });
    function transform(batch, _enc, cb) {
        batch = !(state.schema && state.schema.length) ? batch : batch.select(...state.schema);
        if (batch.length <= 0 || batch.numCols <= 0 || state.closed) {
            state.hasRecords || (state.hasRecords = false);
            return cb(undefined, null);
        }
        state.hasRecords = true;
        const header = ['row_id', ...batch.schema.fields.map((f) => `${f}`)].map(valueToString);
        // Pass one to convert to strings and count max column widths
        const newMaxWidths = measureColumnWidths(rowId, batch, header.map((x, i) => Math.max(maxColWidths[i] || 0, x.length)));
        // If any of the column widths changed, print the header again
        if ((rowId % 350) && JSON.stringify(newMaxWidths) !== JSON.stringify(maxColWidths)) {
            this.push(`\n${formatRow(header, newMaxWidths, separator)}`);
        }
        maxColWidths = newMaxWidths;
        for (const row of batch) {
            if (state.closed) {
                break;
            }
            else if (!row) {
                continue;
            }
            if (!(rowId % 350)) {
                this.push(`\n${formatRow(header, maxColWidths, separator)}`);
            }
            this.push(formatRow([rowId++, ...row].map(valueToString), maxColWidths, separator));
        }
        cb();
    }
}
function formatRow(row = [], maxColWidths = [], separator = ' |') {
    return row.map((x, j) => padLeft(x, maxColWidths[j])).join(separator) + '\n';
}
function measureColumnWidths(rowId, batch, maxColWidths = []) {
    for (const row of batch) {
        if (!row) {
            continue;
        }
        maxColWidths[0] = Math.max(maxColWidths[0] || 0, (`${rowId++}`).length);
        for (let val, j = -1, k = row.length; ++j < k;) {
            if (ArrayBuffer.isView(val = row[j]) && (typeof val[Symbol.toPrimitive] !== 'function')) {
                // If we're printing a column of TypedArrays, ensure the column is wide enough to accommodate
                // the widest possible element for a given byte size, since JS omits leading zeroes. For example:
                // 1 |  [1137743649,2170567488,244696391,2122556476]
                // 2 |                                          null
                // 3 |   [637174007,2142281880,961736230,2912449282]
                // 4 |    [1035112265,21832886,412842672,2207710517]
                // 5 |                                          null
                // 6 |                                          null
                // 7 |     [2755142991,4192423256,2994359,467878370]
                const elementWidth = typedArrayElementWidths.get(val.constructor);
                maxColWidths[j + 1] = Math.max(maxColWidths[j + 1] || 0, 2 + // brackets on each end
                    (val.length - 1) + // commas between elements
                    (val.length * elementWidth) // width of stringified 2^N-1
                );
            }
            else {
                maxColWidths[j + 1] = Math.max(maxColWidths[j + 1] || 0, valueToString(val).length);
            }
        }
    }
    return maxColWidths;
}
// Measure the stringified representation of 2^N-1 for each TypedArray variant
const typedArrayElementWidths = (() => {
    const maxElementWidth = (ArrayType) => {
        const octets = Array.from({ length: ArrayType.BYTES_PER_ELEMENT - 1 }, _ => 255);
        return `${new ArrayType(new Uint8Array([...octets, 254]).buffer)[0]}`.length;
    };
    return new Map([
        [Int8Array, maxElementWidth(Int8Array)],
        [Int16Array, maxElementWidth(Int16Array)],
        [Int32Array, maxElementWidth(Int32Array)],
        [Uint8Array, maxElementWidth(Uint8Array)],
        [Uint16Array, maxElementWidth(Uint16Array)],
        [Uint32Array, maxElementWidth(Uint32Array)],
        [Float32Array, maxElementWidth(Float32Array)],
        [Float64Array, maxElementWidth(Float64Array)],
        [Uint8ClampedArray, maxElementWidth(Uint8ClampedArray)]
    ]);
})();
function cliOpts() {
    return [
        {
            type: String,
            name: 'schema', alias: 's',
            optional: true, multiple: true,
            typeLabel: '{underline columns}',
            description: 'A space-delimited list of column names'
        },
        {
            type: String,
            name: 'file', alias: 'f',
            optional: true, multiple: true,
            description: 'The Arrow file to read'
        },
        {
            type: String,
            name: 'sep', optional: true, default: '|',
            description: 'The column separator character'
        },
        {
            type: Boolean,
            name: 'help', optional: true, default: false,
            description: 'Print this usage guide.'
        }
    ];
}
function print_usage() {
    console.log(require('command-line-usage')([
        {
            header: 'arrow2csv',
            content: 'Print a CSV from an Arrow file'
        },
        {
            header: 'Synopsis',
            content: [
                '$ arrow2csv {underline file.arrow} [{bold --schema} column_name ...]',
                '$ arrow2csv [{bold --schema} column_name ...] [{bold --file} {underline file.arrow}]',
                '$ arrow2csv {bold -s} column_1 {bold -s} column_2 [{bold -f} {underline file.arrow}]',
                '$ arrow2csv [{bold --help}]'
            ]
        },
        {
            header: 'Options',
            optionList: cliOpts()
        },
        {
            header: 'Example',
            content: [
                '$ arrow2csv --schema foo baz -f simple.arrow --sep ","',
                '                                                      ',
                '> "row_id", "foo: Int32", "bar: Float64", "baz: Utf8"',
                '>        0,            1,              1,        "aa"',
                '>        1,         null,           null,        null',
                '>        2,            3,           null,        null',
                '>        3,            4,              4,       "bbb"',
                '>        4,            5,              5,      "cccc"',
            ]
        }
    ]));
    return 1;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJpbi9hcnJvdzJjc3YudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQXFCQSxPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUN6QixPQUFPLEtBQUssTUFBTSxNQUFNLFFBQVEsQ0FBQztBQUNqQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0MsT0FBTyxFQUFlLGlCQUFpQixFQUFFLGNBQWMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUvRSxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDcEMsTUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNyRCxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM1RCxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQ3hFLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUVoRyxNQUFNLEtBQUssR0FBRyxFQUFFLEdBQUcsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxDQUFDO0FBRTVELENBQUMsS0FBSyxJQUFJLEVBQUU7SUFFUixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzdCLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZELEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUN4RCxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQW9DLENBQUM7SUFFckQsSUFBSSxNQUFnQyxDQUFDO0lBRXJDLEtBQUssTUFBTSxNQUFNLElBQUksT0FBTyxFQUFFO1FBQzFCLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUFFLE1BQU07U0FBRTtRQUM1QixJQUFJLE1BQU0sR0FBRyxNQUFNLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2hELE1BQU0sUUFBUSxDQUNWLE1BQU0sQ0FBQyxZQUFZLEVBQUUsRUFDckIsdUJBQXVCLENBQUMsS0FBSyxDQUFDLEVBQzlCLE9BQU8sQ0FBQyxNQUFNLENBQ2pCLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUM7U0FDdEM7UUFDRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7WUFBRSxNQUFNO1NBQUU7S0FDL0I7SUFFRCxPQUFPLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDaEQsQ0FBQyxDQUFDLEVBQUU7S0FDSCxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFO0lBQzFCLElBQUksR0FBRyxFQUFFO1FBQ0wsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsS0FBSyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUM7S0FDL0M7SUFDRCxPQUFPLE9BQU8sQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDO0FBQ2pDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBRXRDLEtBQUssVUFBVSx1QkFBdUIsQ0FBQyxrQkFBK0M7SUFFbEYsSUFBSSxJQUFJLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztJQUNoQyxJQUFJLE1BQU0sR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO0lBQ2xDLElBQUksTUFBTSxHQUFHLGtCQUFrQixFQUFFLENBQUM7SUFDbEMsSUFBSSxNQUFNLEdBQTZCLElBQUksQ0FBQztJQUM1QywrQ0FBK0M7SUFDL0MsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUMzRCxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM3RCxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRWxFLElBQUk7UUFDQSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0saUJBQWlCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDaEU7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUFFLE1BQU0sR0FBRyxJQUFJLENBQUM7S0FBRTtJQUU5QixJQUFJLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7UUFDMUIsTUFBTSxHQUFHLElBQUksQ0FBQztRQUNkLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNsQixJQUFJLE1BQU0sWUFBWSxFQUFFLENBQUMsVUFBVSxFQUFFO1lBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQUU7UUFDeEQsdUdBQXVHO1FBQ3ZHLElBQUk7WUFDQSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0saUJBQWlCLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUNoRztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQUUsTUFBTSxHQUFHLElBQUksQ0FBQztTQUFFO0tBQ2pDO0lBRUQsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDdEQsQ0FBQztBQUVELFNBQVMsdUJBQXVCLENBQUMsS0FBK0U7SUFFNUcsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLFlBQVksR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFNBQVMsR0FBRyxHQUFHLEtBQUssQ0FBQyxTQUFTLElBQUksSUFBSSxHQUFHLENBQUM7SUFFOUUsT0FBTyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxJQUFJLEVBQUUsa0JBQWtCLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUVsSCxTQUFTLFNBQVMsQ0FBeUIsS0FBa0IsRUFBRSxJQUFZLEVBQUUsRUFBdUM7UUFDaEgsS0FBSyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN2RixJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7WUFDekQsS0FBSyxDQUFDLFVBQVUsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUM7WUFDL0MsT0FBTyxFQUFFLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzlCO1FBRUQsS0FBSyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7UUFDeEIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUV4Riw2REFBNkQ7UUFDN0QsTUFBTSxZQUFZLEdBQUcsbUJBQW1CLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFdkgsOERBQThEO1FBQzlELElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQ2hGLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxTQUFTLENBQUMsTUFBTSxFQUFFLFlBQVksRUFBRSxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDaEU7UUFFRCxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBRTVCLEtBQUssTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFO1lBQ3JCLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtnQkFBRSxNQUFNO2FBQUU7aUJBQ3ZCLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQUUsU0FBUzthQUFFO1lBQzVCLElBQUksQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsRUFBRTtnQkFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssU0FBUyxDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQUU7WUFDckYsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztTQUN2RjtRQUNELEVBQUUsRUFBRSxDQUFDO0lBQ1QsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFTLFNBQVMsQ0FBQyxNQUFnQixFQUFFLEVBQUUsZUFBeUIsRUFBRSxFQUFFLFlBQW9CLElBQUk7SUFDeEYsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDakYsQ0FBQztBQUVELFNBQVMsbUJBQW1CLENBQUMsS0FBYSxFQUFFLEtBQWtCLEVBQUUsZUFBeUIsRUFBRTtJQUN2RixLQUFLLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBRTtRQUNyQixJQUFJLENBQUMsR0FBRyxFQUFFO1lBQUUsU0FBUztTQUFFO1FBQ3ZCLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN4RSxLQUFLLElBQUksR0FBUSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUc7WUFDakQsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsS0FBSyxVQUFVLENBQUMsRUFBRTtnQkFDckYsNkZBQTZGO2dCQUM3RixpR0FBaUc7Z0JBQ2pHLG9EQUFvRDtnQkFDcEQsb0RBQW9EO2dCQUNwRCxvREFBb0Q7Z0JBQ3BELG9EQUFvRDtnQkFDcEQsb0RBQW9EO2dCQUNwRCxvREFBb0Q7Z0JBQ3BELG9EQUFvRDtnQkFDcEQsTUFBTSxZQUFZLEdBQUcsdUJBQXVCLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUUsQ0FBQztnQkFFbkUsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUNuRCxDQUFDLEdBQUcsdUJBQXVCO29CQUMzQixDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsMEJBQTBCO29CQUM3QyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsWUFBWSxDQUFDLENBQUMsNkJBQTZCO2lCQUM1RCxDQUFDO2FBQ0w7aUJBQU07Z0JBQ0gsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUN2RjtTQUNKO0tBQ0o7SUFDRCxPQUFPLFlBQVksQ0FBQztBQUN4QixDQUFDO0FBRUQsOEVBQThFO0FBQzlFLE1BQU0sdUJBQXVCLEdBQUcsQ0FBQyxHQUFHLEVBQUU7SUFDbEMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxTQUFjLEVBQUUsRUFBRTtRQUN2QyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLFNBQVMsQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pGLE9BQU8sR0FBRyxJQUFJLFNBQVMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUM7SUFDakYsQ0FBQyxDQUFDO0lBQ0YsT0FBTyxJQUFJLEdBQUcsQ0FBYztRQUN4QixDQUFDLFNBQVMsRUFBRSxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdkMsQ0FBQyxVQUFVLEVBQUUsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3pDLENBQUMsVUFBVSxFQUFFLGVBQWUsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN6QyxDQUFDLFVBQVUsRUFBRSxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDekMsQ0FBQyxXQUFXLEVBQUUsZUFBZSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzNDLENBQUMsV0FBVyxFQUFFLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzQyxDQUFDLFlBQVksRUFBRSxlQUFlLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDN0MsQ0FBQyxZQUFZLEVBQUUsZUFBZSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzdDLENBQUMsaUJBQWlCLEVBQUUsZUFBZSxDQUFDLGlCQUFpQixDQUFDLENBQUM7S0FDMUQsQ0FBQyxDQUFBO0FBQ04sQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUVMLFNBQVMsT0FBTztJQUNaLE9BQU87UUFDSDtZQUNJLElBQUksRUFBRSxNQUFNO1lBQ1osSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsR0FBRztZQUMxQixRQUFRLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJO1lBQzlCLFNBQVMsRUFBRSxxQkFBcUI7WUFDaEMsV0FBVyxFQUFFLHdDQUF3QztTQUN4RDtRQUNEO1lBQ0ksSUFBSSxFQUFFLE1BQU07WUFDWixJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHO1lBQ3hCLFFBQVEsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUk7WUFDOUIsV0FBVyxFQUFFLHdCQUF3QjtTQUN4QztRQUNEO1lBQ0ksSUFBSSxFQUFFLE1BQU07WUFDWixJQUFJLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEdBQUc7WUFDekMsV0FBVyxFQUFFLGdDQUFnQztTQUNoRDtRQUNEO1lBQ0ksSUFBSSxFQUFFLE9BQU87WUFDYixJQUFJLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUs7WUFDNUMsV0FBVyxFQUFFLHlCQUF5QjtTQUN6QztLQUNKLENBQUM7QUFDTixDQUFDO0FBRUQsU0FBUyxXQUFXO0lBQ2hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDdEM7WUFDSSxNQUFNLEVBQUUsV0FBVztZQUNuQixPQUFPLEVBQUUsZ0NBQWdDO1NBQzVDO1FBQ0Q7WUFDSSxNQUFNLEVBQUUsVUFBVTtZQUNsQixPQUFPLEVBQUU7Z0JBQ0wsc0VBQXNFO2dCQUN0RSxzRkFBc0Y7Z0JBQ3RGLHNGQUFzRjtnQkFDdEYsNkJBQTZCO2FBQ2hDO1NBQ0o7UUFDRDtZQUNJLE1BQU0sRUFBRSxTQUFTO1lBQ2pCLFVBQVUsRUFBRSxPQUFPLEVBQUU7U0FDeEI7UUFDRDtZQUNJLE1BQU0sRUFBRSxTQUFTO1lBQ2pCLE9BQU8sRUFBRTtnQkFDTCx3REFBd0Q7Z0JBQ3hELHdEQUF3RDtnQkFDeEQsdURBQXVEO2dCQUN2RCx1REFBdUQ7Z0JBQ3ZELHVEQUF1RDtnQkFDdkQsdURBQXVEO2dCQUN2RCx1REFBdUQ7Z0JBQ3ZELHVEQUF1RDthQUMxRDtTQUNKO0tBQ0osQ0FBQyxDQUFDLENBQUM7SUFDSixPQUFPLENBQUMsQ0FBQztBQUNiLENBQUMiLCJmaWxlIjoiYmluL2Fycm93MmNzdi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiMhIC91c3IvYmluL2VudiBub2RlXG5cbi8vIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBzdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCB7IHZhbHVlVG9TdHJpbmcgfSBmcm9tICcuLi91dGlsL3ByZXR0eSc7XG5pbXBvcnQgeyBSZWNvcmRCYXRjaCwgUmVjb3JkQmF0Y2hSZWFkZXIsIEFzeW5jQnl0ZVF1ZXVlIH0gZnJvbSAnLi4vQXJyb3cubm9kZSc7XG5cbmNvbnN0IHBhZExlZnQgPSByZXF1aXJlKCdwYWQtbGVmdCcpO1xuY29uc3QgYmlnbnVtSlNPTlBhcnNlID0gcmVxdWlyZSgnanNvbi1iaWdudW0nKS5wYXJzZTtcbmNvbnN0IHBpcGVsaW5lID0gcmVxdWlyZSgndXRpbCcpLnByb21pc2lmeShzdHJlYW0ucGlwZWxpbmUpO1xuY29uc3QgYXJndiA9IHJlcXVpcmUoYGNvbW1hbmQtbGluZS1hcmdzYCkoY2xpT3B0cygpLCB7IHBhcnRpYWw6IHRydWUgfSk7XG5jb25zdCBmaWxlcyA9IGFyZ3YuaGVscCA/IFtdIDogWy4uLihhcmd2LmZpbGUgfHwgW10pLCAuLi4oYXJndi5fdW5rbm93biB8fCBbXSldLmZpbHRlcihCb29sZWFuKTtcblxuY29uc3Qgc3RhdGUgPSB7IC4uLmFyZ3YsIGNsb3NlZDogZmFsc2UsIGhhc1JlY29yZHM6IGZhbHNlIH07XG5cbihhc3luYyAoKSA9PiB7XG5cbiAgICBjb25zdCBzb3VyY2VzID0gYXJndi5oZWxwID8gW10gOiBbXG4gICAgICAgIC4uLmZpbGVzLm1hcCgoZmlsZSkgPT4gKCkgPT4gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlKSksXG4gICAgICAgIC4uLihwcm9jZXNzLnN0ZGluLmlzVFRZID8gW10gOiBbKCkgPT4gcHJvY2Vzcy5zdGRpbl0pXG4gICAgXS5maWx0ZXIoQm9vbGVhbikgYXMgKCgpID0+IE5vZGVKUy5SZWFkYWJsZVN0cmVhbSlbXTtcblxuICAgIGxldCByZWFkZXI6IFJlY29yZEJhdGNoUmVhZGVyIHwgbnVsbDtcblxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLmNsb3NlZCkgeyBicmVhazsgfVxuICAgICAgICBpZiAocmVhZGVyID0gYXdhaXQgY3JlYXRlUmVjb3JkQmF0Y2hSZWFkZXIoc291cmNlKSkge1xuICAgICAgICAgICAgYXdhaXQgcGlwZWxpbmUoXG4gICAgICAgICAgICAgICAgcmVhZGVyLnRvTm9kZVN0cmVhbSgpLFxuICAgICAgICAgICAgICAgIHJlY29yZEJhdGNoUm93c1RvU3RyaW5nKHN0YXRlKSxcbiAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZG91dFxuICAgICAgICAgICAgKS5jYXRjaCgoKSA9PiBzdGF0ZS5jbG9zZWQgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuY2xvc2VkKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlLmhhc1JlY29yZHMgPyAwIDogcHJpbnRfdXNhZ2UoKTtcbn0pKClcbi50aGVuKCh4KSA9PiAreCB8fCAwLCAoZXJyKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAke2VyciAmJiBlcnIuc3RhY2sgfHwgZXJyfWApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5leGl0Q29kZSB8fCAxO1xufSkudGhlbigoY29kZSkgPT4gcHJvY2Vzcy5leGl0KGNvZGUpKTtcblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUmVjb3JkQmF0Y2hSZWFkZXIoY3JlYXRlU291cmNlU3RyZWFtOiAoKSA9PiBOb2RlSlMuUmVhZGFibGVTdHJlYW0pIHtcblxuICAgIGxldCBqc29uID0gbmV3IEFzeW5jQnl0ZVF1ZXVlKCk7XG4gICAgbGV0IHN0cmVhbSA9IG5ldyBBc3luY0J5dGVRdWV1ZSgpO1xuICAgIGxldCBzb3VyY2UgPSBjcmVhdGVTb3VyY2VTdHJlYW0oKTtcbiAgICBsZXQgcmVhZGVyOiBSZWNvcmRCYXRjaFJlYWRlciB8IG51bGwgPSBudWxsO1xuICAgIC8vIHRlZSB0aGUgaW5wdXQgc291cmNlLCBqdXN0IGluIGNhc2UgaXQncyBKU09OXG4gICAgc291cmNlLm9uKCdlbmQnLCAoKSA9PiBbc3RyZWFtLCBqc29uXS5mb3JFYWNoKCh5KSA9PiB5LmNsb3NlKCkpKVxuICAgICAgICAub24oJ2RhdGEnLCAoeCkgPT4gW3N0cmVhbSwganNvbl0uZm9yRWFjaCgoeSkgPT4geS53cml0ZSh4KSkpXG4gICAgICAgLm9uKCdlcnJvcicsIChlKSA9PiBbc3RyZWFtLCBqc29uXS5mb3JFYWNoKCh5KSA9PiB5LmFib3J0KGUpKSk7XG5cbiAgICB0cnkge1xuICAgICAgICByZWFkZXIgPSBhd2FpdCAoYXdhaXQgUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbShzdHJlYW0pKS5vcGVuKCk7XG4gICAgfSBjYXRjaCAoZSkgeyByZWFkZXIgPSBudWxsOyB9XG5cbiAgICBpZiAoIXJlYWRlciB8fCByZWFkZXIuY2xvc2VkKSB7XG4gICAgICAgIHJlYWRlciA9IG51bGw7XG4gICAgICAgIGF3YWl0IGpzb24uY2xvc2VkO1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgZnMuUmVhZFN0cmVhbSkgeyBzb3VyY2UuY2xvc2UoKTsgfVxuICAgICAgICAvLyBJZiB0aGUgZGF0YSBpbiB0aGUgYGpzb25gIEJ5dGVRdWV1ZSBwYXJzZXMgdG8gSlNPTiwgdGhlbiBhc3N1bWUgaXQncyBBcnJvdyBKU09OIGZyb20gYSBmaWxlIG9yIHN0ZGluXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZWFkZXIgPSBhd2FpdCAoYXdhaXQgUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbShiaWdudW1KU09OUGFyc2UoYXdhaXQganNvbi50b1N0cmluZygpKSkpLm9wZW4oKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyByZWFkZXIgPSBudWxsOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChyZWFkZXIgJiYgIXJlYWRlci5jbG9zZWQpID8gcmVhZGVyIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQmF0Y2hSb3dzVG9TdHJpbmcoc3RhdGU6IHsgY2xvc2VkOiBib29sZWFuLCBzY2hlbWE6IGFueSwgc2VwYXJhdG9yOiBzdHJpbmcsIGhhc1JlY29yZHM6IGJvb2xlYW4gfSkge1xuXG4gICAgbGV0IHJvd0lkID0gMCwgbWF4Q29sV2lkdGhzID0gWzE1XSwgc2VwYXJhdG9yID0gYCR7c3RhdGUuc2VwYXJhdG9yIHx8ICcgfCd9IGA7XG5cbiAgICByZXR1cm4gbmV3IHN0cmVhbS5UcmFuc2Zvcm0oeyB0cmFuc2Zvcm0sIGVuY29kaW5nOiAndXRmOCcsIHdyaXRhYmxlT2JqZWN0TW9kZTogdHJ1ZSwgcmVhZGFibGVPYmplY3RNb2RlOiBmYWxzZSB9KTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybSh0aGlzOiBzdHJlYW0uVHJhbnNmb3JtLCBiYXRjaDogUmVjb3JkQmF0Y2gsIF9lbmM6IHN0cmluZywgY2I6IChlcnJvcj86IEVycm9yLCBkYXRhPzogYW55KSA9PiB2b2lkKSB7XG4gICAgICAgIGJhdGNoID0gIShzdGF0ZS5zY2hlbWEgJiYgc3RhdGUuc2NoZW1hLmxlbmd0aCkgPyBiYXRjaCA6IGJhdGNoLnNlbGVjdCguLi5zdGF0ZS5zY2hlbWEpO1xuICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoIDw9IDAgfHwgYmF0Y2gubnVtQ29scyA8PSAwIHx8IHN0YXRlLmNsb3NlZCkge1xuICAgICAgICAgICAgc3RhdGUuaGFzUmVjb3JkcyB8fCAoc3RhdGUuaGFzUmVjb3JkcyA9IGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBjYih1bmRlZmluZWQsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaGFzUmVjb3JkcyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IFsncm93X2lkJywgLi4uYmF0Y2guc2NoZW1hLmZpZWxkcy5tYXAoKGYpID0+IGAke2Z9YCldLm1hcCh2YWx1ZVRvU3RyaW5nKTtcblxuICAgICAgICAvLyBQYXNzIG9uZSB0byBjb252ZXJ0IHRvIHN0cmluZ3MgYW5kIGNvdW50IG1heCBjb2x1bW4gd2lkdGhzXG4gICAgICAgIGNvbnN0IG5ld01heFdpZHRocyA9IG1lYXN1cmVDb2x1bW5XaWR0aHMocm93SWQsIGJhdGNoLCBoZWFkZXIubWFwKCh4LCBpKSA9PiBNYXRoLm1heChtYXhDb2xXaWR0aHNbaV0gfHwgMCwgeC5sZW5ndGgpKSk7XG5cbiAgICAgICAgLy8gSWYgYW55IG9mIHRoZSBjb2x1bW4gd2lkdGhzIGNoYW5nZWQsIHByaW50IHRoZSBoZWFkZXIgYWdhaW5cbiAgICAgICAgaWYgKChyb3dJZCAlIDM1MCkgJiYgSlNPTi5zdHJpbmdpZnkobmV3TWF4V2lkdGhzKSAhPT0gSlNPTi5zdHJpbmdpZnkobWF4Q29sV2lkdGhzKSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGBcXG4ke2Zvcm1hdFJvdyhoZWFkZXIsIG5ld01heFdpZHRocywgc2VwYXJhdG9yKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1heENvbFdpZHRocyA9IG5ld01heFdpZHRocztcblxuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmNsb3NlZCkgeyBicmVhazsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXJvdykgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgaWYgKCEocm93SWQgJSAzNTApKSB7IHRoaXMucHVzaChgXFxuJHtmb3JtYXRSb3coaGVhZGVyLCBtYXhDb2xXaWR0aHMsIHNlcGFyYXRvcil9YCk7IH1cbiAgICAgICAgICAgIHRoaXMucHVzaChmb3JtYXRSb3coW3Jvd0lkKyssIC4uLnJvd10ubWFwKHZhbHVlVG9TdHJpbmcpLCBtYXhDb2xXaWR0aHMsIHNlcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRSb3cocm93OiBzdHJpbmdbXSA9IFtdLCBtYXhDb2xXaWR0aHM6IG51bWJlcltdID0gW10sIHNlcGFyYXRvcjogc3RyaW5nID0gJyB8Jykge1xuICAgIHJldHVybiByb3cubWFwKCh4LCBqKSA9PiBwYWRMZWZ0KHgsIG1heENvbFdpZHRoc1tqXSkpLmpvaW4oc2VwYXJhdG9yKSArICdcXG4nO1xufVxuXG5mdW5jdGlvbiBtZWFzdXJlQ29sdW1uV2lkdGhzKHJvd0lkOiBudW1iZXIsIGJhdGNoOiBSZWNvcmRCYXRjaCwgbWF4Q29sV2lkdGhzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgZm9yIChjb25zdCByb3cgb2YgYmF0Y2gpIHtcbiAgICAgICAgaWYgKCFyb3cpIHsgY29udGludWU7IH1cbiAgICAgICAgbWF4Q29sV2lkdGhzWzBdID0gTWF0aC5tYXgobWF4Q29sV2lkdGhzWzBdIHx8IDAsIChgJHtyb3dJZCsrfWApLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IHZhbDogYW55LCBqID0gLTEsIGsgPSByb3cubGVuZ3RoOyArK2ogPCBrOykge1xuICAgICAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWwgPSByb3dbal0pICYmICh0eXBlb2YgdmFsW1N5bWJvbC50b1ByaW1pdGl2ZV0gIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgcHJpbnRpbmcgYSBjb2x1bW4gb2YgVHlwZWRBcnJheXMsIGVuc3VyZSB0aGUgY29sdW1uIGlzIHdpZGUgZW5vdWdoIHRvIGFjY29tbW9kYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHdpZGVzdCBwb3NzaWJsZSBlbGVtZW50IGZvciBhIGdpdmVuIGJ5dGUgc2l6ZSwgc2luY2UgSlMgb21pdHMgbGVhZGluZyB6ZXJvZXMuIEZvciBleGFtcGxlOlxuICAgICAgICAgICAgICAgIC8vIDEgfCAgWzExMzc3NDM2NDksMjE3MDU2NzQ4OCwyNDQ2OTYzOTEsMjEyMjU1NjQ3Nl1cbiAgICAgICAgICAgICAgICAvLyAyIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgLy8gMyB8ICAgWzYzNzE3NDAwNywyMTQyMjgxODgwLDk2MTczNjIzMCwyOTEyNDQ5MjgyXVxuICAgICAgICAgICAgICAgIC8vIDQgfCAgICBbMTAzNTExMjI2NSwyMTgzMjg4Niw0MTI4NDI2NzIsMjIwNzcxMDUxN11cbiAgICAgICAgICAgICAgICAvLyA1IHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgLy8gNiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIC8vIDcgfCAgICAgWzI3NTUxNDI5OTEsNDE5MjQyMzI1NiwyOTk0MzU5LDQ2Nzg3ODM3MF1cbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50V2lkdGggPSB0eXBlZEFycmF5RWxlbWVudFdpZHRocy5nZXQodmFsLmNvbnN0cnVjdG9yKSE7XG5cbiAgICAgICAgICAgICAgICBtYXhDb2xXaWR0aHNbaiArIDFdID0gTWF0aC5tYXgobWF4Q29sV2lkdGhzW2ogKyAxXSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAyICsgLy8gYnJhY2tldHMgb24gZWFjaCBlbmRcbiAgICAgICAgICAgICAgICAgICAgKHZhbC5sZW5ndGggLSAxKSArIC8vIGNvbW1hcyBiZXR3ZWVuIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICh2YWwubGVuZ3RoICogZWxlbWVudFdpZHRoKSAvLyB3aWR0aCBvZiBzdHJpbmdpZmllZCAyXk4tMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1heENvbFdpZHRoc1tqICsgMV0gPSBNYXRoLm1heChtYXhDb2xXaWR0aHNbaiArIDFdIHx8IDAsIHZhbHVlVG9TdHJpbmcodmFsKS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhDb2xXaWR0aHM7XG59XG5cbi8vIE1lYXN1cmUgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIDJeTi0xIGZvciBlYWNoIFR5cGVkQXJyYXkgdmFyaWFudFxuY29uc3QgdHlwZWRBcnJheUVsZW1lbnRXaWR0aHMgPSAoKCkgPT4ge1xuICAgIGNvbnN0IG1heEVsZW1lbnRXaWR0aCA9IChBcnJheVR5cGU6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBvY3RldHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBBcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQgLSAxIH0sIF8gPT4gMjU1KTtcbiAgICAgICAgcmV0dXJuIGAke25ldyBBcnJheVR5cGUobmV3IFVpbnQ4QXJyYXkoWy4uLm9jdGV0cywgMjU0XSkuYnVmZmVyKVswXX1gLmxlbmd0aDtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgTWFwPGFueSwgbnVtYmVyPihbXG4gICAgICAgIFtJbnQ4QXJyYXksIG1heEVsZW1lbnRXaWR0aChJbnQ4QXJyYXkpXSxcbiAgICAgICAgW0ludDE2QXJyYXksIG1heEVsZW1lbnRXaWR0aChJbnQxNkFycmF5KV0sXG4gICAgICAgIFtJbnQzMkFycmF5LCBtYXhFbGVtZW50V2lkdGgoSW50MzJBcnJheSldLFxuICAgICAgICBbVWludDhBcnJheSwgbWF4RWxlbWVudFdpZHRoKFVpbnQ4QXJyYXkpXSxcbiAgICAgICAgW1VpbnQxNkFycmF5LCBtYXhFbGVtZW50V2lkdGgoVWludDE2QXJyYXkpXSxcbiAgICAgICAgW1VpbnQzMkFycmF5LCBtYXhFbGVtZW50V2lkdGgoVWludDMyQXJyYXkpXSxcbiAgICAgICAgW0Zsb2F0MzJBcnJheSwgbWF4RWxlbWVudFdpZHRoKEZsb2F0MzJBcnJheSldLFxuICAgICAgICBbRmxvYXQ2NEFycmF5LCBtYXhFbGVtZW50V2lkdGgoRmxvYXQ2NEFycmF5KV0sXG4gICAgICAgIFtVaW50OENsYW1wZWRBcnJheSwgbWF4RWxlbWVudFdpZHRoKFVpbnQ4Q2xhbXBlZEFycmF5KV1cbiAgICBdKVxufSkoKTtcblxuZnVuY3Rpb24gY2xpT3B0cygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBuYW1lOiAnc2NoZW1hJywgYWxpYXM6ICdzJyxcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGVMYWJlbDogJ3t1bmRlcmxpbmUgY29sdW1uc30nLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdBIHNwYWNlLWRlbGltaXRlZCBsaXN0IG9mIGNvbHVtbiBuYW1lcydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgbmFtZTogJ2ZpbGUnLCBhbGlhczogJ2YnLFxuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgQXJyb3cgZmlsZSB0byByZWFkJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBuYW1lOiAnc2VwJywgb3B0aW9uYWw6IHRydWUsIGRlZmF1bHQ6ICd8JyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGNvbHVtbiBzZXBhcmF0b3IgY2hhcmFjdGVyJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgbmFtZTogJ2hlbHAnLCBvcHRpb25hbDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1ByaW50IHRoaXMgdXNhZ2UgZ3VpZGUuJ1xuICAgICAgICB9XG4gICAgXTsgICAgXG59XG5cbmZ1bmN0aW9uIHByaW50X3VzYWdlKCkge1xuICAgIGNvbnNvbGUubG9nKHJlcXVpcmUoJ2NvbW1hbmQtbGluZS11c2FnZScpKFtcbiAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyOiAnYXJyb3cyY3N2JyxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdQcmludCBhIENTViBmcm9tIGFuIEFycm93IGZpbGUnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogJ1N5bm9wc2lzJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICAnJCBhcnJvdzJjc3Yge3VuZGVybGluZSBmaWxlLmFycm93fSBbe2JvbGQgLS1zY2hlbWF9IGNvbHVtbl9uYW1lIC4uLl0nLFxuICAgICAgICAgICAgICAgICckIGFycm93MmNzdiBbe2JvbGQgLS1zY2hlbWF9IGNvbHVtbl9uYW1lIC4uLl0gW3tib2xkIC0tZmlsZX0ge3VuZGVybGluZSBmaWxlLmFycm93fV0nLFxuICAgICAgICAgICAgICAgICckIGFycm93MmNzdiB7Ym9sZCAtc30gY29sdW1uXzEge2JvbGQgLXN9IGNvbHVtbl8yIFt7Ym9sZCAtZn0ge3VuZGVybGluZSBmaWxlLmFycm93fV0nLFxuICAgICAgICAgICAgICAgICckIGFycm93MmNzdiBbe2JvbGQgLS1oZWxwfV0nXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogJ09wdGlvbnMnLFxuICAgICAgICAgICAgb3B0aW9uTGlzdDogY2xpT3B0cygpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0V4YW1wbGUnLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgICckIGFycm93MmNzdiAtLXNjaGVtYSBmb28gYmF6IC1mIHNpbXBsZS5hcnJvdyAtLXNlcCBcIixcIicsXG4gICAgICAgICAgICAgICAgJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcsXG4gICAgICAgICAgICAgICAgJz4gXCJyb3dfaWRcIiwgXCJmb286IEludDMyXCIsIFwiYmFyOiBGbG9hdDY0XCIsIFwiYmF6OiBVdGY4XCInLFxuICAgICAgICAgICAgICAgICc+ICAgICAgICAwLCAgICAgICAgICAgIDEsICAgICAgICAgICAgICAxLCAgICAgICAgXCJhYVwiJyxcbiAgICAgICAgICAgICAgICAnPiAgICAgICAgMSwgICAgICAgICBudWxsLCAgICAgICAgICAgbnVsbCwgICAgICAgIG51bGwnLFxuICAgICAgICAgICAgICAgICc+ICAgICAgICAyLCAgICAgICAgICAgIDMsICAgICAgICAgICBudWxsLCAgICAgICAgbnVsbCcsXG4gICAgICAgICAgICAgICAgJz4gICAgICAgIDMsICAgICAgICAgICAgNCwgICAgICAgICAgICAgIDQsICAgICAgIFwiYmJiXCInLFxuICAgICAgICAgICAgICAgICc+ICAgICAgICA0LCAgICAgICAgICAgIDUsICAgICAgICAgICAgICA1LCAgICAgIFwiY2NjY1wiJyxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIF0pKTtcbiAgICByZXR1cm4gMTtcbn1cbiJdfQ==
