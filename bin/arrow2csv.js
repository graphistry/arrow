#! /usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = require("fs");
const stream = require("stream");
const pretty_1 = require("../util/pretty");
const Arrow_node_1 = require("../Arrow.node");
const padLeft = require('pad-left');
const bignumJSONParse = require('json-bignum').parse;
const pipeline = require('util').promisify(stream.pipeline);
const argv = require(`command-line-args`)(cliOpts(), { partial: true });
const files = argv.help ? [] : [...(argv.file || []), ...(argv._unknown || [])].filter(Boolean);
const state = Object.assign({}, argv, { closed: false, hasRecords: false });
(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
    const sources = argv.help ? [] : [
        ...files.map((file) => () => fs.createReadStream(file)),
        ...(process.stdin.isTTY ? [] : [() => process.stdin])
    ].filter(Boolean);
    let reader;
    for (const source of sources) {
        if (state.closed) {
            break;
        }
        if (reader = yield createRecordBatchReader(source)) {
            yield pipeline(reader.toNodeStream(), recordBatchRowsToString(state), process.stdout).catch(() => state.closed = true);
        }
        if (state.closed) {
            break;
        }
    }
    return state.hasRecords ? 0 : print_usage();
}))()
    .then((x) => +x || 0, (err) => {
    if (err) {
        console.error(`${err && err.stack || err}`);
    }
    return process.exitCode || 1;
}).then((code) => process.exit(code));
function createRecordBatchReader(createSourceStream) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let json = new Arrow_node_1.AsyncByteQueue();
        let stream = new Arrow_node_1.AsyncByteQueue();
        let source = createSourceStream();
        let reader = null;
        // tee the input source, just in case it's JSON
        source.on('end', () => [stream, json].forEach((y) => y.close()))
            .on('data', (x) => [stream, json].forEach((y) => y.write(x)))
            .on('error', (e) => [stream, json].forEach((y) => y.abort(e)));
        try {
            reader = yield (yield Arrow_node_1.RecordBatchReader.from(stream)).open();
        }
        catch (e) {
            reader = null;
        }
        if (!reader || reader.closed) {
            reader = null;
            yield json.closed;
            if (source instanceof fs.ReadStream) {
                source.close();
            }
            // If the data in the `json` ByteQueue parses to JSON, then assume it's Arrow JSON from a file or stdin
            try {
                reader = yield (yield Arrow_node_1.RecordBatchReader.from(bignumJSONParse(yield json.toString()))).open();
            }
            catch (e) {
                reader = null;
            }
        }
        return (reader && !reader.closed) ? reader : null;
    });
}
function recordBatchRowsToString(state) {
    let rowId = 0, maxColWidths = [15], separator = `${state.separator || ' |'} `;
    return new stream.Transform({ transform, encoding: 'utf8', writableObjectMode: true, readableObjectMode: false });
    function transform(batch, _enc, cb) {
        batch = !(state.schema && state.schema.length) ? batch : batch.select(...state.schema);
        if (batch.length <= 0 || batch.numCols <= 0 || state.closed) {
            state.hasRecords || (state.hasRecords = false);
            return cb(undefined, null);
        }
        state.hasRecords = true;
        const header = ['row_id', ...batch.schema.fields.map((f) => `${f}`)].map(pretty_1.valueToString);
        // Pass one to convert to strings and count max column widths
        const newMaxWidths = measureColumnWidths(rowId, batch, header.map((x, i) => Math.max(maxColWidths[i] || 0, x.length)));
        // If any of the column widths changed, print the header again
        if ((rowId % 350) && JSON.stringify(newMaxWidths) !== JSON.stringify(maxColWidths)) {
            this.push(`\n${formatRow(header, newMaxWidths, separator)}`);
        }
        maxColWidths = newMaxWidths;
        for (const row of batch) {
            if (state.closed) {
                break;
            }
            else if (!row) {
                continue;
            }
            if (!(rowId % 350)) {
                this.push(`\n${formatRow(header, maxColWidths, separator)}`);
            }
            this.push(formatRow([rowId++, ...row].map(pretty_1.valueToString), maxColWidths, separator));
        }
        cb();
    }
}
function formatRow(row = [], maxColWidths = [], separator = ' |') {
    return row.map((x, j) => padLeft(x, maxColWidths[j])).join(separator) + '\n';
}
function measureColumnWidths(rowId, batch, maxColWidths = []) {
    for (const row of batch) {
        if (!row) {
            continue;
        }
        maxColWidths[0] = Math.max(maxColWidths[0] || 0, (`${rowId++}`).length);
        for (let val, j = -1, k = row.length; ++j < k;) {
            if (ArrayBuffer.isView(val = row[j]) && (typeof val[Symbol.toPrimitive] !== 'function')) {
                // If we're printing a column of TypedArrays, ensure the column is wide enough to accommodate
                // the widest possible element for a given byte size, since JS omits leading zeroes. For example:
                // 1 |  [1137743649,2170567488,244696391,2122556476]
                // 2 |                                          null
                // 3 |   [637174007,2142281880,961736230,2912449282]
                // 4 |    [1035112265,21832886,412842672,2207710517]
                // 5 |                                          null
                // 6 |                                          null
                // 7 |     [2755142991,4192423256,2994359,467878370]
                const elementWidth = typedArrayElementWidths.get(val.constructor);
                maxColWidths[j + 1] = Math.max(maxColWidths[j + 1] || 0, 2 + // brackets on each end
                    (val.length - 1) + // commas between elements
                    (val.length * elementWidth) // width of stringified 2^N-1
                );
            }
            else {
                maxColWidths[j + 1] = Math.max(maxColWidths[j + 1] || 0, pretty_1.valueToString(val).length);
            }
        }
    }
    return maxColWidths;
}
// Measure the stringified representation of 2^N-1 for each TypedArray variant
const typedArrayElementWidths = (() => {
    const maxElementWidth = (ArrayType) => {
        const octets = Array.from({ length: ArrayType.BYTES_PER_ELEMENT - 1 }, _ => 255);
        return `${new ArrayType(new Uint8Array([...octets, 254]).buffer)[0]}`.length;
    };
    return new Map([
        [Int8Array, maxElementWidth(Int8Array)],
        [Int16Array, maxElementWidth(Int16Array)],
        [Int32Array, maxElementWidth(Int32Array)],
        [Uint8Array, maxElementWidth(Uint8Array)],
        [Uint16Array, maxElementWidth(Uint16Array)],
        [Uint32Array, maxElementWidth(Uint32Array)],
        [Float32Array, maxElementWidth(Float32Array)],
        [Float64Array, maxElementWidth(Float64Array)],
        [Uint8ClampedArray, maxElementWidth(Uint8ClampedArray)]
    ]);
})();
function cliOpts() {
    return [
        {
            type: String,
            name: 'schema', alias: 's',
            optional: true, multiple: true,
            typeLabel: '{underline columns}',
            description: 'A space-delimited list of column names'
        },
        {
            type: String,
            name: 'file', alias: 'f',
            optional: true, multiple: true,
            description: 'The Arrow file to read'
        },
        {
            type: String,
            name: 'sep', optional: true, default: '|',
            description: 'The column separator character'
        },
        {
            type: Boolean,
            name: 'help', optional: true, default: false,
            description: 'Print this usage guide.'
        }
    ];
}
function print_usage() {
    console.log(require('command-line-usage')([
        {
            header: 'arrow2csv',
            content: 'Print a CSV from an Arrow file'
        },
        {
            header: 'Synopsis',
            content: [
                '$ arrow2csv {underline file.arrow} [{bold --schema} column_name ...]',
                '$ arrow2csv [{bold --schema} column_name ...] [{bold --file} {underline file.arrow}]',
                '$ arrow2csv {bold -s} column_1 {bold -s} column_2 [{bold -f} {underline file.arrow}]',
                '$ arrow2csv [{bold --help}]'
            ]
        },
        {
            header: 'Options',
            optionList: cliOpts()
        },
        {
            header: 'Example',
            content: [
                '$ arrow2csv --schema foo baz -f simple.arrow --sep ","',
                '                                                      ',
                '> "row_id", "foo: Int32", "bar: Float64", "baz: Utf8"',
                '>        0,            1,              1,        "aa"',
                '>        1,         null,           null,        null',
                '>        2,            3,           null,        null',
                '>        3,            4,              4,       "bbb"',
                '>        4,            5,              5,      "cccc"',
            ]
        }
    ]));
    return 1;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QXVEO2dCQUN2RCx1REFBdUQ7Z0JBQ3ZELHVEQUF1RDtnQkFDdkQsdURBQXVEO2dCQUN2RCx1REFBdUQ7YUFDMUQ7U0FDSjtLQUNKLENBQUMsQ0FBQyxDQUFDO0lBQ0osT0FBTyxDQUFDLENBQUM7QUFDYixDQUFDIiwiZmlsZSI6ImJpbi9hcnJvdzJjc3YuanMiLCJzb3VyY2VzQ29udGVudCI6WyIjISAvdXNyL2Jpbi9lbnYgbm9kZVxuXG4vLyBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyogdHNsaW50OmRpc2FibGUgKi9cblxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgc3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgeyB2YWx1ZVRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbC9wcmV0dHknO1xuaW1wb3J0IHsgUmVjb3JkQmF0Y2gsIFJlY29yZEJhdGNoUmVhZGVyLCBBc3luY0J5dGVRdWV1ZSB9IGZyb20gJy4uL0Fycm93Lm5vZGUnO1xuXG5jb25zdCBwYWRMZWZ0ID0gcmVxdWlyZSgncGFkLWxlZnQnKTtcbmNvbnN0IGJpZ251bUpTT05QYXJzZSA9IHJlcXVpcmUoJ2pzb24tYmlnbnVtJykucGFyc2U7XG5jb25zdCBwaXBlbGluZSA9IHJlcXVpcmUoJ3V0aWwnKS5wcm9taXNpZnkoc3RyZWFtLnBpcGVsaW5lKTtcbmNvbnN0IGFyZ3YgPSByZXF1aXJlKGBjb21tYW5kLWxpbmUtYXJnc2ApKGNsaU9wdHMoKSwgeyBwYXJ0aWFsOiB0cnVlIH0pO1xuY29uc3QgZmlsZXMgPSBhcmd2LmhlbHAgPyBbXSA6IFsuLi4oYXJndi5maWxlIHx8IFtdKSwgLi4uKGFyZ3YuX3Vua25vd24gfHwgW10pXS5maWx0ZXIoQm9vbGVhbik7XG5cbmNvbnN0IHN0YXRlID0geyAuLi5hcmd2LCBjbG9zZWQ6IGZhbHNlLCBoYXNSZWNvcmRzOiBmYWxzZSB9O1xuXG4oYXN5bmMgKCkgPT4ge1xuXG4gICAgY29uc3Qgc291cmNlcyA9IGFyZ3YuaGVscCA/IFtdIDogW1xuICAgICAgICAuLi5maWxlcy5tYXAoKGZpbGUpID0+ICgpID0+IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZSkpLFxuICAgICAgICAuLi4ocHJvY2Vzcy5zdGRpbi5pc1RUWSA/IFtdIDogWygpID0+IHByb2Nlc3Muc3RkaW5dKVxuICAgIF0uZmlsdGVyKEJvb2xlYW4pIGFzICgoKSA9PiBOb2RlSlMuUmVhZGFibGVTdHJlYW0pW107XG5cbiAgICBsZXQgcmVhZGVyOiBSZWNvcmRCYXRjaFJlYWRlciB8IG51bGw7XG5cbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jbG9zZWQpIHsgYnJlYWs7IH1cbiAgICAgICAgaWYgKHJlYWRlciA9IGF3YWl0IGNyZWF0ZVJlY29yZEJhdGNoUmVhZGVyKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGF3YWl0IHBpcGVsaW5lKFxuICAgICAgICAgICAgICAgIHJlYWRlci50b05vZGVTdHJlYW0oKSxcbiAgICAgICAgICAgICAgICByZWNvcmRCYXRjaFJvd3NUb1N0cmluZyhzdGF0ZSksXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXRcbiAgICAgICAgICAgICkuY2F0Y2goKCkgPT4gc3RhdGUuY2xvc2VkID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmNsb3NlZCkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5oYXNSZWNvcmRzID8gMCA6IHByaW50X3VzYWdlKCk7XG59KSgpXG4udGhlbigoeCkgPT4gK3ggfHwgMCwgKGVycikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIgJiYgZXJyLnN0YWNrIHx8IGVycn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MuZXhpdENvZGUgfHwgMTtcbn0pLnRoZW4oKGNvZGUpID0+IHByb2Nlc3MuZXhpdChjb2RlKSk7XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVJlY29yZEJhdGNoUmVhZGVyKGNyZWF0ZVNvdXJjZVN0cmVhbTogKCkgPT4gTm9kZUpTLlJlYWRhYmxlU3RyZWFtKSB7XG5cbiAgICBsZXQganNvbiA9IG5ldyBBc3luY0J5dGVRdWV1ZSgpO1xuICAgIGxldCBzdHJlYW0gPSBuZXcgQXN5bmNCeXRlUXVldWUoKTtcbiAgICBsZXQgc291cmNlID0gY3JlYXRlU291cmNlU3RyZWFtKCk7XG4gICAgbGV0IHJlYWRlcjogUmVjb3JkQmF0Y2hSZWFkZXIgfCBudWxsID0gbnVsbDtcbiAgICAvLyB0ZWUgdGhlIGlucHV0IHNvdXJjZSwganVzdCBpbiBjYXNlIGl0J3MgSlNPTlxuICAgIHNvdXJjZS5vbignZW5kJywgKCkgPT4gW3N0cmVhbSwganNvbl0uZm9yRWFjaCgoeSkgPT4geS5jbG9zZSgpKSlcbiAgICAgICAgLm9uKCdkYXRhJywgKHgpID0+IFtzdHJlYW0sIGpzb25dLmZvckVhY2goKHkpID0+IHkud3JpdGUoeCkpKVxuICAgICAgIC5vbignZXJyb3InLCAoZSkgPT4gW3N0cmVhbSwganNvbl0uZm9yRWFjaCgoeSkgPT4geS5hYm9ydChlKSkpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmVhZGVyID0gYXdhaXQgKGF3YWl0IFJlY29yZEJhdGNoUmVhZGVyLmZyb20oc3RyZWFtKSkub3BlbigpO1xuICAgIH0gY2F0Y2ggKGUpIHsgcmVhZGVyID0gbnVsbDsgfVxuXG4gICAgaWYgKCFyZWFkZXIgfHwgcmVhZGVyLmNsb3NlZCkge1xuICAgICAgICByZWFkZXIgPSBudWxsO1xuICAgICAgICBhd2FpdCBqc29uLmNsb3NlZDtcbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIGZzLlJlYWRTdHJlYW0pIHsgc291cmNlLmNsb3NlKCk7IH1cbiAgICAgICAgLy8gSWYgdGhlIGRhdGEgaW4gdGhlIGBqc29uYCBCeXRlUXVldWUgcGFyc2VzIHRvIEpTT04sIHRoZW4gYXNzdW1lIGl0J3MgQXJyb3cgSlNPTiBmcm9tIGEgZmlsZSBvciBzdGRpblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVhZGVyID0gYXdhaXQgKGF3YWl0IFJlY29yZEJhdGNoUmVhZGVyLmZyb20oYmlnbnVtSlNPTlBhcnNlKGF3YWl0IGpzb24udG9TdHJpbmcoKSkpKS5vcGVuKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgcmVhZGVyID0gbnVsbDsgfVxuICAgIH1cblxuICAgIHJldHVybiAocmVhZGVyICYmICFyZWFkZXIuY2xvc2VkKSA/IHJlYWRlciA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlY29yZEJhdGNoUm93c1RvU3RyaW5nKHN0YXRlOiB7IGNsb3NlZDogYm9vbGVhbiwgc2NoZW1hOiBhbnksIHNlcGFyYXRvcjogc3RyaW5nLCBoYXNSZWNvcmRzOiBib29sZWFuIH0pIHtcblxuICAgIGxldCByb3dJZCA9IDAsIG1heENvbFdpZHRocyA9IFsxNV0sIHNlcGFyYXRvciA9IGAke3N0YXRlLnNlcGFyYXRvciB8fCAnIHwnfSBgO1xuXG4gICAgcmV0dXJuIG5ldyBzdHJlYW0uVHJhbnNmb3JtKHsgdHJhbnNmb3JtLCBlbmNvZGluZzogJ3V0ZjgnLCB3cml0YWJsZU9iamVjdE1vZGU6IHRydWUsIHJlYWRhYmxlT2JqZWN0TW9kZTogZmFsc2UgfSk7XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0odGhpczogc3RyZWFtLlRyYW5zZm9ybSwgYmF0Y2g6IFJlY29yZEJhdGNoLCBfZW5jOiBzdHJpbmcsIGNiOiAoZXJyb3I/OiBFcnJvciwgZGF0YT86IGFueSkgPT4gdm9pZCkge1xuICAgICAgICBiYXRjaCA9ICEoc3RhdGUuc2NoZW1hICYmIHN0YXRlLnNjaGVtYS5sZW5ndGgpID8gYmF0Y2ggOiBiYXRjaC5zZWxlY3QoLi4uc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA8PSAwIHx8IGJhdGNoLm51bUNvbHMgPD0gMCB8fCBzdGF0ZS5jbG9zZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmhhc1JlY29yZHMgfHwgKHN0YXRlLmhhc1JlY29yZHMgPSBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gY2IodW5kZWZpbmVkLCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmhhc1JlY29yZHMgPSB0cnVlO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBbJ3Jvd19pZCcsIC4uLmJhdGNoLnNjaGVtYS5maWVsZHMubWFwKChmKSA9PiBgJHtmfWApXS5tYXAodmFsdWVUb1N0cmluZyk7XG5cbiAgICAgICAgLy8gUGFzcyBvbmUgdG8gY29udmVydCB0byBzdHJpbmdzIGFuZCBjb3VudCBtYXggY29sdW1uIHdpZHRoc1xuICAgICAgICBjb25zdCBuZXdNYXhXaWR0aHMgPSBtZWFzdXJlQ29sdW1uV2lkdGhzKHJvd0lkLCBiYXRjaCwgaGVhZGVyLm1hcCgoeCwgaSkgPT4gTWF0aC5tYXgobWF4Q29sV2lkdGhzW2ldIHx8IDAsIHgubGVuZ3RoKSkpO1xuXG4gICAgICAgIC8vIElmIGFueSBvZiB0aGUgY29sdW1uIHdpZHRocyBjaGFuZ2VkLCBwcmludCB0aGUgaGVhZGVyIGFnYWluXG4gICAgICAgIGlmICgocm93SWQgJSAzNTApICYmIEpTT04uc3RyaW5naWZ5KG5ld01heFdpZHRocykgIT09IEpTT04uc3RyaW5naWZ5KG1heENvbFdpZHRocykpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChgXFxuJHtmb3JtYXRSb3coaGVhZGVyLCBuZXdNYXhXaWR0aHMsIHNlcGFyYXRvcil9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXhDb2xXaWR0aHMgPSBuZXdNYXhXaWR0aHM7XG5cbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5jbG9zZWQpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFyb3cpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgIGlmICghKHJvd0lkICUgMzUwKSkgeyB0aGlzLnB1c2goYFxcbiR7Zm9ybWF0Um93KGhlYWRlciwgbWF4Q29sV2lkdGhzLCBzZXBhcmF0b3IpfWApOyB9XG4gICAgICAgICAgICB0aGlzLnB1c2goZm9ybWF0Um93KFtyb3dJZCsrLCAuLi5yb3ddLm1hcCh2YWx1ZVRvU3RyaW5nKSwgbWF4Q29sV2lkdGhzLCBzZXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0Um93KHJvdzogc3RyaW5nW10gPSBbXSwgbWF4Q29sV2lkdGhzOiBudW1iZXJbXSA9IFtdLCBzZXBhcmF0b3I6IHN0cmluZyA9ICcgfCcpIHtcbiAgICByZXR1cm4gcm93Lm1hcCgoeCwgaikgPT4gcGFkTGVmdCh4LCBtYXhDb2xXaWR0aHNbal0pKS5qb2luKHNlcGFyYXRvcikgKyAnXFxuJztcbn1cblxuZnVuY3Rpb24gbWVhc3VyZUNvbHVtbldpZHRocyhyb3dJZDogbnVtYmVyLCBiYXRjaDogUmVjb3JkQmF0Y2gsIG1heENvbFdpZHRoczogbnVtYmVyW10gPSBbXSkge1xuICAgIGZvciAoY29uc3Qgcm93IG9mIGJhdGNoKSB7XG4gICAgICAgIGlmICghcm93KSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIG1heENvbFdpZHRoc1swXSA9IE1hdGgubWF4KG1heENvbFdpZHRoc1swXSB8fCAwLCAoYCR7cm93SWQrK31gKS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCB2YWw6IGFueSwgaiA9IC0xLCBrID0gcm93Lmxlbmd0aDsgKytqIDwgazspIHtcbiAgICAgICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsID0gcm93W2pdKSAmJiAodHlwZW9mIHZhbFtTeW1ib2wudG9QcmltaXRpdmVdICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHByaW50aW5nIGEgY29sdW1uIG9mIFR5cGVkQXJyYXlzLCBlbnN1cmUgdGhlIGNvbHVtbiBpcyB3aWRlIGVub3VnaCB0byBhY2NvbW1vZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB3aWRlc3QgcG9zc2libGUgZWxlbWVudCBmb3IgYSBnaXZlbiBieXRlIHNpemUsIHNpbmNlIEpTIG9taXRzIGxlYWRpbmcgemVyb2VzLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgICAgICAgICAvLyAxIHwgIFsxMTM3NzQzNjQ5LDIxNzA1Njc0ODgsMjQ0Njk2MzkxLDIxMjI1NTY0NzZdXG4gICAgICAgICAgICAgICAgLy8gMiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIC8vIDMgfCAgIFs2MzcxNzQwMDcsMjE0MjI4MTg4MCw5NjE3MzYyMzAsMjkxMjQ0OTI4Ml1cbiAgICAgICAgICAgICAgICAvLyA0IHwgICAgWzEwMzUxMTIyNjUsMjE4MzI4ODYsNDEyODQyNjcyLDIyMDc3MTA1MTddXG4gICAgICAgICAgICAgICAgLy8gNSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIC8vIDYgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAvLyA3IHwgICAgIFsyNzU1MTQyOTkxLDQxOTI0MjMyNTYsMjk5NDM1OSw0Njc4NzgzNzBdXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudFdpZHRoID0gdHlwZWRBcnJheUVsZW1lbnRXaWR0aHMuZ2V0KHZhbC5jb25zdHJ1Y3RvcikhO1xuXG4gICAgICAgICAgICAgICAgbWF4Q29sV2lkdGhzW2ogKyAxXSA9IE1hdGgubWF4KG1heENvbFdpZHRoc1tqICsgMV0gfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgMiArIC8vIGJyYWNrZXRzIG9uIGVhY2ggZW5kXG4gICAgICAgICAgICAgICAgICAgICh2YWwubGVuZ3RoIC0gMSkgKyAvLyBjb21tYXMgYmV0d2VlbiBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAodmFsLmxlbmd0aCAqIGVsZW1lbnRXaWR0aCkgLy8gd2lkdGggb2Ygc3RyaW5naWZpZWQgMl5OLTFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXhDb2xXaWR0aHNbaiArIDFdID0gTWF0aC5tYXgobWF4Q29sV2lkdGhzW2ogKyAxXSB8fCAwLCB2YWx1ZVRvU3RyaW5nKHZhbCkubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4Q29sV2lkdGhzO1xufVxuXG4vLyBNZWFzdXJlIHRoZSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiAyXk4tMSBmb3IgZWFjaCBUeXBlZEFycmF5IHZhcmlhbnRcbmNvbnN0IHR5cGVkQXJyYXlFbGVtZW50V2lkdGhzID0gKCgpID0+IHtcbiAgICBjb25zdCBtYXhFbGVtZW50V2lkdGggPSAoQXJyYXlUeXBlOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3Qgb2N0ZXRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogQXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UIC0gMSB9LCBfID0+IDI1NSk7XG4gICAgICAgIHJldHVybiBgJHtuZXcgQXJyYXlUeXBlKG5ldyBVaW50OEFycmF5KFsuLi5vY3RldHMsIDI1NF0pLmJ1ZmZlcilbMF19YC5sZW5ndGg7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IE1hcDxhbnksIG51bWJlcj4oW1xuICAgICAgICBbSW50OEFycmF5LCBtYXhFbGVtZW50V2lkdGgoSW50OEFycmF5KV0sXG4gICAgICAgIFtJbnQxNkFycmF5LCBtYXhFbGVtZW50V2lkdGgoSW50MTZBcnJheSldLFxuICAgICAgICBbSW50MzJBcnJheSwgbWF4RWxlbWVudFdpZHRoKEludDMyQXJyYXkpXSxcbiAgICAgICAgW1VpbnQ4QXJyYXksIG1heEVsZW1lbnRXaWR0aChVaW50OEFycmF5KV0sXG4gICAgICAgIFtVaW50MTZBcnJheSwgbWF4RWxlbWVudFdpZHRoKFVpbnQxNkFycmF5KV0sXG4gICAgICAgIFtVaW50MzJBcnJheSwgbWF4RWxlbWVudFdpZHRoKFVpbnQzMkFycmF5KV0sXG4gICAgICAgIFtGbG9hdDMyQXJyYXksIG1heEVsZW1lbnRXaWR0aChGbG9hdDMyQXJyYXkpXSxcbiAgICAgICAgW0Zsb2F0NjRBcnJheSwgbWF4RWxlbWVudFdpZHRoKEZsb2F0NjRBcnJheSldLFxuICAgICAgICBbVWludDhDbGFtcGVkQXJyYXksIG1heEVsZW1lbnRXaWR0aChVaW50OENsYW1wZWRBcnJheSldXG4gICAgXSlcbn0pKCk7XG5cbmZ1bmN0aW9uIGNsaU9wdHMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgbmFtZTogJ3NjaGVtYScsIGFsaWFzOiAncycsXG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSwgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICB0eXBlTGFiZWw6ICd7dW5kZXJsaW5lIGNvbHVtbnN9JyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBzcGFjZS1kZWxpbWl0ZWQgbGlzdCBvZiBjb2x1bW4gbmFtZXMnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIG5hbWU6ICdmaWxlJywgYWxpYXM6ICdmJyxcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIEFycm93IGZpbGUgdG8gcmVhZCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgbmFtZTogJ3NlcCcsIG9wdGlvbmFsOiB0cnVlLCBkZWZhdWx0OiAnfCcsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBjb2x1bW4gc2VwYXJhdG9yIGNoYXJhY3RlcidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIG5hbWU6ICdoZWxwJywgb3B0aW9uYWw6IHRydWUsIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdQcmludCB0aGlzIHVzYWdlIGd1aWRlLidcbiAgICAgICAgfVxuICAgIF07ICAgIFxufVxuXG5mdW5jdGlvbiBwcmludF91c2FnZSgpIHtcbiAgICBjb25zb2xlLmxvZyhyZXF1aXJlKCdjb21tYW5kLWxpbmUtdXNhZ2UnKShbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogJ2Fycm93MmNzdicsXG4gICAgICAgICAgICBjb250ZW50OiAnUHJpbnQgYSBDU1YgZnJvbSBhbiBBcnJvdyBmaWxlJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXI6ICdTeW5vcHNpcycsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgJyQgYXJyb3cyY3N2IHt1bmRlcmxpbmUgZmlsZS5hcnJvd30gW3tib2xkIC0tc2NoZW1hfSBjb2x1bW5fbmFtZSAuLi5dJyxcbiAgICAgICAgICAgICAgICAnJCBhcnJvdzJjc3YgW3tib2xkIC0tc2NoZW1hfSBjb2x1bW5fbmFtZSAuLi5dIFt7Ym9sZCAtLWZpbGV9IHt1bmRlcmxpbmUgZmlsZS5hcnJvd31dJyxcbiAgICAgICAgICAgICAgICAnJCBhcnJvdzJjc3Yge2JvbGQgLXN9IGNvbHVtbl8xIHtib2xkIC1zfSBjb2x1bW5fMiBbe2JvbGQgLWZ9IHt1bmRlcmxpbmUgZmlsZS5hcnJvd31dJyxcbiAgICAgICAgICAgICAgICAnJCBhcnJvdzJjc3YgW3tib2xkIC0taGVscH1dJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXI6ICdPcHRpb25zJyxcbiAgICAgICAgICAgIG9wdGlvbkxpc3Q6IGNsaU9wdHMoKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXI6ICdFeGFtcGxlJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICAnJCBhcnJvdzJjc3YgLS1zY2hlbWEgZm9vIGJheiAtZiBzaW1wbGUuYXJyb3cgLS1zZXAgXCIsXCInLFxuICAgICAgICAgICAgICAgICcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLFxuICAgICAgICAgICAgICAgICc+IFwicm93X2lkXCIsIFwiZm9vOiBJbnQzMlwiLCBcImJhcjogRmxvYXQ2NFwiLCBcImJhejogVXRmOFwiJyxcbiAgICAgICAgICAgICAgICAnPiAgICAgICAgMCwgICAgICAgICAgICAxLCAgICAgICAgICAgICAgMSwgICAgICAgIFwiYWFcIicsXG4gICAgICAgICAgICAgICAgJz4gICAgICAgIDEsICAgICAgICAgbnVsbCwgICAgICAgICAgIG51bGwsICAgICAgICBudWxsJyxcbiAgICAgICAgICAgICAgICAnPiAgICAgICAgMiwgICAgICAgICAgICAzLCAgICAgICAgICAgbnVsbCwgICAgICAgIG51bGwnLFxuICAgICAgICAgICAgICAgICc+ICAgICAgICAzLCAgICAgICAgICAgIDQsICAgICAgICAgICAgICA0LCAgICAgICBcImJiYlwiJyxcbiAgICAgICAgICAgICAgICAnPiAgICAgICAgNCwgICAgICAgICAgICA1LCAgICAgICAgICAgICAgNSwgICAgICBcImNjY2NcIicsXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICBdKSk7XG4gICAgcmV0dXJuIDE7XG59XG4iXX0=
