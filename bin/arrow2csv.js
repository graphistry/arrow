#! /usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const stream = require("stream");
const pretty_1 = require("../util/pretty");
const Arrow_node_1 = require("../Arrow.node");
const padLeft = require('pad-left');
const bignumJSONParse = require('json-bignum').parse;
const pipeline = require('util').promisify(stream.pipeline);
const argv = require(`command-line-args`)(cliOpts(), { partial: true });
const files = argv.help ? [] : [...(argv.file || []), ...(argv._unknown || [])].filter(Boolean);
const state = { ...argv, closed: false, hasRecords: false };
(async () => {
    const sources = argv.help ? [] : [
        ...files.map((file) => () => fs.createReadStream(file)),
        ...(process.stdin.isTTY ? [] : [() => process.stdin])
    ].filter(Boolean);
    let reader;
    for (const source of sources) {
        if (state.closed) {
            break;
        }
        for await (reader of recordBatchReaders(source)) {
            const source = reader.toNodeStream();
            const xform = batchesToString(state);
            const sink = new stream.PassThrough();
            sink.pipe(process.stdout, { end: false });
            await pipeline(source, xform, sink).catch(() => state.closed = true);
        }
        if (state.closed) {
            break;
        }
    }
    return state.hasRecords ? 0 : print_usage();
})()
    .then((x) => +x || 0, (err) => {
    if (err) {
        console.error(`${err && err.stack || err}`);
    }
    return process.exitCode || 1;
}).then((code) => process.exit(code));
async function* recordBatchReaders(createSourceStream) {
    let json = new Arrow_node_1.AsyncByteQueue();
    let stream = new Arrow_node_1.AsyncByteQueue();
    let source = createSourceStream();
    let reader = null;
    let readers = null;
    // tee the input source, just in case it's JSON
    source.on('end', () => [stream, json].forEach((y) => y.close()))
        .on('data', (x) => [stream, json].forEach((y) => y.write(x)))
        .on('error', (e) => [stream, json].forEach((y) => y.abort(e)));
    try {
        for await (reader of Arrow_node_1.RecordBatchReader.readAll(stream)) {
            reader && (yield reader);
        }
        if (reader)
            return;
    }
    catch (e) {
        readers = null;
    }
    if (!readers) {
        await json.closed;
        if (source instanceof fs.ReadStream) {
            source.close();
        }
        // If the data in the `json` ByteQueue parses to JSON, then assume it's Arrow JSON from a file or stdin
        try {
            for await (reader of Arrow_node_1.RecordBatchReader.readAll(bignumJSONParse(await json.toString()))) {
                reader && (yield reader);
            }
        }
        catch (e) {
            readers = null;
        }
    }
}
function batchesToString(state) {
    let rowId = 0, maxColWidths = [15], separator = `${state.separator || ' |'} `;
    return new stream.Transform({ transform, encoding: 'utf8', writableObjectMode: true, readableObjectMode: false });
    function transform(batch, _enc, cb) {
        batch = !(state.schema && state.schema.length) ? batch : batch.select(...state.schema);
        if (batch.length <= 0 || batch.numCols <= 0 || state.closed) {
            state.hasRecords || (state.hasRecords = false);
            return cb(undefined, null);
        }
        state.hasRecords = true;
        const header = ['row_id', ...batch.schema.fields.map((f) => `${f}`)].map(pretty_1.valueToString);
        // Pass one to convert to strings and count max column widths
        const newMaxWidths = measureColumnWidths(rowId, batch, header.map((x, i) => Math.max(maxColWidths[i] || 0, x.length)));
        // If any of the column widths changed, print the header again
        if ((rowId % 350) && JSON.stringify(newMaxWidths) !== JSON.stringify(maxColWidths)) {
            this.push(`\n${formatRow(header, newMaxWidths, separator)}`);
        }
        maxColWidths = newMaxWidths;
        for (const row of batch) {
            if (state.closed) {
                break;
            }
            else if (!row) {
                continue;
            }
            if (!(rowId % 350)) {
                this.push(`\n${formatRow(header, maxColWidths, separator)}`);
            }
            this.push(formatRow([rowId++, ...row].map(pretty_1.valueToString), maxColWidths, separator));
        }
        cb();
    }
}
function formatRow(row = [], maxColWidths = [], separator = ' |') {
    return row.map((x, j) => padLeft(x, maxColWidths[j])).join(separator) + '\n';
}
function measureColumnWidths(rowId, batch, maxColWidths = []) {
    let val, j = 0;
    for (const row of batch) {
        if (!row) {
            continue;
        }
        maxColWidths[j = 0] = Math.max(maxColWidths[0] || 0, (`${rowId++}`).length);
        for (val of row) {
            if (val && typedArrayElementWidths.has(val.constructor) && (typeof val[Symbol.toPrimitive] !== 'function')) {
                // If we're printing a column of TypedArrays, ensure the column is wide enough to accommodate
                // the widest possible element for a given byte size, since JS omits leading zeroes. For example:
                // 1 |  [1137743649,2170567488,244696391,2122556476]
                // 2 |                                          null
                // 3 |   [637174007,2142281880,961736230,2912449282]
                // 4 |    [1035112265,21832886,412842672,2207710517]
                // 5 |                                          null
                // 6 |                                          null
                // 7 |     [2755142991,4192423256,2994359,467878370]
                const elementWidth = typedArrayElementWidths.get(val.constructor);
                maxColWidths[j + 1] = Math.max(maxColWidths[j + 1] || 0, 2 + // brackets on each end
                    (val.length - 1) + // commas between elements
                    (val.length * elementWidth) // width of stringified 2^N-1
                );
            }
            else {
                maxColWidths[j + 1] = Math.max(maxColWidths[j + 1] || 0, pretty_1.valueToString(val).length);
            }
            ++j;
        }
    }
    return maxColWidths;
}
// Measure the stringified representation of 2^N-1 for each TypedArray variant
const typedArrayElementWidths = (() => {
    const maxElementWidth = (ArrayType) => {
        const octets = Array.from({ length: ArrayType.BYTES_PER_ELEMENT - 1 }, _ => 255);
        return `${new ArrayType(new Uint8Array([...octets, 254]).buffer)[0]}`.length;
    };
    return new Map([
        [Int8Array, maxElementWidth(Int8Array)],
        [Int16Array, maxElementWidth(Int16Array)],
        [Int32Array, maxElementWidth(Int32Array)],
        [Uint8Array, maxElementWidth(Uint8Array)],
        [Uint16Array, maxElementWidth(Uint16Array)],
        [Uint32Array, maxElementWidth(Uint32Array)],
        [Float32Array, maxElementWidth(Float32Array)],
        [Float64Array, maxElementWidth(Float64Array)],
        [Uint8ClampedArray, maxElementWidth(Uint8ClampedArray)]
    ]);
})();
function cliOpts() {
    return [
        {
            type: String,
            name: 'schema', alias: 's',
            optional: true, multiple: true,
            typeLabel: '{underline columns}',
            description: 'A space-delimited list of column names'
        },
        {
            type: String,
            name: 'file', alias: 'f',
            optional: true, multiple: true,
            description: 'The Arrow file to read'
        },
        {
            type: String,
            name: 'sep', optional: true, default: '|',
            description: 'The column separator character'
        },
        {
            type: Boolean,
            name: 'help', optional: true, default: false,
            description: 'Print this usage guide.'
        }
    ];
}
function print_usage() {
    console.log(require('command-line-usage')([
        {
            header: 'arrow2csv',
            content: 'Print a CSV from an Arrow file'
        },
        {
            header: 'Synopsis',
            content: [
                '$ arrow2csv {underline file.arrow} [{bold --schema} column_name ...]',
                '$ arrow2csv [{bold --schema} column_name ...] [{bold --file} {underline file.arrow}]',
                '$ arrow2csv {bold -s} column_1 {bold -s} column_2 [{bold -f} {underline file.arrow}]',
                '$ arrow2csv [{bold --help}]'
            ]
        },
        {
            header: 'Options',
            optionList: cliOpts()
        },
        {
            header: 'Example',
            content: [
                '$ arrow2csv --schema foo baz -f simple.arrow --sep ","',
                '                                                      ',
                '> "row_id", "foo: Int32", "bar: Float64", "baz: Utf8"',
                '>        0,            1,              1,        "aa"',
                '>        1,         null,           null,        null',
                '>        2,            3,           null,        null',
                '>        3,            4,              4,       "bbb"',
                '>        4,            5,              5,      "cccc"',
            ]
        }
    ]));
    return 1;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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aEM7U0FDSjtRQUNEO1lBQ0ksTUFBTSxFQUFFLFNBQVM7WUFDakIsVUFBVSxFQUFFLE9BQU8sRUFBRTtTQUN4QjtRQUNEO1lBQ0ksTUFBTSxFQUFFLFNBQVM7WUFDakIsT0FBTyxFQUFFO2dCQUNMLHdEQUF3RDtnQkFDeEQsd0RBQXdEO2dCQUN4RCx1REFBdUQ7Z0JBQ3ZELHVEQUF1RDtnQkFDdkQsdURBQXVEO2dCQUN2RCx1REFBdUQ7Z0JBQ3ZELHVEQUF1RDtnQkFDdkQsdURBQXVEO2FBQzFEO1NBQ0o7S0FDSixDQUFDLENBQUMsQ0FBQztJQUNKLE9BQU8sQ0FBQyxDQUFDO0FBQ2IsQ0FBQyIsImZpbGUiOiJiaW4vYXJyb3cyY3N2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIyEgL3Vzci9iaW4vZW52IG5vZGVcblxuLy8gTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qIHRzbGludDpkaXNhYmxlICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHsgdmFsdWVUb1N0cmluZyB9IGZyb20gJy4uL3V0aWwvcHJldHR5JztcbmltcG9ydCB7IFJlY29yZEJhdGNoLCBSZWNvcmRCYXRjaFJlYWRlciwgQXN5bmNCeXRlUXVldWUgfSBmcm9tICcuLi9BcnJvdy5ub2RlJztcblxuY29uc3QgcGFkTGVmdCA9IHJlcXVpcmUoJ3BhZC1sZWZ0Jyk7XG5jb25zdCBiaWdudW1KU09OUGFyc2UgPSByZXF1aXJlKCdqc29uLWJpZ251bScpLnBhcnNlO1xuY29uc3QgcGlwZWxpbmUgPSByZXF1aXJlKCd1dGlsJykucHJvbWlzaWZ5KHN0cmVhbS5waXBlbGluZSk7XG5jb25zdCBhcmd2ID0gcmVxdWlyZShgY29tbWFuZC1saW5lLWFyZ3NgKShjbGlPcHRzKCksIHsgcGFydGlhbDogdHJ1ZSB9KTtcbmNvbnN0IGZpbGVzID0gYXJndi5oZWxwID8gW10gOiBbLi4uKGFyZ3YuZmlsZSB8fCBbXSksIC4uLihhcmd2Ll91bmtub3duIHx8IFtdKV0uZmlsdGVyKEJvb2xlYW4pO1xuXG5jb25zdCBzdGF0ZSA9IHsgLi4uYXJndiwgY2xvc2VkOiBmYWxzZSwgaGFzUmVjb3JkczogZmFsc2UgfTtcblxuKGFzeW5jICgpID0+IHtcblxuICAgIGNvbnN0IHNvdXJjZXMgPSBhcmd2LmhlbHAgPyBbXSA6IFtcbiAgICAgICAgLi4uZmlsZXMubWFwKChmaWxlKSA9PiAoKSA9PiBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGUpKSxcbiAgICAgICAgLi4uKHByb2Nlc3Muc3RkaW4uaXNUVFkgPyBbXSA6IFsoKSA9PiBwcm9jZXNzLnN0ZGluXSlcbiAgICBdLmZpbHRlcihCb29sZWFuKSBhcyAoKCkgPT4gTm9kZUpTLlJlYWRhYmxlU3RyZWFtKVtdO1xuXG4gICAgbGV0IHJlYWRlcjogUmVjb3JkQmF0Y2hSZWFkZXIgfCBudWxsO1xuXG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICBpZiAoc3RhdGUuY2xvc2VkKSB7IGJyZWFrOyB9XG4gICAgICAgIGZvciBhd2FpdCAocmVhZGVyIG9mIHJlY29yZEJhdGNoUmVhZGVycyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSByZWFkZXIudG9Ob2RlU3RyZWFtKCk7XG4gICAgICAgICAgICBjb25zdCB4Zm9ybSA9IGJhdGNoZXNUb1N0cmluZyhzdGF0ZSk7XG4gICAgICAgICAgICBjb25zdCBzaW5rID0gbmV3IHN0cmVhbS5QYXNzVGhyb3VnaCgpO1xuICAgICAgICAgICAgc2luay5waXBlKHByb2Nlc3Muc3Rkb3V0LCB7IGVuZDogZmFsc2UgfSk7XG4gICAgICAgICAgICBhd2FpdCBwaXBlbGluZShzb3VyY2UsIHhmb3JtLCBzaW5rKS5jYXRjaCgoKSA9PiBzdGF0ZS5jbG9zZWQgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuY2xvc2VkKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlLmhhc1JlY29yZHMgPyAwIDogcHJpbnRfdXNhZ2UoKTtcbn0pKClcbi50aGVuKCh4KSA9PiAreCB8fCAwLCAoZXJyKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAke2VyciAmJiBlcnIuc3RhY2sgfHwgZXJyfWApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5leGl0Q29kZSB8fCAxO1xufSkudGhlbigoY29kZSkgPT4gcHJvY2Vzcy5leGl0KGNvZGUpKTtcblxuYXN5bmMgZnVuY3Rpb24gKnJlY29yZEJhdGNoUmVhZGVycyhjcmVhdGVTb3VyY2VTdHJlYW06ICgpID0+IE5vZGVKUy5SZWFkYWJsZVN0cmVhbSkge1xuXG4gICAgbGV0IGpzb24gPSBuZXcgQXN5bmNCeXRlUXVldWUoKTtcbiAgICBsZXQgc3RyZWFtID0gbmV3IEFzeW5jQnl0ZVF1ZXVlKCk7XG4gICAgbGV0IHNvdXJjZSA9IGNyZWF0ZVNvdXJjZVN0cmVhbSgpO1xuICAgIGxldCByZWFkZXI6IFJlY29yZEJhdGNoUmVhZGVyIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHJlYWRlcnM6IEFzeW5jSXRlcmFibGU8UmVjb3JkQmF0Y2hSZWFkZXI+IHwgbnVsbCA9IG51bGw7XG4gICAgLy8gdGVlIHRoZSBpbnB1dCBzb3VyY2UsIGp1c3QgaW4gY2FzZSBpdCdzIEpTT05cbiAgICBzb3VyY2Uub24oJ2VuZCcsICgpID0+IFtzdHJlYW0sIGpzb25dLmZvckVhY2goKHkpID0+IHkuY2xvc2UoKSkpXG4gICAgICAgIC5vbignZGF0YScsICh4KSA9PiBbc3RyZWFtLCBqc29uXS5mb3JFYWNoKCh5KSA9PiB5LndyaXRlKHgpKSlcbiAgICAgICAub24oJ2Vycm9yJywgKGUpID0+IFtzdHJlYW0sIGpzb25dLmZvckVhY2goKHkpID0+IHkuYWJvcnQoZSkpKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAocmVhZGVyIG9mIFJlY29yZEJhdGNoUmVhZGVyLnJlYWRBbGwoc3RyZWFtKSkge1xuICAgICAgICAgICAgcmVhZGVyICYmICh5aWVsZCByZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkZXIpIHJldHVybjtcbiAgICB9IGNhdGNoIChlKSB7IHJlYWRlcnMgPSBudWxsOyB9XG5cbiAgICBpZiAoIXJlYWRlcnMpIHtcbiAgICAgICAgYXdhaXQganNvbi5jbG9zZWQ7XG4gICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBmcy5SZWFkU3RyZWFtKSB7IHNvdXJjZS5jbG9zZSgpOyB9XG4gICAgICAgIC8vIElmIHRoZSBkYXRhIGluIHRoZSBganNvbmAgQnl0ZVF1ZXVlIHBhcnNlcyB0byBKU09OLCB0aGVuIGFzc3VtZSBpdCdzIEFycm93IEpTT04gZnJvbSBhIGZpbGUgb3Igc3RkaW5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAocmVhZGVyIG9mIFJlY29yZEJhdGNoUmVhZGVyLnJlYWRBbGwoYmlnbnVtSlNPTlBhcnNlKGF3YWl0IGpzb24udG9TdHJpbmcoKSkpKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyICYmICh5aWVsZCByZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7IHJlYWRlcnMgPSBudWxsOyB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiYXRjaGVzVG9TdHJpbmcoc3RhdGU6IHsgY2xvc2VkOiBib29sZWFuLCBzY2hlbWE6IGFueSwgc2VwYXJhdG9yOiBzdHJpbmcsIGhhc1JlY29yZHM6IGJvb2xlYW4gfSkge1xuXG4gICAgbGV0IHJvd0lkID0gMCwgbWF4Q29sV2lkdGhzID0gWzE1XSwgc2VwYXJhdG9yID0gYCR7c3RhdGUuc2VwYXJhdG9yIHx8ICcgfCd9IGA7XG5cbiAgICByZXR1cm4gbmV3IHN0cmVhbS5UcmFuc2Zvcm0oeyB0cmFuc2Zvcm0sIGVuY29kaW5nOiAndXRmOCcsIHdyaXRhYmxlT2JqZWN0TW9kZTogdHJ1ZSwgcmVhZGFibGVPYmplY3RNb2RlOiBmYWxzZSB9KTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybSh0aGlzOiBzdHJlYW0uVHJhbnNmb3JtLCBiYXRjaDogUmVjb3JkQmF0Y2gsIF9lbmM6IHN0cmluZywgY2I6IChlcnJvcj86IEVycm9yLCBkYXRhPzogYW55KSA9PiB2b2lkKSB7XG4gICAgICAgIGJhdGNoID0gIShzdGF0ZS5zY2hlbWEgJiYgc3RhdGUuc2NoZW1hLmxlbmd0aCkgPyBiYXRjaCA6IGJhdGNoLnNlbGVjdCguLi5zdGF0ZS5zY2hlbWEpO1xuICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoIDw9IDAgfHwgYmF0Y2gubnVtQ29scyA8PSAwIHx8IHN0YXRlLmNsb3NlZCkge1xuICAgICAgICAgICAgc3RhdGUuaGFzUmVjb3JkcyB8fCAoc3RhdGUuaGFzUmVjb3JkcyA9IGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBjYih1bmRlZmluZWQsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaGFzUmVjb3JkcyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IFsncm93X2lkJywgLi4uYmF0Y2guc2NoZW1hLmZpZWxkcy5tYXAoKGYpID0+IGAke2Z9YCldLm1hcCh2YWx1ZVRvU3RyaW5nKTtcblxuICAgICAgICAvLyBQYXNzIG9uZSB0byBjb252ZXJ0IHRvIHN0cmluZ3MgYW5kIGNvdW50IG1heCBjb2x1bW4gd2lkdGhzXG4gICAgICAgIGNvbnN0IG5ld01heFdpZHRocyA9IG1lYXN1cmVDb2x1bW5XaWR0aHMocm93SWQsIGJhdGNoLCBoZWFkZXIubWFwKCh4LCBpKSA9PiBNYXRoLm1heChtYXhDb2xXaWR0aHNbaV0gfHwgMCwgeC5sZW5ndGgpKSk7XG5cbiAgICAgICAgLy8gSWYgYW55IG9mIHRoZSBjb2x1bW4gd2lkdGhzIGNoYW5nZWQsIHByaW50IHRoZSBoZWFkZXIgYWdhaW5cbiAgICAgICAgaWYgKChyb3dJZCAlIDM1MCkgJiYgSlNPTi5zdHJpbmdpZnkobmV3TWF4V2lkdGhzKSAhPT0gSlNPTi5zdHJpbmdpZnkobWF4Q29sV2lkdGhzKSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGBcXG4ke2Zvcm1hdFJvdyhoZWFkZXIsIG5ld01heFdpZHRocywgc2VwYXJhdG9yKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1heENvbFdpZHRocyA9IG5ld01heFdpZHRocztcblxuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmNsb3NlZCkgeyBicmVhazsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXJvdykgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgaWYgKCEocm93SWQgJSAzNTApKSB7IHRoaXMucHVzaChgXFxuJHtmb3JtYXRSb3coaGVhZGVyLCBtYXhDb2xXaWR0aHMsIHNlcGFyYXRvcil9YCk7IH1cbiAgICAgICAgICAgIHRoaXMucHVzaChmb3JtYXRSb3coW3Jvd0lkKyssIC4uLnJvd10ubWFwKHZhbHVlVG9TdHJpbmcpLCBtYXhDb2xXaWR0aHMsIHNlcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRSb3cocm93OiBzdHJpbmdbXSA9IFtdLCBtYXhDb2xXaWR0aHM6IG51bWJlcltdID0gW10sIHNlcGFyYXRvcjogc3RyaW5nID0gJyB8Jykge1xuICAgIHJldHVybiByb3cubWFwKCh4LCBqKSA9PiBwYWRMZWZ0KHgsIG1heENvbFdpZHRoc1tqXSkpLmpvaW4oc2VwYXJhdG9yKSArICdcXG4nO1xufVxuXG5mdW5jdGlvbiBtZWFzdXJlQ29sdW1uV2lkdGhzKHJvd0lkOiBudW1iZXIsIGJhdGNoOiBSZWNvcmRCYXRjaCwgbWF4Q29sV2lkdGhzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgbGV0IHZhbDogYW55LCBqID0gMDtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xuICAgICAgICBpZiAoIXJvdykgeyBjb250aW51ZTsgfVxuICAgICAgICBtYXhDb2xXaWR0aHNbaiA9IDBdID0gTWF0aC5tYXgobWF4Q29sV2lkdGhzWzBdIHx8IDAsIChgJHtyb3dJZCsrfWApLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFsIG9mIHJvdykge1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB0eXBlZEFycmF5RWxlbWVudFdpZHRocy5oYXModmFsLmNvbnN0cnVjdG9yKSAmJiAodHlwZW9mIHZhbFtTeW1ib2wudG9QcmltaXRpdmVdICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHByaW50aW5nIGEgY29sdW1uIG9mIFR5cGVkQXJyYXlzLCBlbnN1cmUgdGhlIGNvbHVtbiBpcyB3aWRlIGVub3VnaCB0byBhY2NvbW1vZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB3aWRlc3QgcG9zc2libGUgZWxlbWVudCBmb3IgYSBnaXZlbiBieXRlIHNpemUsIHNpbmNlIEpTIG9taXRzIGxlYWRpbmcgemVyb2VzLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgICAgICAgICAvLyAxIHwgIFsxMTM3NzQzNjQ5LDIxNzA1Njc0ODgsMjQ0Njk2MzkxLDIxMjI1NTY0NzZdXG4gICAgICAgICAgICAgICAgLy8gMiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIC8vIDMgfCAgIFs2MzcxNzQwMDcsMjE0MjI4MTg4MCw5NjE3MzYyMzAsMjkxMjQ0OTI4Ml1cbiAgICAgICAgICAgICAgICAvLyA0IHwgICAgWzEwMzUxMTIyNjUsMjE4MzI4ODYsNDEyODQyNjcyLDIyMDc3MTA1MTddXG4gICAgICAgICAgICAgICAgLy8gNSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIC8vIDYgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAvLyA3IHwgICAgIFsyNzU1MTQyOTkxLDQxOTI0MjMyNTYsMjk5NDM1OSw0Njc4NzgzNzBdXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudFdpZHRoID0gdHlwZWRBcnJheUVsZW1lbnRXaWR0aHMuZ2V0KHZhbC5jb25zdHJ1Y3RvcikhO1xuICAgIFxuICAgICAgICAgICAgICAgIG1heENvbFdpZHRoc1tqICsgMV0gPSBNYXRoLm1heChtYXhDb2xXaWR0aHNbaiArIDFdIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIDIgKyAvLyBicmFja2V0cyBvbiBlYWNoIGVuZFxuICAgICAgICAgICAgICAgICAgICAodmFsLmxlbmd0aCAtIDEpICsgLy8gY29tbWFzIGJldHdlZW4gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgKHZhbC5sZW5ndGggKiBlbGVtZW50V2lkdGgpIC8vIHdpZHRoIG9mIHN0cmluZ2lmaWVkIDJeTi0xXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF4Q29sV2lkdGhzW2ogKyAxXSA9IE1hdGgubWF4KG1heENvbFdpZHRoc1tqICsgMV0gfHwgMCwgdmFsdWVUb1N0cmluZyh2YWwpLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heENvbFdpZHRocztcbn1cblxuLy8gTWVhc3VyZSB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgMl5OLTEgZm9yIGVhY2ggVHlwZWRBcnJheSB2YXJpYW50XG5jb25zdCB0eXBlZEFycmF5RWxlbWVudFdpZHRocyA9ICgoKSA9PiB7XG4gICAgY29uc3QgbWF4RWxlbWVudFdpZHRoID0gKEFycmF5VHlwZTogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IG9jdGV0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IEFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVCAtIDEgfSwgXyA9PiAyNTUpO1xuICAgICAgICByZXR1cm4gYCR7bmV3IEFycmF5VHlwZShuZXcgVWludDhBcnJheShbLi4ub2N0ZXRzLCAyNTRdKS5idWZmZXIpWzBdfWAubGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBNYXA8YW55LCBudW1iZXI+KFtcbiAgICAgICAgW0ludDhBcnJheSwgbWF4RWxlbWVudFdpZHRoKEludDhBcnJheSldLFxuICAgICAgICBbSW50MTZBcnJheSwgbWF4RWxlbWVudFdpZHRoKEludDE2QXJyYXkpXSxcbiAgICAgICAgW0ludDMyQXJyYXksIG1heEVsZW1lbnRXaWR0aChJbnQzMkFycmF5KV0sXG4gICAgICAgIFtVaW50OEFycmF5LCBtYXhFbGVtZW50V2lkdGgoVWludDhBcnJheSldLFxuICAgICAgICBbVWludDE2QXJyYXksIG1heEVsZW1lbnRXaWR0aChVaW50MTZBcnJheSldLFxuICAgICAgICBbVWludDMyQXJyYXksIG1heEVsZW1lbnRXaWR0aChVaW50MzJBcnJheSldLFxuICAgICAgICBbRmxvYXQzMkFycmF5LCBtYXhFbGVtZW50V2lkdGgoRmxvYXQzMkFycmF5KV0sXG4gICAgICAgIFtGbG9hdDY0QXJyYXksIG1heEVsZW1lbnRXaWR0aChGbG9hdDY0QXJyYXkpXSxcbiAgICAgICAgW1VpbnQ4Q2xhbXBlZEFycmF5LCBtYXhFbGVtZW50V2lkdGgoVWludDhDbGFtcGVkQXJyYXkpXVxuICAgIF0pXG59KSgpO1xuXG5mdW5jdGlvbiBjbGlPcHRzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIG5hbWU6ICdzY2hlbWEnLCBhbGlhczogJ3MnLFxuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgICAgdHlwZUxhYmVsOiAne3VuZGVybGluZSBjb2x1bW5zfScsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Egc3BhY2UtZGVsaW1pdGVkIGxpc3Qgb2YgY29sdW1uIG5hbWVzJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBuYW1lOiAnZmlsZScsIGFsaWFzOiAnZicsXG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSwgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBBcnJvdyBmaWxlIHRvIHJlYWQnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIG5hbWU6ICdzZXAnLCBvcHRpb25hbDogdHJ1ZSwgZGVmYXVsdDogJ3wnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgY29sdW1uIHNlcGFyYXRvciBjaGFyYWN0ZXInXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBuYW1lOiAnaGVscCcsIG9wdGlvbmFsOiB0cnVlLCBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnUHJpbnQgdGhpcyB1c2FnZSBndWlkZS4nXG4gICAgICAgIH1cbiAgICBdOyAgICBcbn1cblxuZnVuY3Rpb24gcHJpbnRfdXNhZ2UoKSB7XG4gICAgY29uc29sZS5sb2cocmVxdWlyZSgnY29tbWFuZC1saW5lLXVzYWdlJykoW1xuICAgICAgICB7XG4gICAgICAgICAgICBoZWFkZXI6ICdhcnJvdzJjc3YnLFxuICAgICAgICAgICAgY29udGVudDogJ1ByaW50IGEgQ1NWIGZyb20gYW4gQXJyb3cgZmlsZSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyOiAnU3lub3BzaXMnLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgICckIGFycm93MmNzdiB7dW5kZXJsaW5lIGZpbGUuYXJyb3d9IFt7Ym9sZCAtLXNjaGVtYX0gY29sdW1uX25hbWUgLi4uXScsXG4gICAgICAgICAgICAgICAgJyQgYXJyb3cyY3N2IFt7Ym9sZCAtLXNjaGVtYX0gY29sdW1uX25hbWUgLi4uXSBbe2JvbGQgLS1maWxlfSB7dW5kZXJsaW5lIGZpbGUuYXJyb3d9XScsXG4gICAgICAgICAgICAgICAgJyQgYXJyb3cyY3N2IHtib2xkIC1zfSBjb2x1bW5fMSB7Ym9sZCAtc30gY29sdW1uXzIgW3tib2xkIC1mfSB7dW5kZXJsaW5lIGZpbGUuYXJyb3d9XScsXG4gICAgICAgICAgICAgICAgJyQgYXJyb3cyY3N2IFt7Ym9sZCAtLWhlbHB9XSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyOiAnT3B0aW9ucycsXG4gICAgICAgICAgICBvcHRpb25MaXN0OiBjbGlPcHRzKClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyOiAnRXhhbXBsZScsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgJyQgYXJyb3cyY3N2IC0tc2NoZW1hIGZvbyBiYXogLWYgc2ltcGxlLmFycm93IC0tc2VwIFwiLFwiJyxcbiAgICAgICAgICAgICAgICAnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyxcbiAgICAgICAgICAgICAgICAnPiBcInJvd19pZFwiLCBcImZvbzogSW50MzJcIiwgXCJiYXI6IEZsb2F0NjRcIiwgXCJiYXo6IFV0ZjhcIicsXG4gICAgICAgICAgICAgICAgJz4gICAgICAgIDAsICAgICAgICAgICAgMSwgICAgICAgICAgICAgIDEsICAgICAgICBcImFhXCInLFxuICAgICAgICAgICAgICAgICc+ICAgICAgICAxLCAgICAgICAgIG51bGwsICAgICAgICAgICBudWxsLCAgICAgICAgbnVsbCcsXG4gICAgICAgICAgICAgICAgJz4gICAgICAgIDIsICAgICAgICAgICAgMywgICAgICAgICAgIG51bGwsICAgICAgICBudWxsJyxcbiAgICAgICAgICAgICAgICAnPiAgICAgICAgMywgICAgICAgICAgICA0LCAgICAgICAgICAgICAgNCwgICAgICAgXCJiYmJcIicsXG4gICAgICAgICAgICAgICAgJz4gICAgICAgIDQsICAgICAgICAgICAgNSwgICAgICAgICAgICAgIDUsICAgICAgXCJjY2NjXCInLFxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgXSkpO1xuICAgIHJldHVybiAxO1xufVxuIl19
