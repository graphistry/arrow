#! /usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const stream = require("stream");
const pretty_1 = require("../util/pretty");
const Arrow_node_1 = require("../Arrow.node");
const padLeft = require('pad-left');
const bignumJSONParse = require('json-bignum').parse;
const pipeline = require('util').promisify(stream.pipeline);
const argv = require(`command-line-args`)(cliOpts(), { partial: true });
const files = argv.help ? [] : [...(argv.file || []), ...(argv._unknown || [])].filter(Boolean);
const state = { ...argv, closed: false, maxColWidths: [10] };
(async () => {
    const sources = argv.help ? [] : [
        ...files.map((file) => () => fs.createReadStream(file)),
        ...(process.stdin.isTTY ? [] : [() => process.stdin])
    ].filter(Boolean);
    let reader;
    let hasReaders = false;
    for (const source of sources) {
        if (state.closed) {
            break;
        }
        for await (reader of recordBatchReaders(source)) {
            hasReaders = true;
            const source = reader.toNodeStream();
            const xform = batchesToString(state, reader.schema);
            const sink = new stream.PassThrough();
            sink.pipe(process.stdout, { end: false });
            await pipeline(source, xform, sink).catch(() => state.closed = true);
        }
        if (state.closed) {
            break;
        }
    }
    return hasReaders ? 0 : print_usage();
})()
    .then((x) => +x || 0, (err) => {
    if (err) {
        console.error(`${err && err.stack || err}`);
    }
    return process.exitCode || 1;
}).then((code) => process.exit(code));
async function* recordBatchReaders(createSourceStream) {
    let json = new Arrow_node_1.AsyncByteQueue();
    let stream = new Arrow_node_1.AsyncByteQueue();
    let source = createSourceStream();
    let reader = null;
    let readers = null;
    // tee the input source, just in case it's JSON
    source.on('end', () => [stream, json].forEach((y) => y.close()))
        .on('data', (x) => [stream, json].forEach((y) => y.write(x)))
        .on('error', (e) => [stream, json].forEach((y) => y.abort(e)));
    try {
        for await (reader of Arrow_node_1.RecordBatchReader.readAll(stream)) {
            reader && (yield reader);
        }
        if (reader)
            return;
    }
    catch (e) {
        readers = null;
    }
    if (!readers) {
        await json.closed;
        if (source instanceof fs.ReadStream) {
            source.close();
        }
        // If the data in the `json` ByteQueue parses to JSON, then assume it's Arrow JSON from a file or stdin
        try {
            for await (reader of Arrow_node_1.RecordBatchReader.readAll(bignumJSONParse(await json.toString()))) {
                reader && (yield reader);
            }
        }
        catch (e) {
            readers = null;
        }
    }
}
function batchesToString(state, schema) {
    let rowId = 0;
    let batchId = -1;
    let maxColWidths = [10];
    const { hr, sep } = state;
    const header = ['row_id', ...schema.fields.map((f) => `${f}`)].map(pretty_1.valueToString);
    state.maxColWidths = header.map((x, i) => Math.max(maxColWidths[i] || 0, x.length));
    return new stream.Transform({
        transform,
        encoding: 'utf8',
        writableObjectMode: true,
        readableObjectMode: false,
        final(cb) {
            // if there were no batches, then print the Schema, and metadata
            if (batchId === -1) {
                this.push(`${horizontalRule(state.maxColWidths, hr, sep)}\n\n`);
                this.push(`${formatRow(header, maxColWidths, sep)}\n`);
                if (state.metadata && schema.metadata.size > 0) {
                    this.push(`metadata:\n${formatMetadata(schema.metadata)}\n`);
                }
            }
            this.push(`${horizontalRule(state.maxColWidths, hr, sep)}\n\n`);
            cb();
        }
    });
    function transform(batch, _enc, cb) {
        batch = !(state.schema && state.schema.length) ? batch : batch.select(...state.schema);
        if (state.closed) {
            return cb(undefined, null);
        }
        // Pass one to convert to strings and count max column widths
        state.maxColWidths = measureColumnWidths(rowId, batch, header.map((x, i) => Math.max(maxColWidths[i] || 0, x.length)));
        // If this is the first batch in a stream, print a top horizontal rule, schema metadata, and 
        if (++batchId === 0) {
            this.push(`${horizontalRule(state.maxColWidths, hr, sep)}\n`);
            if (state.metadata && batch.schema.metadata.size > 0) {
                this.push(`metadata:\n${formatMetadata(batch.schema.metadata)}\n`);
                this.push(`${horizontalRule(state.maxColWidths, hr, sep)}\n`);
            }
            if (batch.length <= 0 || batch.numCols <= 0) {
                this.push(`${formatRow(header, maxColWidths = state.maxColWidths, sep)}\n`);
            }
        }
        if (batch.length > 0 && batch.numCols > 0) {
            // If any of the column widths changed, print the header again
            if (rowId % 350 !== 0 && JSON.stringify(state.maxColWidths) !== JSON.stringify(maxColWidths)) {
                this.push(`${formatRow(header, state.maxColWidths, sep)}\n`);
            }
            maxColWidths = state.maxColWidths;
            for (const row of batch) {
                if (state.closed) {
                    break;
                }
                else if (!row) {
                    continue;
                }
                if (rowId++ % 350 === 0) {
                    this.push(`${formatRow(header, maxColWidths, sep)}\n`);
                }
                this.push(`${formatRow([rowId, ...row].map(pretty_1.valueToString), maxColWidths, sep)}\n`);
            }
        }
        cb();
    }
}
function horizontalRule(maxColWidths, hr = '-', sep = ' |') {
    return ` ${padLeft('', maxColWidths.reduce((x, y) => x + y, -2 + maxColWidths.length * sep.length), hr)}`;
}
function formatRow(row = [], maxColWidths = [], sep = ' |') {
    return `${row.map((x, j) => padLeft(x, maxColWidths[j])).join(sep)}`;
}
function formatMetadata(metadata) {
    return [...metadata].map(([key, val]) => `  ${key}: ${formatMetadataValue(val)}`).join(',  \n');
    function formatMetadataValue(value = '') {
        let parsed = value;
        try {
            parsed = JSON.stringify(JSON.parse(value), null, 2);
        }
        catch (e) {
            parsed = value;
        }
        return pretty_1.valueToString(parsed).split('\n').join('\n  ');
    }
}
function measureColumnWidths(rowId, batch, maxColWidths = []) {
    let val, j = 0;
    for (const row of batch) {
        if (!row) {
            continue;
        }
        maxColWidths[j = 0] = Math.max(maxColWidths[0] || 0, (`${rowId++}`).length);
        for (val of row) {
            if (val && typedArrayElementWidths.has(val.constructor) && (typeof val[Symbol.toPrimitive] !== 'function')) {
                // If we're printing a column of TypedArrays, ensure the column is wide enough to accommodate
                // the widest possible element for a given byte size, since JS omits leading zeroes. For example:
                // 1 |  [1137743649,2170567488,244696391,2122556476]
                // 2 |                                          null
                // 3 |   [637174007,2142281880,961736230,2912449282]
                // 4 |    [1035112265,21832886,412842672,2207710517]
                // 5 |                                          null
                // 6 |                                          null
                // 7 |     [2755142991,4192423256,2994359,467878370]
                const elementWidth = typedArrayElementWidths.get(val.constructor);
                maxColWidths[j + 1] = Math.max(maxColWidths[j + 1] || 0, 2 + // brackets on each end
                    (val.length - 1) + // commas between elements
                    (val.length * elementWidth) // width of stringified 2^N-1
                );
            }
            else {
                maxColWidths[j + 1] = Math.max(maxColWidths[j + 1] || 0, pretty_1.valueToString(val).length);
            }
            ++j;
        }
    }
    return maxColWidths;
}
// Measure the stringified representation of 2^N-1 for each TypedArray variant
const typedArrayElementWidths = (() => {
    const maxElementWidth = (ArrayType) => {
        const octets = Array.from({ length: ArrayType.BYTES_PER_ELEMENT - 1 }, _ => 255);
        return `${new ArrayType(new Uint8Array([...octets, 254]).buffer)[0]}`.length;
    };
    return new Map([
        [Int8Array, maxElementWidth(Int8Array)],
        [Int16Array, maxElementWidth(Int16Array)],
        [Int32Array, maxElementWidth(Int32Array)],
        [Uint8Array, maxElementWidth(Uint8Array)],
        [Uint16Array, maxElementWidth(Uint16Array)],
        [Uint32Array, maxElementWidth(Uint32Array)],
        [Float32Array, maxElementWidth(Float32Array)],
        [Float64Array, maxElementWidth(Float64Array)],
        [Uint8ClampedArray, maxElementWidth(Uint8ClampedArray)]
    ]);
})();
function cliOpts() {
    return [
        {
            type: String,
            name: 'schema', alias: 's',
            optional: true, multiple: true,
            typeLabel: '{underline columns}',
            description: 'A space-delimited list of column names'
        },
        {
            type: String,
            name: 'file', alias: 'f',
            optional: true, multiple: true,
            description: 'The Arrow file to read'
        },
        {
            type: String,
            name: 'sep', optional: true, default: ' |',
            description: 'The column separator character (default: " |")'
        },
        {
            type: String,
            name: 'hr', optional: true, default: '-',
            description: 'The horizontal border character (default: "-")'
        },
        {
            type: Boolean,
            name: 'metadata', alias: 'm',
            optional: true, default: false,
            description: 'Flag to print Schema metadata (default: false)'
        },
        {
            type: Boolean,
            name: 'help', optional: true, default: false,
            description: 'Print this usage guide.'
        }
    ];
}
function print_usage() {
    console.log(require('command-line-usage')([
        {
            header: 'arrow2csv',
            content: 'Print a CSV from an Arrow file'
        },
        {
            header: 'Synopsis',
            content: [
                '$ arrow2csv {underline file.arrow} [{bold --schema} column_name ...]',
                '$ arrow2csv [{bold --schema} column_name ...] [{bold --file} {underline file.arrow}]',
                '$ arrow2csv {bold -s} column_1 {bold -s} column_2 [{bold -f} {underline file.arrow}]',
                '$ arrow2csv [{bold --help}]'
            ]
        },
        {
            header: 'Options',
            optionList: cliOpts()
        },
        {
            header: 'Example',
            content: [
                '$ arrow2csv --schema foo baz --sep "," -f simple.arrow',
                '>--------------------------------------',
                '>   "row_id", "foo: Int32", "baz: Utf8"',
                '>          0,            1,        "aa"',
                '>          1,         null,        null',
                '>          2,            3,        null',
                '>          3,            4,       "bbb"',
                '>          4,            5,      "cccc"',
                '>--------------------------------------',
            ]
        }
    ]));
    return 1;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QyxDQUFDLENBQUM7SUFDSixPQUFPLENBQUMsQ0FBQztBQUNiLENBQUMiLCJmaWxlIjoiYmluL2Fycm93MmNzdi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiMhIC91c3IvYmluL2VudiBub2RlXG5cbi8vIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBzdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCB7IHZhbHVlVG9TdHJpbmcgfSBmcm9tICcuLi91dGlsL3ByZXR0eSc7XG5pbXBvcnQgeyBSZWNvcmRCYXRjaCwgUmVjb3JkQmF0Y2hSZWFkZXIsIEFzeW5jQnl0ZVF1ZXVlIH0gZnJvbSAnLi4vQXJyb3cubm9kZSc7XG5pbXBvcnQgeyBTY2hlbWEgfSBmcm9tICcuLi9zY2hlbWEnO1xuXG5jb25zdCBwYWRMZWZ0ID0gcmVxdWlyZSgncGFkLWxlZnQnKTtcbmNvbnN0IGJpZ251bUpTT05QYXJzZSA9IHJlcXVpcmUoJ2pzb24tYmlnbnVtJykucGFyc2U7XG5jb25zdCBwaXBlbGluZSA9IHJlcXVpcmUoJ3V0aWwnKS5wcm9taXNpZnkoc3RyZWFtLnBpcGVsaW5lKTtcbmNvbnN0IGFyZ3YgPSByZXF1aXJlKGBjb21tYW5kLWxpbmUtYXJnc2ApKGNsaU9wdHMoKSwgeyBwYXJ0aWFsOiB0cnVlIH0pO1xuY29uc3QgZmlsZXMgPSBhcmd2LmhlbHAgPyBbXSA6IFsuLi4oYXJndi5maWxlIHx8IFtdKSwgLi4uKGFyZ3YuX3Vua25vd24gfHwgW10pXS5maWx0ZXIoQm9vbGVhbik7XG5cbmNvbnN0IHN0YXRlID0geyAuLi5hcmd2LCBjbG9zZWQ6IGZhbHNlLCBtYXhDb2xXaWR0aHM6IFsxMF0gfTtcblxudHlwZSBUb1N0cmluZ1N0YXRlID0ge1xuICAgIGhyOiBzdHJpbmc7XG4gICAgc2VwOiBzdHJpbmc7XG4gICAgc2NoZW1hOiBhbnk7XG4gICAgY2xvc2VkOiBib29sZWFuO1xuICAgIG1ldGFkYXRhOiBib29sZWFuO1xuICAgIG1heENvbFdpZHRoczogbnVtYmVyW107XG59O1xuXG4oYXN5bmMgKCkgPT4ge1xuXG4gICAgY29uc3Qgc291cmNlcyA9IGFyZ3YuaGVscCA/IFtdIDogW1xuICAgICAgICAuLi5maWxlcy5tYXAoKGZpbGUpID0+ICgpID0+IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZSkpLFxuICAgICAgICAuLi4ocHJvY2Vzcy5zdGRpbi5pc1RUWSA/IFtdIDogWygpID0+IHByb2Nlc3Muc3RkaW5dKVxuICAgIF0uZmlsdGVyKEJvb2xlYW4pIGFzICgoKSA9PiBOb2RlSlMuUmVhZGFibGVTdHJlYW0pW107XG5cbiAgICBsZXQgcmVhZGVyOiBSZWNvcmRCYXRjaFJlYWRlciB8IG51bGw7XG4gICAgbGV0IGhhc1JlYWRlcnMgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLmNsb3NlZCkgeyBicmVhazsgfVxuICAgICAgICBmb3IgYXdhaXQgKHJlYWRlciBvZiByZWNvcmRCYXRjaFJlYWRlcnMoc291cmNlKSkge1xuICAgICAgICAgICAgaGFzUmVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSByZWFkZXIudG9Ob2RlU3RyZWFtKCk7XG4gICAgICAgICAgICBjb25zdCB4Zm9ybSA9IGJhdGNoZXNUb1N0cmluZyhzdGF0ZSwgcmVhZGVyLnNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCBzaW5rID0gbmV3IHN0cmVhbS5QYXNzVGhyb3VnaCgpO1xuICAgICAgICAgICAgc2luay5waXBlKHByb2Nlc3Muc3Rkb3V0LCB7IGVuZDogZmFsc2UgfSk7XG4gICAgICAgICAgICBhd2FpdCBwaXBlbGluZShzb3VyY2UsIHhmb3JtLCBzaW5rKS5jYXRjaCgoKSA9PiBzdGF0ZS5jbG9zZWQgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuY2xvc2VkKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc1JlYWRlcnMgPyAwIDogcHJpbnRfdXNhZ2UoKTtcbn0pKClcbi50aGVuKCh4KSA9PiAreCB8fCAwLCAoZXJyKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAke2VyciAmJiBlcnIuc3RhY2sgfHwgZXJyfWApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5leGl0Q29kZSB8fCAxO1xufSkudGhlbigoY29kZSkgPT4gcHJvY2Vzcy5leGl0KGNvZGUpKTtcblxuYXN5bmMgZnVuY3Rpb24gKnJlY29yZEJhdGNoUmVhZGVycyhjcmVhdGVTb3VyY2VTdHJlYW06ICgpID0+IE5vZGVKUy5SZWFkYWJsZVN0cmVhbSkge1xuXG4gICAgbGV0IGpzb24gPSBuZXcgQXN5bmNCeXRlUXVldWUoKTtcbiAgICBsZXQgc3RyZWFtID0gbmV3IEFzeW5jQnl0ZVF1ZXVlKCk7XG4gICAgbGV0IHNvdXJjZSA9IGNyZWF0ZVNvdXJjZVN0cmVhbSgpO1xuICAgIGxldCByZWFkZXI6IFJlY29yZEJhdGNoUmVhZGVyIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHJlYWRlcnM6IEFzeW5jSXRlcmFibGU8UmVjb3JkQmF0Y2hSZWFkZXI+IHwgbnVsbCA9IG51bGw7XG4gICAgLy8gdGVlIHRoZSBpbnB1dCBzb3VyY2UsIGp1c3QgaW4gY2FzZSBpdCdzIEpTT05cbiAgICBzb3VyY2Uub24oJ2VuZCcsICgpID0+IFtzdHJlYW0sIGpzb25dLmZvckVhY2goKHkpID0+IHkuY2xvc2UoKSkpXG4gICAgICAgIC5vbignZGF0YScsICh4KSA9PiBbc3RyZWFtLCBqc29uXS5mb3JFYWNoKCh5KSA9PiB5LndyaXRlKHgpKSlcbiAgICAgICAub24oJ2Vycm9yJywgKGUpID0+IFtzdHJlYW0sIGpzb25dLmZvckVhY2goKHkpID0+IHkuYWJvcnQoZSkpKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAocmVhZGVyIG9mIFJlY29yZEJhdGNoUmVhZGVyLnJlYWRBbGwoc3RyZWFtKSkge1xuICAgICAgICAgICAgcmVhZGVyICYmICh5aWVsZCByZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkZXIpIHJldHVybjtcbiAgICB9IGNhdGNoIChlKSB7IHJlYWRlcnMgPSBudWxsOyB9XG5cbiAgICBpZiAoIXJlYWRlcnMpIHtcbiAgICAgICAgYXdhaXQganNvbi5jbG9zZWQ7XG4gICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBmcy5SZWFkU3RyZWFtKSB7IHNvdXJjZS5jbG9zZSgpOyB9XG4gICAgICAgIC8vIElmIHRoZSBkYXRhIGluIHRoZSBganNvbmAgQnl0ZVF1ZXVlIHBhcnNlcyB0byBKU09OLCB0aGVuIGFzc3VtZSBpdCdzIEFycm93IEpTT04gZnJvbSBhIGZpbGUgb3Igc3RkaW5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAocmVhZGVyIG9mIFJlY29yZEJhdGNoUmVhZGVyLnJlYWRBbGwoYmlnbnVtSlNPTlBhcnNlKGF3YWl0IGpzb24udG9TdHJpbmcoKSkpKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyICYmICh5aWVsZCByZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7IHJlYWRlcnMgPSBudWxsOyB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiYXRjaGVzVG9TdHJpbmcoc3RhdGU6IFRvU3RyaW5nU3RhdGUsIHNjaGVtYTogU2NoZW1hKSB7XG5cbiAgICBsZXQgcm93SWQgPSAwO1xuICAgIGxldCBiYXRjaElkID0gLTE7XG4gICAgbGV0IG1heENvbFdpZHRocyA9IFsxMF07XG4gICAgY29uc3QgeyBociwgc2VwIH0gPSBzdGF0ZTtcblxuICAgIGNvbnN0IGhlYWRlciA9IFsncm93X2lkJywgLi4uc2NoZW1hLmZpZWxkcy5tYXAoKGYpID0+IGAke2Z9YCldLm1hcCh2YWx1ZVRvU3RyaW5nKTtcblxuICAgIHN0YXRlLm1heENvbFdpZHRocyA9IGhlYWRlci5tYXAoKHgsIGkpID0+IE1hdGgubWF4KG1heENvbFdpZHRoc1tpXSB8fCAwLCB4Lmxlbmd0aCkpO1xuXG4gICAgcmV0dXJuIG5ldyBzdHJlYW0uVHJhbnNmb3JtKHtcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICB3cml0YWJsZU9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogZmFsc2UsXG4gICAgICAgIGZpbmFsKHRoaXM6IHN0cmVhbS5UcmFuc2Zvcm0sIGNiOiAoZXJyb3I/OiBFcnJvciB8IG51bGwpID0+IHZvaWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdlcmUgbm8gYmF0Y2hlcywgdGhlbiBwcmludCB0aGUgU2NoZW1hLCBhbmQgbWV0YWRhdGFcbiAgICAgICAgICAgIGlmIChiYXRjaElkID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChgJHtob3Jpem9udGFsUnVsZShzdGF0ZS5tYXhDb2xXaWR0aHMsIGhyLCBzZXApfVxcblxcbmApO1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChgJHtmb3JtYXRSb3coaGVhZGVyLCBtYXhDb2xXaWR0aHMsIHNlcCl9XFxuYCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1ldGFkYXRhICYmIHNjaGVtYS5tZXRhZGF0YS5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2goYG1ldGFkYXRhOlxcbiR7Zm9ybWF0TWV0YWRhdGEoc2NoZW1hLm1ldGFkYXRhKX1cXG5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1c2goYCR7aG9yaXpvbnRhbFJ1bGUoc3RhdGUubWF4Q29sV2lkdGhzLCBociwgc2VwKX1cXG5cXG5gKTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybSh0aGlzOiBzdHJlYW0uVHJhbnNmb3JtLCBiYXRjaDogUmVjb3JkQmF0Y2gsIF9lbmM6IHN0cmluZywgY2I6IChlcnJvcj86IEVycm9yLCBkYXRhPzogYW55KSA9PiB2b2lkKSB7XG5cbiAgICAgICAgYmF0Y2ggPSAhKHN0YXRlLnNjaGVtYSAmJiBzdGF0ZS5zY2hlbWEubGVuZ3RoKSA/IGJhdGNoIDogYmF0Y2guc2VsZWN0KC4uLnN0YXRlLnNjaGVtYSk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmNsb3NlZCkgeyByZXR1cm4gY2IodW5kZWZpbmVkLCBudWxsKTsgfVxuXG4gICAgICAgIC8vIFBhc3Mgb25lIHRvIGNvbnZlcnQgdG8gc3RyaW5ncyBhbmQgY291bnQgbWF4IGNvbHVtbiB3aWR0aHNcbiAgICAgICAgc3RhdGUubWF4Q29sV2lkdGhzID0gbWVhc3VyZUNvbHVtbldpZHRocyhyb3dJZCwgYmF0Y2gsIGhlYWRlci5tYXAoKHgsIGkpID0+IE1hdGgubWF4KG1heENvbFdpZHRoc1tpXSB8fCAwLCB4Lmxlbmd0aCkpKTtcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBiYXRjaCBpbiBhIHN0cmVhbSwgcHJpbnQgYSB0b3AgaG9yaXpvbnRhbCBydWxlLCBzY2hlbWEgbWV0YWRhdGEsIGFuZCBcbiAgICAgICAgaWYgKCsrYmF0Y2hJZCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGAke2hvcml6b250YWxSdWxlKHN0YXRlLm1heENvbFdpZHRocywgaHIsIHNlcCl9XFxuYCk7XG4gICAgICAgICAgICBpZiAoc3RhdGUubWV0YWRhdGEgJiYgYmF0Y2guc2NoZW1hLm1ldGFkYXRhLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGBtZXRhZGF0YTpcXG4ke2Zvcm1hdE1ldGFkYXRhKGJhdGNoLnNjaGVtYS5tZXRhZGF0YSl9XFxuYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGAke2hvcml6b250YWxSdWxlKHN0YXRlLm1heENvbFdpZHRocywgaHIsIHNlcCl9XFxuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoIDw9IDAgfHwgYmF0Y2gubnVtQ29scyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGAke2Zvcm1hdFJvdyhoZWFkZXIsIG1heENvbFdpZHRocyA9IHN0YXRlLm1heENvbFdpZHRocywgc2VwKX1cXG5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYXRjaC5sZW5ndGggPiAwICYmIGJhdGNoLm51bUNvbHMgPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIGNvbHVtbiB3aWR0aHMgY2hhbmdlZCwgcHJpbnQgdGhlIGhlYWRlciBhZ2FpblxuICAgICAgICAgICAgaWYgKHJvd0lkICUgMzUwICE9PSAwICYmIEpTT04uc3RyaW5naWZ5KHN0YXRlLm1heENvbFdpZHRocykgIT09IEpTT04uc3RyaW5naWZ5KG1heENvbFdpZHRocykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goYCR7Zm9ybWF0Um93KGhlYWRlciwgc3RhdGUubWF4Q29sV2lkdGhzLCBzZXApfVxcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4Q29sV2lkdGhzID0gc3RhdGUubWF4Q29sV2lkdGhzO1xuICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY2xvc2VkKSB7IGJyZWFrOyB9IGVsc2UgaWYgKCFyb3cpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICBpZiAocm93SWQrKyAlIDM1MCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2goYCR7Zm9ybWF0Um93KGhlYWRlciwgbWF4Q29sV2lkdGhzLCBzZXApfVxcbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goYCR7Zm9ybWF0Um93KFtyb3dJZCwgLi4ucm93XS5tYXAodmFsdWVUb1N0cmluZyksIG1heENvbFdpZHRocywgc2VwKX1cXG5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaG9yaXpvbnRhbFJ1bGUobWF4Q29sV2lkdGhzOiBudW1iZXJbXSwgaHIgPSAnLScsIHNlcCA9ICcgfCcpIHtcbiAgICByZXR1cm4gYCAke3BhZExlZnQoJycsIG1heENvbFdpZHRocy5yZWR1Y2UoKHgsIHkpID0+IHggKyB5LCAtMiArIG1heENvbFdpZHRocy5sZW5ndGggKiBzZXAubGVuZ3RoKSwgaHIpfWA7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJvdyhyb3c6IHN0cmluZ1tdID0gW10sIG1heENvbFdpZHRoczogbnVtYmVyW10gPSBbXSwgc2VwID0gJyB8Jykge1xuICAgIHJldHVybiBgJHtyb3cubWFwKCh4LCBqKSA9PiBwYWRMZWZ0KHgsIG1heENvbFdpZHRoc1tqXSkpLmpvaW4oc2VwKX1gO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNZXRhZGF0YShtZXRhZGF0YTogTWFwPHN0cmluZywgc3RyaW5nPikge1xuXG4gICAgcmV0dXJuIFsuLi5tZXRhZGF0YV0ubWFwKChba2V5LCB2YWxdKSA9PlxuICAgICAgICBgICAke2tleX06ICR7Zm9ybWF0TWV0YWRhdGFWYWx1ZSh2YWwpfWBcbiAgICApLmpvaW4oJywgIFxcbicpO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0TWV0YWRhdGFWYWx1ZSh2YWx1ZTogc3RyaW5nID0gJycpIHtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5zdHJpbmdpZnkoSlNPTi5wYXJzZSh2YWx1ZSksIG51bGwsIDIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7IHBhcnNlZCA9IHZhbHVlOyB9XG4gICAgICAgIHJldHVybiB2YWx1ZVRvU3RyaW5nKHBhcnNlZCkuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtZWFzdXJlQ29sdW1uV2lkdGhzKHJvd0lkOiBudW1iZXIsIGJhdGNoOiBSZWNvcmRCYXRjaCwgbWF4Q29sV2lkdGhzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgbGV0IHZhbDogYW55LCBqID0gMDtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xuICAgICAgICBpZiAoIXJvdykgeyBjb250aW51ZTsgfVxuICAgICAgICBtYXhDb2xXaWR0aHNbaiA9IDBdID0gTWF0aC5tYXgobWF4Q29sV2lkdGhzWzBdIHx8IDAsIChgJHtyb3dJZCsrfWApLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFsIG9mIHJvdykge1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB0eXBlZEFycmF5RWxlbWVudFdpZHRocy5oYXModmFsLmNvbnN0cnVjdG9yKSAmJiAodHlwZW9mIHZhbFtTeW1ib2wudG9QcmltaXRpdmVdICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHByaW50aW5nIGEgY29sdW1uIG9mIFR5cGVkQXJyYXlzLCBlbnN1cmUgdGhlIGNvbHVtbiBpcyB3aWRlIGVub3VnaCB0byBhY2NvbW1vZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB3aWRlc3QgcG9zc2libGUgZWxlbWVudCBmb3IgYSBnaXZlbiBieXRlIHNpemUsIHNpbmNlIEpTIG9taXRzIGxlYWRpbmcgemVyb2VzLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgICAgICAgICAvLyAxIHwgIFsxMTM3NzQzNjQ5LDIxNzA1Njc0ODgsMjQ0Njk2MzkxLDIxMjI1NTY0NzZdXG4gICAgICAgICAgICAgICAgLy8gMiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIC8vIDMgfCAgIFs2MzcxNzQwMDcsMjE0MjI4MTg4MCw5NjE3MzYyMzAsMjkxMjQ0OTI4Ml1cbiAgICAgICAgICAgICAgICAvLyA0IHwgICAgWzEwMzUxMTIyNjUsMjE4MzI4ODYsNDEyODQyNjcyLDIyMDc3MTA1MTddXG4gICAgICAgICAgICAgICAgLy8gNSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIC8vIDYgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAvLyA3IHwgICAgIFsyNzU1MTQyOTkxLDQxOTI0MjMyNTYsMjk5NDM1OSw0Njc4NzgzNzBdXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudFdpZHRoID0gdHlwZWRBcnJheUVsZW1lbnRXaWR0aHMuZ2V0KHZhbC5jb25zdHJ1Y3RvcikhO1xuICAgIFxuICAgICAgICAgICAgICAgIG1heENvbFdpZHRoc1tqICsgMV0gPSBNYXRoLm1heChtYXhDb2xXaWR0aHNbaiArIDFdIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIDIgKyAvLyBicmFja2V0cyBvbiBlYWNoIGVuZFxuICAgICAgICAgICAgICAgICAgICAodmFsLmxlbmd0aCAtIDEpICsgLy8gY29tbWFzIGJldHdlZW4gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgKHZhbC5sZW5ndGggKiBlbGVtZW50V2lkdGgpIC8vIHdpZHRoIG9mIHN0cmluZ2lmaWVkIDJeTi0xXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF4Q29sV2lkdGhzW2ogKyAxXSA9IE1hdGgubWF4KG1heENvbFdpZHRoc1tqICsgMV0gfHwgMCwgdmFsdWVUb1N0cmluZyh2YWwpLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heENvbFdpZHRocztcbn1cblxuLy8gTWVhc3VyZSB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgMl5OLTEgZm9yIGVhY2ggVHlwZWRBcnJheSB2YXJpYW50XG5jb25zdCB0eXBlZEFycmF5RWxlbWVudFdpZHRocyA9ICgoKSA9PiB7XG4gICAgY29uc3QgbWF4RWxlbWVudFdpZHRoID0gKEFycmF5VHlwZTogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IG9jdGV0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IEFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVCAtIDEgfSwgXyA9PiAyNTUpO1xuICAgICAgICByZXR1cm4gYCR7bmV3IEFycmF5VHlwZShuZXcgVWludDhBcnJheShbLi4ub2N0ZXRzLCAyNTRdKS5idWZmZXIpWzBdfWAubGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBNYXA8YW55LCBudW1iZXI+KFtcbiAgICAgICAgW0ludDhBcnJheSwgbWF4RWxlbWVudFdpZHRoKEludDhBcnJheSldLFxuICAgICAgICBbSW50MTZBcnJheSwgbWF4RWxlbWVudFdpZHRoKEludDE2QXJyYXkpXSxcbiAgICAgICAgW0ludDMyQXJyYXksIG1heEVsZW1lbnRXaWR0aChJbnQzMkFycmF5KV0sXG4gICAgICAgIFtVaW50OEFycmF5LCBtYXhFbGVtZW50V2lkdGgoVWludDhBcnJheSldLFxuICAgICAgICBbVWludDE2QXJyYXksIG1heEVsZW1lbnRXaWR0aChVaW50MTZBcnJheSldLFxuICAgICAgICBbVWludDMyQXJyYXksIG1heEVsZW1lbnRXaWR0aChVaW50MzJBcnJheSldLFxuICAgICAgICBbRmxvYXQzMkFycmF5LCBtYXhFbGVtZW50V2lkdGgoRmxvYXQzMkFycmF5KV0sXG4gICAgICAgIFtGbG9hdDY0QXJyYXksIG1heEVsZW1lbnRXaWR0aChGbG9hdDY0QXJyYXkpXSxcbiAgICAgICAgW1VpbnQ4Q2xhbXBlZEFycmF5LCBtYXhFbGVtZW50V2lkdGgoVWludDhDbGFtcGVkQXJyYXkpXVxuICAgIF0pXG59KSgpO1xuXG5mdW5jdGlvbiBjbGlPcHRzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIG5hbWU6ICdzY2hlbWEnLCBhbGlhczogJ3MnLFxuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgICAgdHlwZUxhYmVsOiAne3VuZGVybGluZSBjb2x1bW5zfScsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Egc3BhY2UtZGVsaW1pdGVkIGxpc3Qgb2YgY29sdW1uIG5hbWVzJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBuYW1lOiAnZmlsZScsIGFsaWFzOiAnZicsXG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSwgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBBcnJvdyBmaWxlIHRvIHJlYWQnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIG5hbWU6ICdzZXAnLCBvcHRpb25hbDogdHJ1ZSwgZGVmYXVsdDogJyB8JyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGNvbHVtbiBzZXBhcmF0b3IgY2hhcmFjdGVyIChkZWZhdWx0OiBcIiB8XCIpJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBuYW1lOiAnaHInLCBvcHRpb25hbDogdHJ1ZSwgZGVmYXVsdDogJy0nLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgaG9yaXpvbnRhbCBib3JkZXIgY2hhcmFjdGVyIChkZWZhdWx0OiBcIi1cIiknXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBuYW1lOiAnbWV0YWRhdGEnLCBhbGlhczogJ20nLFxuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdGbGFnIHRvIHByaW50IFNjaGVtYSBtZXRhZGF0YSAoZGVmYXVsdDogZmFsc2UpJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgbmFtZTogJ2hlbHAnLCBvcHRpb25hbDogdHJ1ZSwgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1ByaW50IHRoaXMgdXNhZ2UgZ3VpZGUuJ1xuICAgICAgICB9XG4gICAgXTsgICAgXG59XG5cbmZ1bmN0aW9uIHByaW50X3VzYWdlKCkge1xuICAgIGNvbnNvbGUubG9nKHJlcXVpcmUoJ2NvbW1hbmQtbGluZS11c2FnZScpKFtcbiAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyOiAnYXJyb3cyY3N2JyxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdQcmludCBhIENTViBmcm9tIGFuIEFycm93IGZpbGUnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogJ1N5bm9wc2lzJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICAnJCBhcnJvdzJjc3Yge3VuZGVybGluZSBmaWxlLmFycm93fSBbe2JvbGQgLS1zY2hlbWF9IGNvbHVtbl9uYW1lIC4uLl0nLFxuICAgICAgICAgICAgICAgICckIGFycm93MmNzdiBbe2JvbGQgLS1zY2hlbWF9IGNvbHVtbl9uYW1lIC4uLl0gW3tib2xkIC0tZmlsZX0ge3VuZGVybGluZSBmaWxlLmFycm93fV0nLFxuICAgICAgICAgICAgICAgICckIGFycm93MmNzdiB7Ym9sZCAtc30gY29sdW1uXzEge2JvbGQgLXN9IGNvbHVtbl8yIFt7Ym9sZCAtZn0ge3VuZGVybGluZSBmaWxlLmFycm93fV0nLFxuICAgICAgICAgICAgICAgICckIGFycm93MmNzdiBbe2JvbGQgLS1oZWxwfV0nXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogJ09wdGlvbnMnLFxuICAgICAgICAgICAgb3B0aW9uTGlzdDogY2xpT3B0cygpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0V4YW1wbGUnLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgICckIGFycm93MmNzdiAtLXNjaGVtYSBmb28gYmF6IC0tc2VwIFwiLFwiIC1mIHNpbXBsZS5hcnJvdycsXG4gICAgICAgICAgICAgICAgJz4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsXG4gICAgICAgICAgICAgICAgJz4gICBcInJvd19pZFwiLCBcImZvbzogSW50MzJcIiwgXCJiYXo6IFV0ZjhcIicsXG4gICAgICAgICAgICAgICAgJz4gICAgICAgICAgMCwgICAgICAgICAgICAxLCAgICAgICAgXCJhYVwiJyxcbiAgICAgICAgICAgICAgICAnPiAgICAgICAgICAxLCAgICAgICAgIG51bGwsICAgICAgICBudWxsJyxcbiAgICAgICAgICAgICAgICAnPiAgICAgICAgICAyLCAgICAgICAgICAgIDMsICAgICAgICBudWxsJyxcbiAgICAgICAgICAgICAgICAnPiAgICAgICAgICAzLCAgICAgICAgICAgIDQsICAgICAgIFwiYmJiXCInLFxuICAgICAgICAgICAgICAgICc+ICAgICAgICAgIDQsICAgICAgICAgICAgNSwgICAgICBcImNjY2NcIicsXG4gICAgICAgICAgICAgICAgJz4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICBdKSk7XG4gICAgcmV0dXJuIDE7XG59XG4iXX0=
