{"version":3,"sources":["data.ts"],"names":[],"mappings":"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","file":"data.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from './vector';\nimport { truncateBitmap } from './util/bit';\nimport { popcnt_bit_range } from './util/bit';\nimport { DataType, SparseUnion, DenseUnion } from './type';\nimport { VectorType as BufferType, UnionMode, Type } from './enum';\nimport { toArrayBufferView, toUint8Array, toInt32Array } from './util/buffer';\nimport {\n    Dictionary,\n    Null, Int, Float,\n    Binary, Bool, Utf8, Decimal,\n    Date_, Time, Timestamp, Interval,\n    List, Struct, Union, FixedSizeBinary, FixedSizeList, Map_,\n} from './type';\n\n// When slicing, we do not know the null count of the sliced range without\n// doing some computation. To avoid doing this eagerly, we set the null count\n// to -1 (any negative number will do). When Vector.nullCount is called the\n// first time, the null count will be computed. See ARROW-33\n/** @ignore */ export type kUnknownNullCount = -1;\n/** @ignore */ export const kUnknownNullCount = -1;\n\n/** @ignore */ export type NullBuffer = Uint8Array | null | undefined;\n/** @ignore */ export type TypeIdsBuffer = Int8Array  | ArrayLike<number> | Iterable<number>;\n/** @ignore */ export type ValueOffsetsBuffer = Int32Array  | ArrayLike<number> | Iterable<number>;\n/** @ignore */ export type DataBuffer<T extends DataType> = T['TArray'] | ArrayLike<number> | Iterable<number>;\n\n/** @ignore */\nexport interface Buffers<T extends DataType> {\n      [BufferType.OFFSET]: Int32Array;\n        [BufferType.DATA]: T['TArray'];\n    [BufferType.VALIDITY]: Uint8Array;\n        [BufferType.TYPE]: T['TArray'];\n}\n\n/** @ignore */\nexport interface Data<T extends DataType = DataType> {\n    readonly TType: T['TType'];\n    readonly TArray: T['TArray'];\n    readonly TValue: T['TValue'];\n}\n\n/** @ignore */\nexport class Data<T extends DataType = DataType> {\n\n    public readonly type: T;\n    public readonly length: number;\n    public readonly offset: number;\n    public readonly stride: number;\n    public readonly childData: Data[];\n    public readonly values: Buffers<T>[BufferType.DATA];\n    public readonly typeIds: Buffers<T>[BufferType.TYPE];\n    // @ts-ignore\n    public readonly nullBitmap: Buffers<T>[BufferType.VALIDITY];\n    // @ts-ignore\n    public readonly valueOffsets: Buffers<T>[BufferType.OFFSET];\n\n    public get ArrayType() { return this.type.ArrayType; }\n    public get typeId(): T['TType'] { return this.type.typeId; }\n    public get buffers() {\n        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds] as Buffers<T>;\n    }\n\n    protected _nullCount: number | kUnknownNullCount;\n\n    public get nullCount() {\n        let nullCount = this._nullCount;\n        let nullBitmap: Uint8Array | undefined;\n        if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n            this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n        }\n        return nullCount;\n    }\n\n    constructor(type: T, offset: number, length: number, nullCount?: number, buffers?: Partial<Buffers<T>> | Data<T>, childData?: (Data | Vector)[]) {\n        this.type = type;\n        this.offset = Math.floor(Math.max(offset || 0, 0));\n        this.length = Math.floor(Math.max(length || 0, 0));\n        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n        this.childData = (childData || []).map((x) => x instanceof Data ? x : x.data) as Data[];\n        let buffer: Buffers<T>[keyof Buffers<T>];\n        if (buffers instanceof Data) {\n            this.stride = buffers.stride;\n            this.values = buffers.values;\n            this.typeIds = buffers.typeIds;\n            this.nullBitmap = buffers.nullBitmap;\n            this.valueOffsets = buffers.valueOffsets;\n        } else {\n            if (buffers) {\n                (buffer = (buffers as Buffers<T>)[0]) && (this.valueOffsets = buffer);\n                (buffer = (buffers as Buffers<T>)[1]) && (this.values = buffer);\n                (buffer = (buffers as Buffers<T>)[2]) && (this.nullBitmap = buffer);\n                (buffer = (buffers as Buffers<T>)[3]) && (this.typeIds = buffer);\n            }\n            const t: any = type;\n            switch (type.typeId) {\n                case Type.Decimal: this.stride = 4; break;\n                case Type.Timestamp: this.stride = 2; break;\n                case Type.Date: this.stride = 1 + (t as Date_).unit; break;\n                case Type.Interval: this.stride = 1 + (t as Interval).unit; break;\n                case Type.Int: this.stride = 1 + +((t as Int).bitWidth > 32); break;\n                case Type.Time: this.stride = 1 + +((t as Time).bitWidth > 32); break;\n                case Type.FixedSizeList: this.stride = (t as FixedSizeList).listSize; break;\n                case Type.FixedSizeBinary: this.stride = (t as FixedSizeBinary).byteWidth; break;\n                default: this.stride = 1;\n            }\n        }\n    }\n\n    public clone<R extends DataType>(type: R, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers: Buffers<R> = <any> this, childData: (Data | Vector)[] = this.childData) {\n        return new Data(type, offset, length, nullCount, buffers, childData);\n    }\n\n    public slice(offset: number, length: number): Data<T> {\n        // +true === 1, +false === 0, so this means\n        // we keep nullCount at 0 if it's already 0,\n        // otherwise set to the invalidated flag -1\n        const { stride, typeId, childData } = this;\n        const nullCount = +(this._nullCount === 0) - 1;\n        const childStride = typeId === 16 /* FixedSizeList */ ? stride : 1;\n        const buffers = this._sliceBuffers(offset, length, stride, typeId);\n        return this.clone<T>(this.type, this.offset + offset, length, nullCount, buffers,\n            // Don't slice children if we have value offsets (the variable-width types)\n            (!childData.length || this.valueOffsets) ? childData : this._sliceChildren(childData, childStride * offset, childStride * length));\n    }\n\n    public _changeLengthAndBackfillNullBitmap(newLength: number): Data<T> {\n        const { length, nullCount } = this;\n        // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)\n        const bitmap = new Uint8Array(((newLength + 63) & ~63) >> 3).fill(255, 0, length >> 3);\n        // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)\n        bitmap[length >> 3] = (1 << (length - (length & ~7))) - 1;\n        // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s\n        if (nullCount > 0) {\n            bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);\n        }\n        const buffers = this.buffers;\n        buffers[BufferType.VALIDITY] = bitmap;\n        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);\n    }\n\n    protected _sliceBuffers(offset: number, length: number, stride: number, typeId: T['TType']): Buffers<T> {\n        let arr: any, { buffers } = this;\n        // If typeIds exist, slice the typeIds buffer\n        (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length));\n        // If offsets exist, only slice the offsets buffer\n        (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) ||\n        // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n        (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));\n        return buffers;\n    }\n\n    protected _sliceChildren(childData: Data[], offset: number, length: number): Data[] {\n        return childData.map((child) => child.slice(offset, length));\n    }\n\n    //\n    // Convenience methods for creating Data instances for each of the Arrow Vector types\n    //\n    /** @nocollapse */\n    public static Null<T extends Null>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, _data?: NullBuffer) {\n        return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Int<T extends Int>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Dictionary<T extends Dictionary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView<T['TArray']>(type.indices.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Float<T extends Float>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Bool<T extends Bool>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Decimal<T extends Decimal>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Date<T extends Date_>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Time<T extends Time>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Timestamp<T extends Timestamp>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Interval<T extends Interval>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static FixedSizeBinary<T extends FixedSizeBinary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Binary<T extends Binary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, data: Uint8Array) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Utf8<T extends Utf8>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, data: Uint8Array) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static List<T extends List>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, child: Data<T['valueType']> | Vector<T['valueType']>) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n    public static FixedSizeList<T extends FixedSizeList>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, child: Data | Vector) {\n        return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n    public static Struct<T extends Struct>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, children: (Data | Vector)[]) {\n        return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], children);\n    }\n    /** @nocollapse */\n    public static Map<T extends Map_>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, children: (Data | Vector)[]) {\n        return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], children);\n    }\n    public static Union<T extends SparseUnion>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, children: (Data | Vector)[]): Data<T>;\n    public static Union<T extends DenseUnion>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsets: ValueOffsetsBuffer, children: (Data | Vector)[]): Data<T>;\n    /** @nocollapse */\n    public static Union<T extends Union>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsetsOrChildren: ValueOffsetsBuffer | (Data | Vector)[], children?: (Data | Vector)[]) {\n        const buffers = <unknown> [\n            undefined, undefined,\n            toUint8Array(nullBitmap),\n            toArrayBufferView(type.ArrayType, typeIds)\n        ] as Partial<Buffers<T>>;\n        if (type.mode === UnionMode.Sparse) {\n            return new Data(type, offset, length, nullCount, buffers, valueOffsetsOrChildren as (Data | Vector)[]);\n        }\n        buffers[BufferType.OFFSET] = toInt32Array(<ValueOffsetsBuffer> valueOffsetsOrChildren);\n        return new Data(type, offset, length, nullCount, buffers, children);\n    }\n}\n\n((Data.prototype as any).childData = Object.freeze([]));\n"]}