"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const stream_1 = require("stream");
const adapters_1 = require("./io/adapters");
const reader_1 = require("./ipc/reader");
const writer_1 = require("./ipc/writer");
const compat_1 = require("./util/compat");
const stream_2 = require("./io/stream");
adapters_1.default.toReadableNodeStream = toReadableNodeStream;
reader_1.RecordBatchReader['throughNode'] = recordBatchReaderThroughNodeStream;
writer_1.RecordBatchWriter['throughNode'] = recordBatchWriterThroughNodeStream;
tslib_1.__exportStar(require("./Arrow.dom"), exports);
function recordBatchReaderThroughNodeStream() {
    let reading = false;
    let reader = null;
    let through = new stream_2.AsyncByteQueue();
    return new stream_1.Duplex({
        allowHalfOpen: false,
        readableObjectMode: true,
        writableObjectMode: false,
        final(cb) { through && through.close(); cb(); },
        write(x, _, cb) { through && through.write(x); cb(); },
        read(size) {
            through && (reading || (reading = !!(() => tslib_1.__awaiter(this, void 0, void 0, function* () { return yield next(this, size, reader || (reader = yield open(through))); }))()));
        },
        destroy(err, cb) {
            reading = true;
            through && (err ? through.abort(err) : through.close());
            cb(reader = through = null);
        }
    });
    function open(queue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield (yield reader_1.RecordBatchReader.from(queue)).open();
        });
    }
    function next(sink, size, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r = null;
            while (sink.readable && !(r = yield reader.next()).done) {
                if (!sink.push(r.value) || (size != null && --size <= 0)) {
                    return reading = false;
                }
            }
            sink.push(null);
            yield reader.cancel();
        });
    }
}
function recordBatchWriterThroughNodeStream() {
    let reading = false;
    let through = new stream_2.AsyncByteQueue();
    let reader = new stream_2.AsyncByteStream(through);
    let writer = new this().reset(through);
    return new stream_1.Duplex({
        allowHalfOpen: false,
        writableObjectMode: true,
        readableObjectMode: false,
        final(cb) { writer && writer.close(); cb(); },
        write(x, _, cb) { writer && writer.write(x); cb(); },
        read(size) {
            reader && (reading || (reading = !!(() => tslib_1.__awaiter(this, void 0, void 0, function* () { return yield next(this, size, reader); }))()));
        },
        destroy(err, cb) {
            reading = true;
            writer && (err ? writer.abort(err) : writer.close());
            cb(through = reader = writer = null);
        }
    });
    function next(sink, size, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let buf = null;
            while (sink.readable && (buf = yield reader.read())) {
                if (!sink.push(buf) || (size != null && (size -= buf.byteLength) <= 0)) {
                    return reading = false;
                }
            }
            sink.push(null);
            yield reader.cancel();
        });
    }
}
function toReadableNodeStream(source, options) {
    if (compat_1.isAsyncIterable(source)) {
        return asyncIterableAsReadableNodeStream(source, options);
    }
    if (compat_1.isIterable(source)) {
        return iterableAsReadableNodeStream(source, options);
    }
    throw new Error(`toReadableNodeStream() must be called with an Iterable or AsyncIterable`);
}
function iterableAsReadableNodeStream(source, options) {
    let it, reading = false;
    return new stream_1.Readable(Object.assign({}, options, { read(size) {
            !reading && (reading = true) &&
                next(this, size, (it || (it = source[Symbol.iterator]())));
        },
        destroy(e, cb) {
            if ((reading = true) && it || Boolean(cb(null))) {
                let fn = e == null ? it.return : it.throw;
                (fn && fn.call(it, e) || true) && cb(null);
            }
        } }));
    function next(sink, size, it) {
        let r = null;
        while (sink.readable && (size == null || size-- > 0) && !(r = it.next()).done) {
            if (!sink.push(r.value)) {
                return reading = false;
            }
        }
        if (((r && r.done) || !sink.readable) && (reading = sink.push(null) || true)) {
            it.return && it.return();
        }
    }
}
function asyncIterableAsReadableNodeStream(source, options) {
    let it, reading = false;
    return new stream_1.Readable(Object.assign({}, options, { read(size) {
            reading || (reading = !!(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (yield next(this, size, (it || (it = source[Symbol.asyncIterator]()))));
            }))());
        },
        destroy(e, cb) {
            if ((reading = true) && it || Boolean(cb(null))) {
                ((fn) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    (fn && (yield fn.call(it, e)) || true) && cb(null);
                }))(e == null ? it.return : it.throw);
            }
        } }));
    function next(sink, size, it) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r = null;
            while (sink.readable && (size == null || size-- > 0) && !(r = yield it.next()).done) {
                if (!sink.push(r.value)) {
                    return reading = false;
                }
            }
            if (((r && r.done) || !sink.readable) && (reading = sink.push(null) || true)) {
                it.return && (yield it.return());
            }
        });
    }
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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LEVBQUUsS0FBSSxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFBLElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFBO2dCQUNwRCxDQUFDLENBQUEsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUN4QztRQUNMLENBQUMsSUFDSCxDQUFDO0lBQ0gsU0FBZSxJQUFJLENBQUMsSUFBYyxFQUFFLElBQVksRUFBRSxFQUFvQjs7WUFDbEUsSUFBSSxDQUFDLEdBQTZCLElBQUksQ0FBQztZQUN2QyxPQUFPLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUU7Z0JBQ2pGLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFBRSxPQUFPLE9BQU8sR0FBRyxLQUFLLENBQUM7aUJBQUU7YUFDdkQ7WUFDRCxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUU7Z0JBQzFFLEVBQUUsQ0FBQyxNQUFNLEtBQUksTUFBTSxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUEsQ0FBQzthQUNsQztRQUNMLENBQUM7S0FBQTtBQUNMLENBQUMiLCJmaWxlIjoiQXJyb3cubm9kZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4vdHlwZSc7XG5pbXBvcnQgeyBEdXBsZXgsIFJlYWRhYmxlIH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCBzdHJlYW1BZGFwdGVycyBmcm9tICcuL2lvL2FkYXB0ZXJzJztcbmltcG9ydCB7IFJlY29yZEJhdGNoUmVhZGVyIH0gZnJvbSAnLi9pcGMvcmVhZGVyJztcbmltcG9ydCB7IFJlY29yZEJhdGNoV3JpdGVyIH0gZnJvbSAnLi9pcGMvd3JpdGVyJztcbmltcG9ydCB7IGlzSXRlcmFibGUsIGlzQXN5bmNJdGVyYWJsZSB9IGZyb20gJy4vdXRpbC9jb21wYXQnO1xuaW1wb3J0IHsgQXN5bmNCeXRlU3RyZWFtLCBBc3luY0J5dGVRdWV1ZSB9IGZyb20gJy4vaW8vc3RyZWFtJztcbmltcG9ydCB7IFJlY29yZEJhdGNoIH0gZnJvbSAnLi9yZWNvcmRiYXRjaCc7XG5cbnR5cGUgUmVhZGFibGVPcHRpb25zID0gaW1wb3J0KCdzdHJlYW0nKS5SZWFkYWJsZU9wdGlvbnM7XG5cbnN0cmVhbUFkYXB0ZXJzLnRvUmVhZGFibGVOb2RlU3RyZWFtID0gdG9SZWFkYWJsZU5vZGVTdHJlYW07XG5SZWNvcmRCYXRjaFJlYWRlclsndGhyb3VnaE5vZGUnXSA9IHJlY29yZEJhdGNoUmVhZGVyVGhyb3VnaE5vZGVTdHJlYW07XG5SZWNvcmRCYXRjaFdyaXRlclsndGhyb3VnaE5vZGUnXSA9IHJlY29yZEJhdGNoV3JpdGVyVGhyb3VnaE5vZGVTdHJlYW07XG5cbmV4cG9ydCAqIGZyb20gJy4vQXJyb3cuZG9tJztcblxuZnVuY3Rpb24gcmVjb3JkQmF0Y2hSZWFkZXJUaHJvdWdoTm9kZVN0cmVhbTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBEYXRhVHlwZSB9ID0gYW55PigpIHtcblxuICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IHJlYWRlcjogUmVjb3JkQmF0Y2hSZWFkZXI8VD4gfCBudWxsID0gbnVsbDtcbiAgICBsZXQgdGhyb3VnaCA9IG5ldyBBc3luY0J5dGVRdWV1ZSgpIGFzIEFzeW5jQnl0ZVF1ZXVlIHwgbnVsbDtcblxuICAgIHJldHVybiBuZXcgRHVwbGV4KHtcbiAgICAgICAgYWxsb3dIYWxmT3BlbjogZmFsc2UsXG4gICAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZSxcbiAgICAgICAgZmluYWwoY2IpIHsgdGhyb3VnaCAmJiB0aHJvdWdoLmNsb3NlKCk7IGNiKCk7IH0sXG4gICAgICAgIHdyaXRlKHgsIF8sIGNiKSB7IHRocm91Z2ggJiYgdGhyb3VnaC53cml0ZSh4KTsgY2IoKTsgfSxcbiAgICAgICAgcmVhZChzaXplOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgICAgIHRocm91Z2ggJiYgKHJlYWRpbmcgfHwgKHJlYWRpbmcgPSAhIShhc3luYyAoKSA9PlxuICAgICAgICAgICAgICAgIGF3YWl0IG5leHQodGhpcywgc2l6ZSwgcmVhZGVyIHx8IChyZWFkZXIgPSBhd2FpdCBvcGVuKHRocm91Z2gpKSlcbiAgICAgICAgICAgICkoKSkpO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95KGVyciwgY2IpIHtcbiAgICAgICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3VnaCAmJiAoZXJyID8gdGhyb3VnaC5hYm9ydChlcnIpIDogdGhyb3VnaC5jbG9zZSgpKTtcbiAgICAgICAgICAgIGNiKHJlYWRlciA9IHRocm91Z2ggPSBudWxsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gb3BlbihxdWV1ZTogQXN5bmNCeXRlUXVldWUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IChhd2FpdCBSZWNvcmRCYXRjaFJlYWRlci5mcm9tKHF1ZXVlKSkub3BlbigpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIG5leHQoc2luazogUmVhZGFibGUsIHNpemU6IG51bWJlciwgcmVhZGVyOiBSZWNvcmRCYXRjaFJlYWRlcjxUPik6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGxldCByOiBJdGVyYXRvclJlc3VsdDxSZWNvcmRCYXRjaDxUPj4gfCBudWxsID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKHNpbmsucmVhZGFibGUgJiYgIShyID0gYXdhaXQgcmVhZGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFzaW5rLnB1c2goci52YWx1ZSkgfHwgKHNpemUgIT0gbnVsbCAmJiAtLXNpemUgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpbmsucHVzaChudWxsKTtcbiAgICAgICAgYXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkQmF0Y2hXcml0ZXJUaHJvdWdoTm9kZVN0cmVhbTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBEYXRhVHlwZSB9ID0gYW55Pih0aGlzOiB0eXBlb2YgUmVjb3JkQmF0Y2hXcml0ZXIpIHtcblxuICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IHRocm91Z2g6IEFzeW5jQnl0ZVF1ZXVlIHwgbnVsbCA9IG5ldyBBc3luY0J5dGVRdWV1ZSgpO1xuICAgIGxldCByZWFkZXI6IEFzeW5jQnl0ZVN0cmVhbSB8IG51bGwgPSBuZXcgQXN5bmNCeXRlU3RyZWFtKHRocm91Z2gpO1xuICAgIGxldCB3cml0ZXI6IFJlY29yZEJhdGNoV3JpdGVyPFQ+IHwgbnVsbCA9IG5ldyB0aGlzPFQ+KCkucmVzZXQodGhyb3VnaCk7XG5cbiAgICByZXR1cm4gbmV3IER1cGxleCh7XG4gICAgICAgIGFsbG93SGFsZk9wZW46IGZhbHNlLFxuICAgICAgICB3cml0YWJsZU9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogZmFsc2UsXG4gICAgICAgIGZpbmFsKGNiKSB7IHdyaXRlciAmJiB3cml0ZXIuY2xvc2UoKTsgY2IoKTsgfSxcbiAgICAgICAgd3JpdGUoeCwgXywgY2IpIHsgd3JpdGVyICYmIHdyaXRlci53cml0ZSh4KTsgY2IoKTsgfSxcbiAgICAgICAgcmVhZChzaXplOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgICAgIHJlYWRlciAmJiAocmVhZGluZyB8fCAocmVhZGluZyA9ICEhKGFzeW5jICgpID0+XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV4dCh0aGlzLCBzaXplLCByZWFkZXIpXG4gICAgICAgICAgICApKCkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveShlcnIsIGNiKSB7XG4gICAgICAgICAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdyaXRlciAmJiAoZXJyID8gd3JpdGVyLmFib3J0KGVycikgOiB3cml0ZXIuY2xvc2UoKSk7XG4gICAgICAgICAgICBjYih0aHJvdWdoID0gcmVhZGVyID0gd3JpdGVyID0gbnVsbCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIG5leHQoc2luazogUmVhZGFibGUsIHNpemU6IG51bWJlciwgcmVhZGVyOiBBc3luY0J5dGVTdHJlYW0pOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBsZXQgYnVmOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIHdoaWxlIChzaW5rLnJlYWRhYmxlICYmIChidWYgPSBhd2FpdCByZWFkZXIucmVhZCgpKSkge1xuICAgICAgICAgICAgaWYgKCFzaW5rLnB1c2goYnVmKSB8fCAoc2l6ZSAhPSBudWxsICYmIChzaXplIC09IGJ1Zi5ieXRlTGVuZ3RoKSA8PSAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2luay5wdXNoKG51bGwpO1xuICAgICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b1JlYWRhYmxlTm9kZVN0cmVhbTxUPihzb3VyY2U6IEl0ZXJhYmxlPFQ+IHwgQXN5bmNJdGVyYWJsZTxUPiwgb3B0aW9ucz86IFJlYWRhYmxlT3B0aW9ucyk6IFJlYWRhYmxlIHtcbiAgICBpZiAoaXNBc3luY0l0ZXJhYmxlPFQ+KHNvdXJjZSkpIHsgcmV0dXJuIGFzeW5jSXRlcmFibGVBc1JlYWRhYmxlTm9kZVN0cmVhbShzb3VyY2UsIG9wdGlvbnMpOyB9XG4gICAgaWYgKGlzSXRlcmFibGU8VD4oc291cmNlKSkgeyByZXR1cm4gaXRlcmFibGVBc1JlYWRhYmxlTm9kZVN0cmVhbShzb3VyY2UsIG9wdGlvbnMpOyB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB0b1JlYWRhYmxlTm9kZVN0cmVhbSgpIG11c3QgYmUgY2FsbGVkIHdpdGggYW4gSXRlcmFibGUgb3IgQXN5bmNJdGVyYWJsZWApO1xufVxuXG5mdW5jdGlvbiBpdGVyYWJsZUFzUmVhZGFibGVOb2RlU3RyZWFtPFQ+KHNvdXJjZTogSXRlcmFibGU8VD4sIG9wdGlvbnM/OiBSZWFkYWJsZU9wdGlvbnMpIHtcbiAgICBsZXQgaXQ6IEl0ZXJhdG9yPFQ+LCByZWFkaW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZSh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHJlYWQoc2l6ZTogbnVtYmVyKSB7XG4gICAgICAgICAgICAhcmVhZGluZyAmJiAocmVhZGluZyA9IHRydWUpICYmXG4gICAgICAgICAgICAgICAgbmV4dCh0aGlzLCBzaXplLCAoaXQgfHwgKGl0ID0gc291cmNlW1N5bWJvbC5pdGVyYXRvcl0oKSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveShlOiBFcnJvciB8IG51bGwsIGNiOiAoZTogRXJyb3IgfCBudWxsKSA9PiB2b2lkKSB7XG4gICAgICAgICAgICBpZiAoKHJlYWRpbmcgPSB0cnVlKSAmJiBpdCB8fCBCb29sZWFuKGNiKG51bGwpKSkge1xuICAgICAgICAgICAgICAgIGxldCBmbiA9IGUgPT0gbnVsbCA/IGl0LnJldHVybiA6IGl0LnRocm93O1xuICAgICAgICAgICAgICAgIChmbiAmJiBmbi5jYWxsKGl0LCBlKSB8fCB0cnVlKSAmJiBjYihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBuZXh0KHNpbms6IFJlYWRhYmxlLCBzaXplOiBudW1iZXIsIGl0OiBJdGVyYXRvcjxUPik6IGFueSB7XG4gICAgICAgIGxldCByOiBJdGVyYXRvclJlc3VsdDxUPiB8IG51bGwgPSBudWxsO1xuICAgICAgICB3aGlsZSAoc2luay5yZWFkYWJsZSAmJiAoc2l6ZSA9PSBudWxsIHx8IHNpemUtLSA+IDApICYmICEociA9IGl0Lm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFzaW5rLnB1c2goci52YWx1ZSkpIHsgcmV0dXJuIHJlYWRpbmcgPSBmYWxzZTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoKHIgJiYgci5kb25lKSB8fCAhc2luay5yZWFkYWJsZSkgJiYgKHJlYWRpbmcgPSBzaW5rLnB1c2gobnVsbCkgfHwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGl0LnJldHVybiAmJiBpdC5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYXN5bmNJdGVyYWJsZUFzUmVhZGFibGVOb2RlU3RyZWFtPFQ+KHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUPiwgb3B0aW9ucz86IFJlYWRhYmxlT3B0aW9ucykge1xuICAgIGxldCBpdDogQXN5bmNJdGVyYXRvcjxUPiwgcmVhZGluZyA9IGZhbHNlO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGUoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICByZWFkKHNpemU6IG51bWJlcikge1xuICAgICAgICAgICAgcmVhZGluZyB8fCAocmVhZGluZyA9ICEhKGFzeW5jICgpID0+IChcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXh0KHRoaXMsIHNpemUsIChpdCB8fCAoaXQgPSBzb3VyY2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpKSlcbiAgICAgICAgICAgICkpKCkpO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95KGU6IEVycm9yIHwgbnVsbCwgY2I6IChlOiBFcnJvciB8IG51bGwpID0+IHZvaWQpIHtcbiAgICAgICAgICAgIGlmICgocmVhZGluZyA9IHRydWUpICYmIGl0IHx8IEJvb2xlYW4oY2IobnVsbCkpKSB7XG4gICAgICAgICAgICAgICAgKGFzeW5jIChmbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAoZm4gJiYgYXdhaXQgZm4uY2FsbChpdCwgZSkgfHwgdHJ1ZSkgJiYgY2IobnVsbClcbiAgICAgICAgICAgICAgICB9KShlID09IG51bGwgPyBpdC5yZXR1cm4gOiBpdC50aHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgYXN5bmMgZnVuY3Rpb24gbmV4dChzaW5rOiBSZWFkYWJsZSwgc2l6ZTogbnVtYmVyLCBpdDogQXN5bmNJdGVyYXRvcjxUPik6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGxldCByOiBJdGVyYXRvclJlc3VsdDxUPiB8IG51bGwgPSBudWxsO1xuICAgICAgICB3aGlsZSAoc2luay5yZWFkYWJsZSAmJiAoc2l6ZSA9PSBudWxsIHx8IHNpemUtLSA+IDApICYmICEociA9IGF3YWl0IGl0Lm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFzaW5rLnB1c2goci52YWx1ZSkpIHsgcmV0dXJuIHJlYWRpbmcgPSBmYWxzZTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoKHIgJiYgci5kb25lKSB8fCAhc2luay5yZWFkYWJsZSkgJiYgKHJlYWRpbmcgPSBzaW5rLnB1c2gobnVsbCkgfHwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGl0LnJldHVybiAmJiBhd2FpdCBpdC5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==
