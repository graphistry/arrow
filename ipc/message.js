"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const enum_1 = require("../enum");
const flatbuffers_1 = require("flatbuffers");
var ByteBuffer = flatbuffers_1.flatbuffers.ByteBuffer;
const message_1 = require("./metadata/message");
const compat_1 = require("../util/compat");
const file_1 = require("../io/file");
const buffer_1 = require("../util/buffer");
const stream_1 = require("../io/stream");
const interfaces_1 = require("../io/interfaces");
const invalidMessageType = (type) => `Expected ${enum_1.MessageHeader[type]} Message in stream, but was null or length 0.`;
const nullMessage = (type) => `Header pointer of flatbuffer-encoded ${enum_1.MessageHeader[type]} Message is null or length 0.`;
const invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
const invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
class MessageReader {
    constructor(source) {
        this.source = source instanceof stream_1.ByteStream ? source : new stream_1.ByteStream(source);
    }
    [Symbol.iterator]() { return this; }
    next() {
        let r;
        if ((r = this.readMetadataLength()).done) {
            return interfaces_1.ITERATOR_DONE;
        }
        if ((r = this.readMetadata(r.value)).done) {
            return interfaces_1.ITERATOR_DONE;
        }
        return r;
    }
    throw(value) { return this.source.throw(value); }
    return(value) { return this.source.return(value); }
    readMessage(type) {
        let r;
        if ((r = this.next()).done) {
            return null;
        }
        if ((type != null) && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
        }
        return r.value;
    }
    readMessageBody(bodyLength) {
        if (bodyLength <= 0) {
            return new Uint8Array(0);
        }
        const buf = buffer_1.toUint8Array(this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817
        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126
        return /* 1. */ (buf.byteOffset % 8 === 0) &&
            /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();
    }
    readSchema(throwIfNull = false) {
        const type = enum_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message && message.header();
        if (throwIfNull && !schema) {
            throw new Error(nullMessage(type));
        }
        return schema;
    }
    readMetadataLength() {
        const buf = this.source.read(exports.PADDING);
        const bb = buf && new ByteBuffer(buf);
        const len = +(bb && bb.readInt32(0));
        return { done: len <= 0, value: len };
    }
    readMetadata(metadataLength) {
        const buf = this.source.read(metadataLength);
        if (!buf) {
            return interfaces_1.ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: message_1.Message.decode(buf) };
    }
}
exports.MessageReader = MessageReader;
class AsyncMessageReader {
    constructor(source, byteLength) {
        this.source = source instanceof stream_1.AsyncByteStream ? source
            : compat_1.isFileHandle(source)
                ? new file_1.AsyncRandomAccessFile(source, byteLength)
                : new stream_1.AsyncByteStream(source);
    }
    [Symbol.asyncIterator]() { return this; }
    next() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r;
            if ((r = yield this.readMetadataLength()).done) {
                return interfaces_1.ITERATOR_DONE;
            }
            if ((r = yield this.readMetadata(r.value)).done) {
                return interfaces_1.ITERATOR_DONE;
            }
            return r;
        });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return yield this.source.throw(value); });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return yield this.source.return(value); });
    }
    readMessage(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r;
            if ((r = yield this.next()).done) {
                return null;
            }
            if ((type != null) && r.value.headerType !== type) {
                throw new Error(invalidMessageType(type));
            }
            return r.value;
        });
    }
    readMessageBody(bodyLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (bodyLength <= 0) {
                return new Uint8Array(0);
            }
            const buf = buffer_1.toUint8Array(yield this.source.read(bodyLength));
            if (buf.byteLength < bodyLength) {
                throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
            }
            // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817
            // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126
            return /* 1. */ (buf.byteOffset % 8 === 0) &&
                /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();
        });
    }
    readSchema(throwIfNull = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const type = enum_1.MessageHeader.Schema;
            const message = yield this.readMessage(type);
            const schema = message && message.header();
            if (throwIfNull && !schema) {
                throw new Error(nullMessage(type));
            }
            return schema;
        });
    }
    readMetadataLength() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const buf = yield this.source.read(exports.PADDING);
            const bb = buf && new ByteBuffer(buf);
            const len = +(bb && bb.readInt32(0));
            return { done: len <= 0, value: len };
        });
    }
    readMetadata(metadataLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const buf = yield this.source.read(metadataLength);
            if (!buf) {
                return interfaces_1.ITERATOR_DONE;
            }
            if (buf.byteLength < metadataLength) {
                throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
            }
            return { done: false, value: message_1.Message.decode(buf) };
        });
    }
}
exports.AsyncMessageReader = AsyncMessageReader;
class JSONMessageReader extends MessageReader {
    constructor(source) {
        super(new Uint8Array(0));
        this._schema = false;
        this._body = [];
        this._batchIndex = 0;
        this._dictionaryIndex = 0;
        this._json = source instanceof interfaces_1.ArrowJSON ? source : new interfaces_1.ArrowJSON(source);
    }
    next() {
        const { _json, _batchIndex, _dictionaryIndex } = this;
        const numBatches = _json.batches.length;
        const numDictionaries = _json.dictionaries.length;
        if (!this._schema) {
            this._schema = true;
            const message = message_1.Message.fromJSON(_json.schema, enum_1.MessageHeader.Schema);
            return { value: message, done: _batchIndex >= numBatches && _dictionaryIndex >= numDictionaries };
        }
        if (_dictionaryIndex < numDictionaries) {
            const batch = _json.dictionaries[this._dictionaryIndex++];
            this._body = batch['data']['columns'];
            const message = message_1.Message.fromJSON(batch, enum_1.MessageHeader.DictionaryBatch);
            return { done: false, value: message };
        }
        if (_batchIndex < numBatches) {
            const batch = _json.batches[this._batchIndex++];
            this._body = batch['columns'];
            const message = message_1.Message.fromJSON(batch, enum_1.MessageHeader.RecordBatch);
            return { done: false, value: message };
        }
        this._body = [];
        return interfaces_1.ITERATOR_DONE;
    }
    readMessageBody(_bodyLength) {
        return flattenDataSources(this._body);
        function flattenDataSources(xs) {
            return (xs || []).reduce((buffers, column) => [
                ...buffers,
                ...(column['VALIDITY'] && [column['VALIDITY']] || []),
                ...(column['TYPE'] && [column['TYPE']] || []),
                ...(column['OFFSET'] && [column['OFFSET']] || []),
                ...(column['DATA'] && [column['DATA']] || []),
                ...flattenDataSources(column['children'])
            ], []);
        }
    }
    readMessage(type) {
        let r;
        if ((r = this.next()).done) {
            return null;
        }
        if ((type != null) && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
        }
        return r.value;
    }
    readSchema() {
        const type = enum_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message && message.header();
        if (!message || !schema) {
            throw new Error(nullMessage(type));
        }
        return schema;
    }
}
exports.JSONMessageReader = JSONMessageReader;
exports.PADDING = 4;
exports.MAGIC_STR = 'ARROW1';
exports.MAGIC = new Uint8Array(exports.MAGIC_STR.length);
for (let i = 0; i < exports.MAGIC_STR.length; i += 1 | 0) {
    exports.MAGIC[i] = exports.MAGIC_STR.charCodeAt(i);
}
function checkForMagicArrowString(buffer, index = 0) {
    for (let i = -1, n = exports.MAGIC.length; ++i < n;) {
        if (exports.MAGIC[i] !== buffer[index + i]) {
            return false;
        }
    }
    return true;
}
exports.checkForMagicArrowString = checkForMagicArrowString;
function isValidArrowFile(bb) {
    let fileLength = bb.capacity(), footerLength, lengthOffset;
    if ((fileLength < exports.magicX2AndPadding /*                                  Arrow buffer too small */) ||
        (!checkForMagicArrowString(bb.bytes(), 0) /*                        Missing magic start    */) ||
        (!checkForMagicArrowString(bb.bytes(), fileLength - exports.magicLength) /* Missing magic end      */) ||
        ( /*                                                                 Invalid footer length  */(footerLength = bb.readInt32(lengthOffset = fileLength - exports.magicAndPadding)) < 1 &&
            (footerLength + lengthOffset > fileLength))) {
        return false;
    }
    return true;
}
exports.isValidArrowFile = isValidArrowFile;
exports.magicLength = exports.MAGIC.length;
exports.magicAndPadding = exports.magicLength + exports.PADDING;
exports.magicX2AndPadding = exports.magicLength * 2 + exports.PADDING;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUFDO0FBQzNCLFFBQUEsZUFBZSxHQUFHLG1CQUFXLEdBQUcsZUFBTyxDQUFDO0FBQ3hDLFFBQUEsaUJBQWlCLEdBQUcsbUJBQVcsR0FBRyxDQUFDLEdBQUcsZUFBTyxDQUFDIiwiZmlsZSI6ImlwYy9tZXNzYWdlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmltcG9ydCB7IE1lc3NhZ2VIZWFkZXIgfSBmcm9tICcuLi9lbnVtJztcbmltcG9ydCB7IGZsYXRidWZmZXJzIH0gZnJvbSAnZmxhdGJ1ZmZlcnMnO1xuaW1wb3J0IEJ5dGVCdWZmZXIgPSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyO1xuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gJy4vbWV0YWRhdGEvbWVzc2FnZSc7XG5pbXBvcnQgeyBpc0ZpbGVIYW5kbGUgfSBmcm9tICcuLi91dGlsL2NvbXBhdCc7XG5pbXBvcnQgeyBBc3luY1JhbmRvbUFjY2Vzc0ZpbGUgfSBmcm9tICcuLi9pby9maWxlJztcbmltcG9ydCB7IHRvVWludDhBcnJheSwgQXJyYXlCdWZmZXJWaWV3SW5wdXQgfSBmcm9tICcuLi91dGlsL2J1ZmZlcic7XG5pbXBvcnQgeyBCeXRlU3RyZWFtLCBSZWFkYWJsZVNvdXJjZSwgQXN5bmNCeXRlU3RyZWFtIH0gZnJvbSAnLi4vaW8vc3RyZWFtJztcbmltcG9ydCB7IEFycm93SlNPTiwgQXJyb3dKU09OTGlrZSwgSVRFUkFUT1JfRE9ORSwgRmlsZUhhbmRsZSB9IGZyb20gJy4uL2lvL2ludGVyZmFjZXMnO1xuXG5jb25zdCBpbnZhbGlkTWVzc2FnZVR5cGUgICAgICAgPSAodHlwZTogTWVzc2FnZUhlYWRlcikgPT4gYEV4cGVjdGVkICR7TWVzc2FnZUhlYWRlclt0eXBlXX0gTWVzc2FnZSBpbiBzdHJlYW0sIGJ1dCB3YXMgbnVsbCBvciBsZW5ndGggMC5gO1xuY29uc3QgbnVsbE1lc3NhZ2UgICAgICAgICAgICAgID0gKHR5cGU6IE1lc3NhZ2VIZWFkZXIpID0+IGBIZWFkZXIgcG9pbnRlciBvZiBmbGF0YnVmZmVyLWVuY29kZWQgJHtNZXNzYWdlSGVhZGVyW3R5cGVdfSBNZXNzYWdlIGlzIG51bGwgb3IgbGVuZ3RoIDAuYDtcbmNvbnN0IGludmFsaWRNZXNzYWdlTWV0YWRhdGEgICA9IChleHBlY3RlZDogbnVtYmVyLCBhY3R1YWw6IG51bWJlcikgPT4gYEV4cGVjdGVkIHRvIHJlYWQgJHtleHBlY3RlZH0gbWV0YWRhdGEgYnl0ZXMsIGJ1dCBvbmx5IHJlYWQgJHthY3R1YWx9LmA7XG5jb25zdCBpbnZhbGlkTWVzc2FnZUJvZHlMZW5ndGggPSAoZXhwZWN0ZWQ6IG51bWJlciwgYWN0dWFsOiBudW1iZXIpID0+IGBFeHBlY3RlZCB0byByZWFkICR7ZXhwZWN0ZWR9IGJ5dGVzIGZvciBtZXNzYWdlIGJvZHksIGJ1dCBvbmx5IHJlYWQgJHthY3R1YWx9LmA7XG5cbmV4cG9ydCBjbGFzcyBNZXNzYWdlUmVhZGVyIGltcGxlbWVudHMgSXRlcmFibGVJdGVyYXRvcjxNZXNzYWdlPiB7XG4gICAgcHJvdGVjdGVkIHNvdXJjZTogQnl0ZVN0cmVhbTtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2U6IEJ5dGVTdHJlYW0gfCBBcnJheUJ1ZmZlclZpZXdJbnB1dCB8IEl0ZXJhYmxlPEFycmF5QnVmZmVyVmlld0lucHV0Pikge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZSBpbnN0YW5jZW9mIEJ5dGVTdHJlYW0gPyBzb3VyY2UgOiBuZXcgQnl0ZVN0cmVhbShzb3VyY2UpO1xuICAgIH1cbiAgICBwdWJsaWMgW1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxNZXNzYWdlPiB7IHJldHVybiB0aGlzIGFzIEl0ZXJhYmxlSXRlcmF0b3I8TWVzc2FnZT47IH1cbiAgICBwdWJsaWMgbmV4dCgpOiBJdGVyYXRvclJlc3VsdDxNZXNzYWdlPiB7XG4gICAgICAgIGxldCByO1xuICAgICAgICBpZiAoKHIgPSB0aGlzLnJlYWRNZXRhZGF0YUxlbmd0aCgpKS5kb25lKSB7IHJldHVybiBJVEVSQVRPUl9ET05FOyB9XG4gICAgICAgIGlmICgociA9IHRoaXMucmVhZE1ldGFkYXRhKHIudmFsdWUpKS5kb25lKSB7IHJldHVybiBJVEVSQVRPUl9ET05FOyB9XG4gICAgICAgIHJldHVybiAoPGFueT4gcikgYXMgSXRlcmF0b3JSZXN1bHQ8TWVzc2FnZT47XG4gICAgfVxuICAgIHB1YmxpYyB0aHJvdyh2YWx1ZT86IGFueSkgeyByZXR1cm4gdGhpcy5zb3VyY2UudGhyb3codmFsdWUpOyB9XG4gICAgcHVibGljIHJldHVybih2YWx1ZT86IGFueSkgeyByZXR1cm4gdGhpcy5zb3VyY2UucmV0dXJuKHZhbHVlKTsgfVxuICAgIHB1YmxpYyByZWFkTWVzc2FnZTxUIGV4dGVuZHMgTWVzc2FnZUhlYWRlcj4odHlwZT86IFQgfCBudWxsKSB7XG4gICAgICAgIGxldCByOiBJdGVyYXRvclJlc3VsdDxNZXNzYWdlPFQ+PjtcbiAgICAgICAgaWYgKChyID0gdGhpcy5uZXh0KCkpLmRvbmUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgaWYgKCh0eXBlICE9IG51bGwpICYmIHIudmFsdWUuaGVhZGVyVHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRNZXNzYWdlVHlwZSh0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIudmFsdWU7XG4gICAgfVxuICAgIHB1YmxpYyByZWFkTWVzc2FnZUJvZHkoYm9keUxlbmd0aDogbnVtYmVyKTogVWludDhBcnJheSB7XG4gICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDApIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApOyB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRvVWludDhBcnJheSh0aGlzLnNvdXJjZS5yZWFkKGJvZHlMZW5ndGgpKTtcbiAgICAgICAgaWYgKGJ1Zi5ieXRlTGVuZ3RoIDwgYm9keUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRNZXNzYWdlQm9keUxlbmd0aChib2R5TGVuZ3RoLCBidWYuYnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDEuIFdvcmsgYXJvdW5kIGJ1Z3MgaW4gZnMuUmVhZFN0cmVhbSdzIGludGVybmFsIEJ1ZmZlciBwb29saW5nLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMjQ4MTdcbiAgICAgICAgLy8gMi4gV29yayBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9zdHJlYW1zL2Jsb2IvMGViZTRiMDQyZTQ2N2Q5ODc2ZDgwYWUwNDVkZTM4NDMwOTJhZDc5Ny9yZWZlcmVuY2UtaW1wbGVtZW50YXRpb24vbGliL2hlbHBlcnMuanMjTDEyNlxuICAgICAgICByZXR1cm4gLyogMS4gKi8gKGJ1Zi5ieXRlT2Zmc2V0ICUgOCA9PT0gMCkgJiZcbiAgICAgICAgICAgICAgIC8qIDIuICovIChidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKSA8PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGggPyBidWYgOiBidWYuc2xpY2UoKTtcbiAgICB9XG4gICAgcHVibGljIHJlYWRTY2hlbWEodGhyb3dJZk51bGwgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gTWVzc2FnZUhlYWRlci5TY2hlbWE7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLnJlYWRNZXNzYWdlKHR5cGUpO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBtZXNzYWdlICYmIG1lc3NhZ2UuaGVhZGVyKCk7XG4gICAgICAgIGlmICh0aHJvd0lmTnVsbCAmJiAhc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobnVsbE1lc3NhZ2UodHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIHByb3RlY3RlZCByZWFkTWV0YWRhdGFMZW5ndGgoKTogSXRlcmF0b3JSZXN1bHQ8bnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuc291cmNlLnJlYWQoUEFERElORyk7XG4gICAgICAgIGNvbnN0IGJiID0gYnVmICYmIG5ldyBCeXRlQnVmZmVyKGJ1Zik7XG4gICAgICAgIGNvbnN0IGxlbiA9ICsoYmIgJiYgYmIucmVhZEludDMyKDApKSE7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGxlbiA8PSAwLCB2YWx1ZTogbGVuIH07XG4gICAgfVxuICAgIHByb3RlY3RlZCByZWFkTWV0YWRhdGEobWV0YWRhdGFMZW5ndGg6IG51bWJlcik6IEl0ZXJhdG9yUmVzdWx0PE1lc3NhZ2U+IHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5zb3VyY2UucmVhZChtZXRhZGF0YUxlbmd0aCk7XG4gICAgICAgIGlmICghYnVmKSB7IHJldHVybiBJVEVSQVRPUl9ET05FOyB9XG4gICAgICAgIGlmIChidWYuYnl0ZUxlbmd0aCA8IG1ldGFkYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZE1lc3NhZ2VNZXRhZGF0YShtZXRhZGF0YUxlbmd0aCwgYnVmLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IE1lc3NhZ2UuZGVjb2RlKGJ1ZikgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBc3luY01lc3NhZ2VSZWFkZXIgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8TWVzc2FnZT4ge1xuICAgIHByb3RlY3RlZCBzb3VyY2U6IEFzeW5jQnl0ZVN0cmVhbTtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2U6IFJlYWRhYmxlU291cmNlPFVpbnQ4QXJyYXk+KTtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2U6IEZpbGVIYW5kbGUsIGJ5dGVMZW5ndGg/OiBudW1iZXIpO1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZTogYW55LCBieXRlTGVuZ3RoPzogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlIGluc3RhbmNlb2YgQXN5bmNCeXRlU3RyZWFtID8gc291cmNlXG4gICAgICAgICAgICA6IGlzRmlsZUhhbmRsZShzb3VyY2UpXG4gICAgICAgICAgICA/IG5ldyBBc3luY1JhbmRvbUFjY2Vzc0ZpbGUoc291cmNlLCBieXRlTGVuZ3RoISlcbiAgICAgICAgICAgIDogbmV3IEFzeW5jQnl0ZVN0cmVhbShzb3VyY2UpO1xuICAgIH1cbiAgICBwdWJsaWMgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8TWVzc2FnZT4geyByZXR1cm4gdGhpcyBhcyBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8TWVzc2FnZT47IH1cbiAgICBwdWJsaWMgYXN5bmMgbmV4dCgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PE1lc3NhZ2U+PiB7XG4gICAgICAgIGxldCByO1xuICAgICAgICBpZiAoKHIgPSBhd2FpdCB0aGlzLnJlYWRNZXRhZGF0YUxlbmd0aCgpKS5kb25lKSB7IHJldHVybiBJVEVSQVRPUl9ET05FOyB9XG4gICAgICAgIGlmICgociA9IGF3YWl0IHRoaXMucmVhZE1ldGFkYXRhKHIudmFsdWUpKS5kb25lKSB7IHJldHVybiBJVEVSQVRPUl9ET05FOyB9XG4gICAgICAgIHJldHVybiAoPGFueT4gcikgYXMgSXRlcmF0b3JSZXN1bHQ8TWVzc2FnZT47XG4gICAgfVxuICAgIHB1YmxpYyBhc3luYyB0aHJvdyh2YWx1ZT86IGFueSkgeyByZXR1cm4gYXdhaXQgdGhpcy5zb3VyY2UudGhyb3codmFsdWUpOyB9XG4gICAgcHVibGljIGFzeW5jIHJldHVybih2YWx1ZT86IGFueSkgeyByZXR1cm4gYXdhaXQgdGhpcy5zb3VyY2UucmV0dXJuKHZhbHVlKTsgfVxuICAgIHB1YmxpYyBhc3luYyByZWFkTWVzc2FnZTxUIGV4dGVuZHMgTWVzc2FnZUhlYWRlcj4odHlwZT86IFQgfCBudWxsKSB7XG4gICAgICAgIGxldCByOiBJdGVyYXRvclJlc3VsdDxNZXNzYWdlPFQ+PjtcbiAgICAgICAgaWYgKChyID0gYXdhaXQgdGhpcy5uZXh0KCkpLmRvbmUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgaWYgKCh0eXBlICE9IG51bGwpICYmIHIudmFsdWUuaGVhZGVyVHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRNZXNzYWdlVHlwZSh0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIudmFsdWU7XG4gICAgfVxuICAgIHB1YmxpYyBhc3luYyByZWFkTWVzc2FnZUJvZHkoYm9keUxlbmd0aDogbnVtYmVyKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDApIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApOyB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRvVWludDhBcnJheShhd2FpdCB0aGlzLnNvdXJjZS5yZWFkKGJvZHlMZW5ndGgpKTtcbiAgICAgICAgaWYgKGJ1Zi5ieXRlTGVuZ3RoIDwgYm9keUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRNZXNzYWdlQm9keUxlbmd0aChib2R5TGVuZ3RoLCBidWYuYnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDEuIFdvcmsgYXJvdW5kIGJ1Z3MgaW4gZnMuUmVhZFN0cmVhbSdzIGludGVybmFsIEJ1ZmZlciBwb29saW5nLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMjQ4MTdcbiAgICAgICAgLy8gMi4gV29yayBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9zdHJlYW1zL2Jsb2IvMGViZTRiMDQyZTQ2N2Q5ODc2ZDgwYWUwNDVkZTM4NDMwOTJhZDc5Ny9yZWZlcmVuY2UtaW1wbGVtZW50YXRpb24vbGliL2hlbHBlcnMuanMjTDEyNlxuICAgICAgICByZXR1cm4gLyogMS4gKi8gKGJ1Zi5ieXRlT2Zmc2V0ICUgOCA9PT0gMCkgJiZcbiAgICAgICAgICAgICAgIC8qIDIuICovIChidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKSA8PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGggPyBidWYgOiBidWYuc2xpY2UoKTtcbiAgICB9XG4gICAgcHVibGljIGFzeW5jIHJlYWRTY2hlbWEodGhyb3dJZk51bGwgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gTWVzc2FnZUhlYWRlci5TY2hlbWE7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLnJlYWRNZXNzYWdlKHR5cGUpO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBtZXNzYWdlICYmIG1lc3NhZ2UuaGVhZGVyKCk7XG4gICAgICAgIGlmICh0aHJvd0lmTnVsbCAmJiAhc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobnVsbE1lc3NhZ2UodHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIHByb3RlY3RlZCBhc3luYyByZWFkTWV0YWRhdGFMZW5ndGgoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxudW1iZXI+PiB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMuc291cmNlLnJlYWQoUEFERElORyk7XG4gICAgICAgIGNvbnN0IGJiID0gYnVmICYmIG5ldyBCeXRlQnVmZmVyKGJ1Zik7XG4gICAgICAgIGNvbnN0IGxlbiA9ICsoYmIgJiYgYmIucmVhZEludDMyKDApKSE7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGxlbiA8PSAwLCB2YWx1ZTogbGVuIH07XG4gICAgfVxuICAgIHByb3RlY3RlZCBhc3luYyByZWFkTWV0YWRhdGEobWV0YWRhdGFMZW5ndGg6IG51bWJlcik6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8TWVzc2FnZT4+IHtcbiAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgdGhpcy5zb3VyY2UucmVhZChtZXRhZGF0YUxlbmd0aCk7XG4gICAgICAgIGlmICghYnVmKSB7IHJldHVybiBJVEVSQVRPUl9ET05FOyB9XG4gICAgICAgIGlmIChidWYuYnl0ZUxlbmd0aCA8IG1ldGFkYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZE1lc3NhZ2VNZXRhZGF0YShtZXRhZGF0YUxlbmd0aCwgYnVmLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IE1lc3NhZ2UuZGVjb2RlKGJ1ZikgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBKU09OTWVzc2FnZVJlYWRlciBleHRlbmRzIE1lc3NhZ2VSZWFkZXIge1xuICAgIHByaXZhdGUgX3NjaGVtYSA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2pzb246IEFycm93SlNPTjtcbiAgICBwcml2YXRlIF9ib2R5OiBhbnlbXSA9IFtdO1xuICAgIHByaXZhdGUgX2JhdGNoSW5kZXggPSAwO1xuICAgIHByaXZhdGUgX2RpY3Rpb25hcnlJbmRleCA9IDA7XG4gICAgY29uc3RydWN0b3Ioc291cmNlOiBBcnJvd0pTT04gfCBBcnJvd0pTT05MaWtlKSB7XG4gICAgICAgIHN1cGVyKG5ldyBVaW50OEFycmF5KDApKTtcbiAgICAgICAgdGhpcy5fanNvbiA9IHNvdXJjZSBpbnN0YW5jZW9mIEFycm93SlNPTiA/IHNvdXJjZSA6IG5ldyBBcnJvd0pTT04oc291cmNlKTtcbiAgICB9XG4gICAgcHVibGljIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgX2pzb24sIF9iYXRjaEluZGV4LCBfZGljdGlvbmFyeUluZGV4IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBudW1CYXRjaGVzID0gX2pzb24uYmF0Y2hlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG51bURpY3Rpb25hcmllcyA9IF9qc29uLmRpY3Rpb25hcmllcy5sZW5ndGg7XG4gICAgICAgIGlmICghdGhpcy5fc2NoZW1hKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWEgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IE1lc3NhZ2UuZnJvbUpTT04oX2pzb24uc2NoZW1hLCBNZXNzYWdlSGVhZGVyLlNjaGVtYSk7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbWVzc2FnZSwgZG9uZTogX2JhdGNoSW5kZXggPj0gbnVtQmF0Y2hlcyAmJiBfZGljdGlvbmFyeUluZGV4ID49IG51bURpY3Rpb25hcmllcyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZGljdGlvbmFyeUluZGV4IDwgbnVtRGljdGlvbmFyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IF9qc29uLmRpY3Rpb25hcmllc1t0aGlzLl9kaWN0aW9uYXJ5SW5kZXgrK107XG4gICAgICAgICAgICB0aGlzLl9ib2R5ID0gYmF0Y2hbJ2RhdGEnXVsnY29sdW1ucyddO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IE1lc3NhZ2UuZnJvbUpTT04oYmF0Y2gsIE1lc3NhZ2VIZWFkZXIuRGljdGlvbmFyeUJhdGNoKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogbWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfYmF0Y2hJbmRleCA8IG51bUJhdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gX2pzb24uYmF0Y2hlc1t0aGlzLl9iYXRjaEluZGV4KytdO1xuICAgICAgICAgICAgdGhpcy5fYm9keSA9IGJhdGNoWydjb2x1bW5zJ107XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gTWVzc2FnZS5mcm9tSlNPTihiYXRjaCwgTWVzc2FnZUhlYWRlci5SZWNvcmRCYXRjaCk7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG1lc3NhZ2UgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ib2R5ID0gW107XG4gICAgICAgIHJldHVybiBJVEVSQVRPUl9ET05FO1xuICAgIH1cbiAgICBwdWJsaWMgcmVhZE1lc3NhZ2VCb2R5KF9ib2R5TGVuZ3RoPzogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBmbGF0dGVuRGF0YVNvdXJjZXModGhpcy5fYm9keSkgYXMgYW55O1xuICAgICAgICBmdW5jdGlvbiBmbGF0dGVuRGF0YVNvdXJjZXMoeHM6IGFueVtdKTogYW55W11bXSB7XG4gICAgICAgICAgICByZXR1cm4gKHhzIHx8IFtdKS5yZWR1Y2U8YW55W11bXT4oKGJ1ZmZlcnMsIGNvbHVtbjogYW55KSA9PiBbXG4gICAgICAgICAgICAgICAgLi4uYnVmZmVycyxcbiAgICAgICAgICAgICAgICAuLi4oY29sdW1uWydWQUxJRElUWSddICYmIFtjb2x1bW5bJ1ZBTElESVRZJ11dIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAuLi4oY29sdW1uWydUWVBFJ10gJiYgW2NvbHVtblsnVFlQRSddXSB8fCBbXSksXG4gICAgICAgICAgICAgICAgLi4uKGNvbHVtblsnT0ZGU0VUJ10gJiYgW2NvbHVtblsnT0ZGU0VUJ11dIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAuLi4oY29sdW1uWydEQVRBJ10gJiYgW2NvbHVtblsnREFUQSddXSB8fCBbXSksXG4gICAgICAgICAgICAgICAgLi4uZmxhdHRlbkRhdGFTb3VyY2VzKGNvbHVtblsnY2hpbGRyZW4nXSlcbiAgICAgICAgICAgIF0sIFtdIGFzIGFueVtdW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1YmxpYyByZWFkTWVzc2FnZTxUIGV4dGVuZHMgTWVzc2FnZUhlYWRlcj4odHlwZT86IFQgfCBudWxsKSB7XG4gICAgICAgIGxldCByOiBJdGVyYXRvclJlc3VsdDxNZXNzYWdlPFQ+PjtcbiAgICAgICAgaWYgKChyID0gdGhpcy5uZXh0KCkpLmRvbmUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgaWYgKCh0eXBlICE9IG51bGwpICYmIHIudmFsdWUuaGVhZGVyVHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRNZXNzYWdlVHlwZSh0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIudmFsdWU7XG4gICAgfVxuICAgIHB1YmxpYyByZWFkU2NoZW1hKCkge1xuICAgICAgICBjb25zdCB0eXBlID0gTWVzc2FnZUhlYWRlci5TY2hlbWE7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLnJlYWRNZXNzYWdlKHR5cGUpO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBtZXNzYWdlICYmIG1lc3NhZ2UuaGVhZGVyKCk7XG4gICAgICAgIGlmICghbWVzc2FnZSB8fCAhc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobnVsbE1lc3NhZ2UodHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgUEFERElORyA9IDQ7XG5leHBvcnQgY29uc3QgTUFHSUNfU1RSID0gJ0FSUk9XMSc7XG5leHBvcnQgY29uc3QgTUFHSUMgPSBuZXcgVWludDhBcnJheShNQUdJQ19TVFIubGVuZ3RoKTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCBNQUdJQ19TVFIubGVuZ3RoOyBpICs9IDEgfCAwKSB7XG4gICAgTUFHSUNbaV0gPSBNQUdJQ19TVFIuY2hhckNvZGVBdChpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRm9yTWFnaWNBcnJvd1N0cmluZyhidWZmZXI6IFVpbnQ4QXJyYXksIGluZGV4ID0gMCkge1xuICAgIGZvciAobGV0IGkgPSAtMSwgbiA9IE1BR0lDLmxlbmd0aDsgKytpIDwgbjspIHtcbiAgICAgICAgaWYgKE1BR0lDW2ldICE9PSBidWZmZXJbaW5kZXggKyBpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEFycm93RmlsZShiYjogQnl0ZUJ1ZmZlcikge1xuICAgIGxldCBmaWxlTGVuZ3RoID0gYmIuY2FwYWNpdHkoKSwgZm9vdGVyTGVuZ3RoOiBudW1iZXIsIGxlbmd0aE9mZnNldDogbnVtYmVyO1xuICAgIGlmICgoZmlsZUxlbmd0aCA8IG1hZ2ljWDJBbmRQYWRkaW5nIC8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycm93IGJ1ZmZlciB0b28gc21hbGwgKi8pIHx8XG4gICAgICAgICghY2hlY2tGb3JNYWdpY0Fycm93U3RyaW5nKGJiLmJ5dGVzKCksIDApIC8qICAgICAgICAgICAgICAgICAgICAgICAgTWlzc2luZyBtYWdpYyBzdGFydCAgICAqLykgfHxcbiAgICAgICAgKCFjaGVja0Zvck1hZ2ljQXJyb3dTdHJpbmcoYmIuYnl0ZXMoKSwgZmlsZUxlbmd0aCAtIG1hZ2ljTGVuZ3RoKSAvKiBNaXNzaW5nIG1hZ2ljIGVuZCAgICAgICovKSB8fFxuICAgICAgICAoLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEludmFsaWQgZm9vdGVyIGxlbmd0aCAgKi9cbiAgICAgICAgKGZvb3Rlckxlbmd0aCA9IGJiLnJlYWRJbnQzMihsZW5ndGhPZmZzZXQgPSBmaWxlTGVuZ3RoIC0gbWFnaWNBbmRQYWRkaW5nKSkgPCAxICYmXG4gICAgICAgIChmb290ZXJMZW5ndGggKyBsZW5ndGhPZmZzZXQgPiBmaWxlTGVuZ3RoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGNvbnN0IG1hZ2ljTGVuZ3RoID0gTUFHSUMubGVuZ3RoO1xuZXhwb3J0IGNvbnN0IG1hZ2ljQW5kUGFkZGluZyA9IG1hZ2ljTGVuZ3RoICsgUEFERElORztcbmV4cG9ydCBjb25zdCBtYWdpY1gyQW5kUGFkZGluZyA9IG1hZ2ljTGVuZ3RoICogMiArIFBBRERJTkc7XG4iXX0=
