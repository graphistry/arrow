{"version":3,"sources":["recordbatch.ts"],"names":[],"mappings":"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","file":"recordbatch.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from './data';\nimport { Table } from './table';\nimport { Vector } from './vector';\nimport { Schema, Field } from './schema';\nimport { DataType, Struct } from './type';\nimport { Chunked } from './vector/chunked';\nimport { StructVector } from './vector/struct';\nimport { selectFieldArgs } from './util/args';\nimport { ensureSameLengthData } from './util/recordbatch';\nimport { Clonable, Sliceable, Applicative } from './vector';\n\ntype VectorMap = { [key: string]: Vector };\ntype Fields<T extends { [key: string]: DataType }> = (keyof T)[] | Field<T[keyof T]>[];\ntype ChildData<T extends { [key: string]: DataType }> = (Data<T[keyof T]> | Vector<T[keyof T]>)[];\n\nexport interface RecordBatch<T extends { [key: string]: DataType } = any> {\n    concat(...others: Vector<Struct<T>>[]): Table<T>;\n    slice(begin?: number, end?: number): RecordBatch<T>;\n    clone(data: Data<Struct<T>>, children?: Vector[]): RecordBatch<T>;\n}\n\nexport class RecordBatch<T extends { [key: string]: DataType } = any>\n    extends StructVector<T>\n    implements Clonable<RecordBatch<T>>,\n               Sliceable<RecordBatch<T>>,\n               Applicative<Struct<T>, Table<T>> {\n\n    public static from<T extends VectorMap = any>(children: T): RecordBatch<{ [P in keyof T]: T[P]['type'] }>;\n    public static from<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): RecordBatch<T>;\n    /** @nocollapse */\n    public static from(...args: any[]) {\n        return RecordBatch.new(args[0], args[1]);\n    }\n\n    public static new<T extends VectorMap = any>(children: T): RecordBatch<{ [P in keyof T]: T[P]['type'] }>;\n    public static new<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): RecordBatch<T>;\n    /** @nocollapse */\n    public static new<T extends { [key: string]: DataType } = any>(...args: any[]) {\n        const [fs, xs] = selectFieldArgs<T>(args);\n        const vs = xs.filter((x): x is Vector<T[keyof T]> => x instanceof Vector);\n        return new RecordBatch(...ensureSameLengthData(new Schema<T>(fs), vs.map((x) => x.data)));\n    }\n\n    protected _schema: Schema;\n\n    constructor(schema: Schema<T>, length: number, children: (Data | Vector)[]);\n    constructor(schema: Schema<T>, data: Data<Struct<T>>, children?: Vector[]);\n    constructor(...args: any[]) {\n        let data: Data<Struct<T>>;\n        let schema = args[0] as Schema<T>;\n        let children: Vector[] | undefined;\n        if (args[1] instanceof Data) {\n            [, data, children] = (args as [any, Data<Struct<T>>, Vector<T[keyof T]>[]?]);\n        } else {\n            const fields = schema.fields as Field<T[keyof T]>[];\n            const [, length, childData] = args as [any, number, Data<T[keyof T]>[]];\n            data = Data.Struct(new Struct<T>(fields), 0, length, 0, null, childData);\n        }\n        super(data, children);\n        this._schema = schema;\n    }\n\n    public clone(data: Data<Struct<T>>, children = this._children) {\n        return new RecordBatch<T>(this._schema, data, children);\n    }\n\n    public concat(...others: Vector<Struct<T>>[]): Table<T> {\n        const schema = this._schema, chunks = Chunked.flatten(this, ...others);\n        return new Table(schema, chunks.map(({ data }) => new RecordBatch(schema, data)));\n    }\n\n    public get schema() { return this._schema; }\n    public get numCols() { return this._schema.fields.length; }\n\n    public select<K extends keyof T = any>(...columnNames: K[]) {\n        const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name as K, i), new Map<K, number>());\n        return this.selectAt(...columnNames.map((columnName) => nameToIndex.get(columnName)!).filter((x) => x > -1));\n    }\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\n        const schema = this._schema.selectAt(...columnIndices);\n        const childData = columnIndices.map((i) => this.data.childData[i]).filter(Boolean);\n        return new RecordBatch<{ [key: string]: K }>(schema, this.length, childData);\n    }\n}\n"]}