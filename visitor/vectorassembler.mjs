// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
import { Vector } from '../vector';
import { Visitor } from '../visitor';
import { UnionMode } from '../enum';
import { RecordBatch } from '../recordbatch';
import { rebaseValueOffsets } from '../util/buffer';
import { packBools, truncateBitmap } from '../util/bit';
import { BufferRegion, FieldNode } from '../ipc/metadata/message';
import { DataType, } from '../type';
export class VectorAssembler extends Visitor {
    constructor() {
        super();
        this._byteLength = 0;
        this._nodes = [];
        this._buffers = [];
        this._bufferRegions = [];
    }
    /** @nocollapse */
    static assemble(...args) {
        const vectors = args.reduce(function flatten(xs, x) {
            if (Array.isArray(x)) {
                return x.reduce(flatten, xs);
            }
            if (!(x instanceof RecordBatch)) {
                return [...xs, x];
            }
            return [...xs, ...x.schema.fields.map((_, i) => x.getChildAt(i))];
        }, []).filter((x) => x instanceof Vector);
        return new VectorAssembler().visitMany(vectors)[0];
    }
    visit(vector) {
        if (!DataType.isDictionary(vector.type)) {
            const { data, length, nullCount } = vector;
            if (length > 2147483647) {
                /* istanbul ignore next */
                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');
            }
            addBuffer.call(this, nullCount <= 0
                ? new Uint8Array(0) // placeholder validity buffer
                : truncateBitmap(data.offset, length, data.nullBitmap)).nodes.push(new FieldNode(length, nullCount));
        }
        return super.visit(vector);
    }
    visitNull(_nullV) { return this; }
    visitDictionary(vector) {
        // Assemble the indices here, Dictionary assembled separately.
        return this.visit(vector.indices);
    }
    get nodes() { return this._nodes; }
    get buffers() { return this._buffers; }
    get byteLength() { return this._byteLength; }
    get bufferRegions() { return this._bufferRegions; }
}
/** @ignore */
function addBuffer(values) {
    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8
    this.buffers.push(values);
    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
}
/** @ignore */
function assembleUnion(vector) {
    const { type, length, typeIds, valueOffsets } = vector;
    // All Union Vectors have a typeIds buffer
    addBuffer.call(this, typeIds);
    // If this is a Sparse Union, treat it like all other Nested types
    if (type.mode === UnionMode.Sparse) {
        return assembleNestedVector.call(this, vector);
    }
    else if (type.mode === UnionMode.Dense) {
        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children
        if (vector.offset <= 0) {
            // If the Vector hasn't been sliced, write the existing valueOffsets
            addBuffer.call(this, valueOffsets);
            // We can treat this like all other Nested types
            return assembleNestedVector.call(this, vector);
        }
        else {
            // A sliced Dense Union is an unpleasant case. Because the offsets are different for
            // each child vector, we need to "rebase" the valueOffsets for each child
            // Union typeIds are not necessary 0-indexed
            const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);
            const childLengths = new Int32Array(maxChildTypeId + 1);
            // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet
            const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);
            const shiftedOffsets = new Int32Array(length);
            // If we have a non-zero offset, then the value offsets do not start at
            // zero. We must a) create a new offsets array with shifted offsets and
            // b) slice the values array accordingly
            const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);
            for (let typeId, shift, index = -1; ++index < length;) {
                if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {
                    shift = childOffsets[typeId] = unshiftedOffsets[typeId];
                }
                shiftedOffsets[index] = unshiftedOffsets[index] - shift;
                ++childLengths[typeId];
            }
            addBuffer.call(this, shiftedOffsets);
            // Slice and visit children accordingly
            for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {
                if (child = vector.getChildAt(childIndex)) {
                    const typeId = type.typeIds[childIndex];
                    const childLength = Math.min(length, childLengths[typeId]);
                    this.visit(child.slice(childOffsets[typeId], childLength));
                }
            }
        }
    }
    return this;
}
/** @ignore */
function assembleBoolVector(vector) {
    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed
    let values;
    if (vector.nullCount >= vector.length) {
        // If all values are null, just insert a placeholder empty data buffer (fastest path)
        return addBuffer.call(this, new Uint8Array(0));
    }
    else if ((values = vector.values) instanceof Uint8Array) {
        // If values is already a Uint8Array, slice the bitmap (fast path)
        return addBuffer.call(this, truncateBitmap(vector.offset, vector.length, values));
    }
    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the
    // values as bools and re-pack them into a Uint8Array. This code isn't
    // reachable unless you're trying to manipulate the Data internals,
    // we we're only doing this for safety.
    /* istanbul ignore next */
    return addBuffer.call(this, packBools(vector));
}
/** @ignore */
function assembleFlatVector(vector) {
    return addBuffer.call(this, vector.values.subarray(0, vector.length * vector.stride));
}
/** @ignore */
function assembleFlatListVector(vector) {
    const { length, values, valueOffsets } = vector;
    const firstOffset = valueOffsets[0];
    const lastOffset = valueOffsets[length];
    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);
    // Push in the order FlatList types read their buffers
    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first
    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second
    return this;
}
/** @ignore */
function assembleListVector(vector) {
    const { length, valueOffsets } = vector;
    // If we have valueOffsets (ListVector), push that buffer first
    if (valueOffsets) {
        addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));
    }
    // Then insert the List's values child
    return this.visit(vector.getChildAt(0));
}
/** @ignore */
function assembleNestedVector(vector) {
    return this.visitMany(vector.type.children.map((_, i) => vector.getChildAt(i)).filter(Boolean))[0];
}
VectorAssembler.prototype.visitBool = assembleBoolVector;
VectorAssembler.prototype.visitInt = assembleFlatVector;
VectorAssembler.prototype.visitFloat = assembleFlatVector;
VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitBinary = assembleFlatListVector;
VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
VectorAssembler.prototype.visitDate = assembleFlatVector;
VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
VectorAssembler.prototype.visitTime = assembleFlatVector;
VectorAssembler.prototype.visitDecimal = assembleFlatVector;
VectorAssembler.prototype.visitList = assembleListVector;
VectorAssembler.prototype.visitStruct = assembleNestedVector;
VectorAssembler.prototype.visitUnion = assembleUnion;
VectorAssembler.prototype.visitInterval = assembleFlatVector;
VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
VectorAssembler.prototype.visitMap = assembleNestedVector;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZpc2l0b3IvdmVjdG9yYXNzZW1ibGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZEQUE2RDtBQUM3RCwrREFBK0Q7QUFDL0Qsd0RBQXdEO0FBQ3hELDZEQUE2RDtBQUM3RCxvREFBb0Q7QUFDcEQsNkRBQTZEO0FBQzdELDZEQUE2RDtBQUM3RCxFQUFFO0FBQ0YsK0NBQStDO0FBQy9DLEVBQUU7QUFDRiw2REFBNkQ7QUFDN0QsOERBQThEO0FBQzlELHlEQUF5RDtBQUN6RCw0REFBNEQ7QUFDNUQsMERBQTBEO0FBQzFELHFCQUFxQjtBQUdyQixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ25DLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDckMsT0FBTyxFQUFRLFNBQVMsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUMxQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFN0MsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxjQUFjLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEQsT0FBTyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNsRSxPQUFPLEVBQ0gsUUFBUSxHQUdYLE1BQU0sU0FBUyxDQUFDO0FBMEJqQixNQUFNLE9BQU8sZUFBZ0IsU0FBUSxPQUFPO0lBY3hDO1FBQXdCLEtBQUssRUFBRSxDQUFDO1FBNEJ0QixnQkFBVyxHQUFHLENBQUMsQ0FBQztRQUNoQixXQUFNLEdBQWdCLEVBQUUsQ0FBQztRQUN6QixhQUFRLEdBQXNCLEVBQUUsQ0FBQztRQUNqQyxtQkFBYyxHQUFtQixFQUFFLENBQUM7SUEvQmIsQ0FBQztJQVpsQyxrQkFBa0I7SUFDWCxNQUFNLENBQUMsUUFBUSxDQUFpQyxHQUFHLElBQWlCO1FBRXZFLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxPQUFPLENBQUMsRUFBUyxFQUFFLENBQU07WUFDMUQsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUFFLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7YUFBRTtZQUN2RCxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksV0FBVyxDQUFDLEVBQUU7Z0JBQUUsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQUU7WUFDdkQsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdkUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQU0sRUFBZSxFQUFFLENBQUMsQ0FBQyxZQUFZLE1BQU0sQ0FBQyxDQUFDO1FBRTVELE9BQU8sSUFBSSxlQUFlLEVBQUUsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUlNLEtBQUssQ0FBbUIsTUFBUztRQUNwQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDckMsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsTUFBTSxDQUFDO1lBQzNDLElBQUksTUFBTSxHQUFHLFVBQVUsRUFBRTtnQkFDckIsMEJBQTBCO2dCQUMxQixNQUFNLElBQUksVUFBVSxDQUFDLG9EQUFvRCxDQUFDLENBQUM7YUFDOUU7WUFDRCxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxTQUFTLElBQUksQ0FBQztnQkFDL0IsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLDhCQUE4QjtnQkFDbEQsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQ3pELENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztTQUNsRDtRQUNELE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRU0sU0FBUyxDQUFpQixNQUFnQixJQUFJLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM1RCxlQUFlLENBQXVCLE1BQWdCO1FBQ3pELDhEQUE4RDtRQUM5RCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxJQUFXLEtBQUssS0FBSyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzFDLElBQVcsT0FBTyxLQUFLLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDOUMsSUFBVyxVQUFVLEtBQUssT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztJQUNwRCxJQUFXLGFBQWEsS0FBSyxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO0NBTTdEO0FBRUQsY0FBYztBQUNkLFNBQVMsU0FBUyxDQUF3QixNQUF1QjtJQUM3RCxNQUFNLFVBQVUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyw4QkFBOEI7SUFDL0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDMUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLElBQUksQ0FBQyxXQUFXLElBQUksVUFBVSxDQUFDO0lBQy9CLE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUM7QUFFRCxjQUFjO0FBQ2QsU0FBUyxhQUFhLENBQXlDLE1BQWdCO0lBQzNFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsR0FBRyxNQUFNLENBQUM7SUFDdkQsMENBQTBDO0lBQzFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzlCLGtFQUFrRTtJQUNsRSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLE1BQU0sRUFBRTtRQUNoQyxPQUFPLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDbEQ7U0FBTSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLEtBQUssRUFBRTtRQUN0QywyRkFBMkY7UUFDM0YsSUFBSSxNQUFNLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtZQUNwQixvRUFBb0U7WUFDcEUsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDbkMsZ0RBQWdEO1lBQ2hELE9BQU8sb0JBQW9CLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztTQUNsRDthQUFNO1lBQ0gsb0ZBQW9GO1lBQ3BGLHlFQUF5RTtZQUN6RSw0Q0FBNEM7WUFDNUMsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVFLE1BQU0sWUFBWSxHQUFHLElBQUksVUFBVSxDQUFDLGNBQWMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN4RCxrR0FBa0c7WUFDbEcsTUFBTSxZQUFZLEdBQUcsSUFBSSxVQUFVLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pFLE1BQU0sY0FBYyxHQUFHLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzlDLHVFQUF1RTtZQUN2RSx1RUFBdUU7WUFDdkUsd0NBQXdDO1lBQ3hDLE1BQU0sZ0JBQWdCLEdBQUcsa0JBQWtCLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO1lBQ3BGLEtBQUssSUFBSSxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEtBQUssR0FBRyxNQUFNLEdBQUc7Z0JBQ25ELElBQUksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO29CQUN4RCxLQUFLLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUMzRDtnQkFDRCxjQUFjLENBQUMsS0FBSyxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDO2dCQUN4RCxFQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMxQjtZQUNELFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBQ3JDLHVDQUF1QztZQUN2QyxLQUFLLElBQUksS0FBb0IsRUFBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUUsV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLEVBQUUsVUFBVSxHQUFHLFdBQVcsR0FBRztnQkFDN0csSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRTtvQkFDdkMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztvQkFDeEMsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7b0JBQzNELElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztpQkFDOUQ7YUFDSjtTQUNKO0tBQ0o7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNoQixDQUFDO0FBRUQsY0FBYztBQUNkLFNBQVMsa0JBQWtCLENBQXdDLE1BQWdCO0lBQy9FLHVGQUF1RjtJQUN2RixJQUFJLE1BQWtCLENBQUM7SUFDdkIsSUFBSSxNQUFNLENBQUMsU0FBUyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7UUFDbkMscUZBQXFGO1FBQ3JGLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNsRDtTQUFNLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLFVBQVUsRUFBRTtRQUN2RCxrRUFBa0U7UUFDbEUsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDckY7SUFDRCx1RUFBdUU7SUFDdkUsc0VBQXNFO0lBQ3RFLG1FQUFtRTtJQUNuRSx1Q0FBdUM7SUFDdkMsMEJBQTBCO0lBQzFCLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDbkQsQ0FBQztBQUVELGNBQWM7QUFDZCxTQUFTLGtCQUFrQixDQUFpSCxNQUFnQjtJQUN4SixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQzFGLENBQUM7QUFFRCxjQUFjO0FBQ2QsU0FBUyxzQkFBc0IsQ0FBaUQsTUFBZ0I7SUFDNUYsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLEdBQUcsTUFBTSxDQUFDO0lBQ2hELE1BQU0sV0FBVyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwQyxNQUFNLFVBQVUsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDeEMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsV0FBVyxFQUFFLE1BQU0sQ0FBQyxVQUFVLEdBQUcsV0FBVyxDQUFDLENBQUM7SUFDdkYsc0RBQXNEO0lBQ3RELFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLGtCQUFrQixDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsNEJBQTRCO0lBQzlHLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLFdBQVcsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsOEJBQThCO0lBQzVHLE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUM7QUFFRCxjQUFjO0FBQ2QsU0FBUyxrQkFBa0IsQ0FBd0QsTUFBZ0I7SUFDL0YsTUFBTSxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsR0FBRyxNQUFNLENBQUM7SUFDeEMsK0RBQStEO0lBQy9ELElBQUksWUFBWSxFQUFFO1FBQ2QsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO0tBQ25GO0lBQ0Qsc0NBQXNDO0lBQ3RDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBRSxDQUFDLENBQUM7QUFDN0MsQ0FBQztBQUVELGNBQWM7QUFDZCxTQUFTLG9CQUFvQixDQUF5RCxNQUFnQjtJQUNsRyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hHLENBQUM7QUFFRCxlQUFlLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBa0Isa0JBQWtCLENBQUM7QUFDeEUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQW1CLGtCQUFrQixDQUFDO0FBQ3hFLGVBQWUsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFpQixrQkFBa0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBYyxzQkFBc0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBWSxzQkFBc0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLG9CQUFvQixHQUFPLGtCQUFrQixDQUFDO0FBQ3hFLGVBQWUsQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFrQixrQkFBa0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBYSxrQkFBa0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBa0Isa0JBQWtCLENBQUM7QUFDeEUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQWUsa0JBQWtCLENBQUM7QUFDeEUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQWtCLGtCQUFrQixDQUFDO0FBQ3hFLGVBQWUsQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFjLG9CQUFvQixDQUFDO0FBQ3hFLGVBQWUsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFzQixhQUFhLENBQUM7QUFDeEUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQWMsa0JBQWtCLENBQUM7QUFDeEUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsR0FBUyxrQkFBa0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBaUIsb0JBQW9CLENBQUMiLCJmaWxlIjoidmlzaXRvci92ZWN0b3Jhc3NlbWJsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YSB9IGZyb20gJy4uL2RhdGEnO1xuaW1wb3J0IHsgVmVjdG9yIH0gZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCB7IFZpc2l0b3IgfSBmcm9tICcuLi92aXNpdG9yJztcbmltcG9ydCB7IFR5cGUsIFVuaW9uTW9kZSB9IGZyb20gJy4uL2VudW0nO1xuaW1wb3J0IHsgUmVjb3JkQmF0Y2ggfSBmcm9tICcuLi9yZWNvcmRiYXRjaCc7XG5pbXBvcnQgeyBWZWN0b3IgYXMgVlR5cGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IHJlYmFzZVZhbHVlT2Zmc2V0cyB9IGZyb20gJy4uL3V0aWwvYnVmZmVyJztcbmltcG9ydCB7IHBhY2tCb29scywgdHJ1bmNhdGVCaXRtYXAgfSBmcm9tICcuLi91dGlsL2JpdCc7XG5pbXBvcnQgeyBCdWZmZXJSZWdpb24sIEZpZWxkTm9kZSB9IGZyb20gJy4uL2lwYy9tZXRhZGF0YS9tZXNzYWdlJztcbmltcG9ydCB7XG4gICAgRGF0YVR5cGUsIERpY3Rpb25hcnksXG4gICAgRmxvYXQsIEludCwgRGF0ZV8sIEludGVydmFsLCBUaW1lLCBUaW1lc3RhbXAsIFVuaW9uLFxuICAgIEJvb2wsIE51bGwsIFV0ZjgsIEJpbmFyeSwgRGVjaW1hbCwgRml4ZWRTaXplQmluYXJ5LCBMaXN0LCBGaXhlZFNpemVMaXN0LCBNYXBfLCBTdHJ1Y3QsXG59IGZyb20gJy4uL3R5cGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvckFzc2VtYmxlciBleHRlbmRzIFZpc2l0b3Ige1xuICAgIHZpc2l0PFQgZXh0ZW5kcyBWZWN0b3I+KG5vZGU6IFQpOiB0aGlzO1xuICAgIHZpc2l0TWFueTxUIGV4dGVuZHMgVmVjdG9yPihub2RlczogVFtdKTogdGhpc1tdO1xuICAgIGdldFZpc2l0Rm48VCBleHRlbmRzIFR5cGU+KG5vZGU6IFQpOiAodmVjdG9yOiBWVHlwZTxUPikgPT4gdGhpcztcbiAgICBnZXRWaXNpdEZuPFQgZXh0ZW5kcyBEYXRhVHlwZT4obm9kZTogVlR5cGU8VD4gfCBEYXRhPFQ+IHwgVCk6ICh2ZWN0b3I6IFZUeXBlPFQ+KSA9PiB0aGlzO1xuXG4gICAgdmlzaXRCb29sICAgICAgICAgICAgICAgICA8VCBleHRlbmRzIEJvb2w+ICAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0SW50ICAgICAgICAgICAgICAgICAgPFQgZXh0ZW5kcyBJbnQ+ICAgICAgICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdEZsb2F0ICAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgRmxvYXQ+ICAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRVdGY4ICAgICAgICAgICAgICAgICA8VCBleHRlbmRzIFV0Zjg+ICAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0QmluYXJ5ICAgICAgICAgICAgICAgPFQgZXh0ZW5kcyBCaW5hcnk+ICAgICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdEZpeGVkU2l6ZUJpbmFyeSAgICAgIDxUIGV4dGVuZHMgRml4ZWRTaXplQmluYXJ5PiAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXREYXRlICAgICAgICAgICAgICAgICA8VCBleHRlbmRzIERhdGVfPiAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0VGltZXN0YW1wICAgICAgICAgICAgPFQgZXh0ZW5kcyBUaW1lc3RhbXA+ICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdFRpbWUgICAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgVGltZT4gICAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXREZWNpbWFsICAgICAgICAgICAgICA8VCBleHRlbmRzIERlY2ltYWw+ICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0TGlzdCAgICAgICAgICAgICAgICAgPFQgZXh0ZW5kcyBMaXN0PiAgICAgICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdFN0cnVjdCAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgU3RydWN0PiAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRVbmlvbiAgICAgICAgICAgICAgICA8VCBleHRlbmRzIFVuaW9uPiAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0SW50ZXJ2YWwgICAgICAgICAgICAgPFQgZXh0ZW5kcyBJbnRlcnZhbD4gICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdEZpeGVkU2l6ZUxpc3QgICAgICAgIDxUIGV4dGVuZHMgRml4ZWRTaXplTGlzdD4gICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRNYXAgICAgICAgICAgICAgICAgICA8VCBleHRlbmRzIE1hcF8+ICAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xufVxuXG5leHBvcnQgY2xhc3MgVmVjdG9yQXNzZW1ibGVyIGV4dGVuZHMgVmlzaXRvciB7XG5cbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBwdWJsaWMgc3RhdGljIGFzc2VtYmxlPFQgZXh0ZW5kcyBWZWN0b3IgfCBSZWNvcmRCYXRjaD4oLi4uYXJnczogKFQgfCBUW10pW10pIHtcblxuICAgICAgICBjb25zdCB2ZWN0b3JzID0gYXJncy5yZWR1Y2UoZnVuY3Rpb24gZmxhdHRlbih4czogYW55W10sIHg6IGFueSk6IGFueVtdIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7IHJldHVybiB4LnJlZHVjZShmbGF0dGVuLCB4cyk7IH1cbiAgICAgICAgICAgIGlmICghKHggaW5zdGFuY2VvZiBSZWNvcmRCYXRjaCkpIHsgcmV0dXJuIFsuLi54cywgeF07IH1cbiAgICAgICAgICAgIHJldHVybiBbLi4ueHMsIC4uLnguc2NoZW1hLmZpZWxkcy5tYXAoKF8sIGkpID0+IHguZ2V0Q2hpbGRBdChpKSEpXTtcbiAgICAgICAgfSwgW10pLmZpbHRlcigoeDogYW55KTogeCBpcyBWZWN0b3IgPT4geCBpbnN0YW5jZW9mIFZlY3Rvcik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3JBc3NlbWJsZXIoKS52aXNpdE1hbnkodmVjdG9ycylbMF07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoKTsgfVxuXG4gICAgcHVibGljIHZpc2l0PFQgZXh0ZW5kcyBWZWN0b3I+KHZlY3RvcjogVCk6IHRoaXMge1xuICAgICAgICBpZiAoIURhdGFUeXBlLmlzRGljdGlvbmFyeSh2ZWN0b3IudHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgbGVuZ3RoLCBudWxsQ291bnQgfSA9IHZlY3RvcjtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2Fubm90IHdyaXRlIGFycmF5cyBsYXJnZXIgdGhhbiAyXjMxIC0gMSBpbiBsZW5ndGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIG51bGxDb3VudCA8PSAwXG4gICAgICAgICAgICAgICAgPyBuZXcgVWludDhBcnJheSgwKSAvLyBwbGFjZWhvbGRlciB2YWxpZGl0eSBidWZmZXJcbiAgICAgICAgICAgICAgICA6IHRydW5jYXRlQml0bWFwKGRhdGEub2Zmc2V0LCBsZW5ndGgsIGRhdGEubnVsbEJpdG1hcClcbiAgICAgICAgICAgICkubm9kZXMucHVzaChuZXcgRmllbGROb2RlKGxlbmd0aCwgbnVsbENvdW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0KHZlY3Rvcik7XG4gICAgfVxuXG4gICAgcHVibGljIHZpc2l0TnVsbDxUIGV4dGVuZHMgTnVsbD4oX251bGxWOiBWVHlwZTxUPikgeyByZXR1cm4gdGhpczsgfVxuICAgIHB1YmxpYyB2aXNpdERpY3Rpb25hcnk8VCBleHRlbmRzIERpY3Rpb25hcnk+KHZlY3RvcjogVlR5cGU8VD4pIHtcbiAgICAgICAgLy8gQXNzZW1ibGUgdGhlIGluZGljZXMgaGVyZSwgRGljdGlvbmFyeSBhc3NlbWJsZWQgc2VwYXJhdGVseS5cbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQodmVjdG9yLmluZGljZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgbm9kZXMoKSB7IHJldHVybiB0aGlzLl9ub2RlczsgfVxuICAgIHB1YmxpYyBnZXQgYnVmZmVycygpIHsgcmV0dXJuIHRoaXMuX2J1ZmZlcnM7IH1cbiAgICBwdWJsaWMgZ2V0IGJ5dGVMZW5ndGgoKSB7IHJldHVybiB0aGlzLl9ieXRlTGVuZ3RoOyB9XG4gICAgcHVibGljIGdldCBidWZmZXJSZWdpb25zKCkgeyByZXR1cm4gdGhpcy5fYnVmZmVyUmVnaW9uczsgfVxuXG4gICAgcHJvdGVjdGVkIF9ieXRlTGVuZ3RoID0gMDtcbiAgICBwcm90ZWN0ZWQgX25vZGVzOiBGaWVsZE5vZGVbXSA9IFtdO1xuICAgIHByb3RlY3RlZCBfYnVmZmVyczogQXJyYXlCdWZmZXJWaWV3W10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgX2J1ZmZlclJlZ2lvbnM6IEJ1ZmZlclJlZ2lvbltdID0gW107XG59XG5cbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBhZGRCdWZmZXIodGhpczogVmVjdG9yQXNzZW1ibGVyLCB2YWx1ZXM6IEFycmF5QnVmZmVyVmlldykge1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSAodmFsdWVzLmJ5dGVMZW5ndGggKyA3KSAmIH43OyAvLyBSb3VuZCB1cCB0byBhIG11bHRpcGxlIG9mIDhcbiAgICB0aGlzLmJ1ZmZlcnMucHVzaCh2YWx1ZXMpO1xuICAgIHRoaXMuYnVmZmVyUmVnaW9ucy5wdXNoKG5ldyBCdWZmZXJSZWdpb24odGhpcy5fYnl0ZUxlbmd0aCwgYnl0ZUxlbmd0aCkpO1xuICAgIHRoaXMuX2J5dGVMZW5ndGggKz0gYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGFzc2VtYmxlVW5pb248VCBleHRlbmRzIFVuaW9uPih0aGlzOiBWZWN0b3JBc3NlbWJsZXIsIHZlY3RvcjogVlR5cGU8VD4pIHtcbiAgICBjb25zdCB7IHR5cGUsIGxlbmd0aCwgdHlwZUlkcywgdmFsdWVPZmZzZXRzIH0gPSB2ZWN0b3I7XG4gICAgLy8gQWxsIFVuaW9uIFZlY3RvcnMgaGF2ZSBhIHR5cGVJZHMgYnVmZmVyXG4gICAgYWRkQnVmZmVyLmNhbGwodGhpcywgdHlwZUlkcyk7XG4gICAgLy8gSWYgdGhpcyBpcyBhIFNwYXJzZSBVbmlvbiwgdHJlYXQgaXQgbGlrZSBhbGwgb3RoZXIgTmVzdGVkIHR5cGVzXG4gICAgaWYgKHR5cGUubW9kZSA9PT0gVW5pb25Nb2RlLlNwYXJzZSkge1xuICAgICAgICByZXR1cm4gYXNzZW1ibGVOZXN0ZWRWZWN0b3IuY2FsbCh0aGlzLCB2ZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5tb2RlID09PSBVbmlvbk1vZGUuRGVuc2UpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIERlbnNlIFVuaW9uLCBhZGQgdGhlIHZhbHVlT2Zmc2V0cyBidWZmZXIgYW5kIHBvdGVudGlhbGx5IHNsaWNlIHRoZSBjaGlsZHJlblxuICAgICAgICBpZiAodmVjdG9yLm9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgVmVjdG9yIGhhc24ndCBiZWVuIHNsaWNlZCwgd3JpdGUgdGhlIGV4aXN0aW5nIHZhbHVlT2Zmc2V0c1xuICAgICAgICAgICAgYWRkQnVmZmVyLmNhbGwodGhpcywgdmFsdWVPZmZzZXRzKTtcbiAgICAgICAgICAgIC8vIFdlIGNhbiB0cmVhdCB0aGlzIGxpa2UgYWxsIG90aGVyIE5lc3RlZCB0eXBlc1xuICAgICAgICAgICAgcmV0dXJuIGFzc2VtYmxlTmVzdGVkVmVjdG9yLmNhbGwodGhpcywgdmVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEEgc2xpY2VkIERlbnNlIFVuaW9uIGlzIGFuIHVucGxlYXNhbnQgY2FzZS4gQmVjYXVzZSB0aGUgb2Zmc2V0cyBhcmUgZGlmZmVyZW50IGZvclxuICAgICAgICAgICAgLy8gZWFjaCBjaGlsZCB2ZWN0b3IsIHdlIG5lZWQgdG8gXCJyZWJhc2VcIiB0aGUgdmFsdWVPZmZzZXRzIGZvciBlYWNoIGNoaWxkXG4gICAgICAgICAgICAvLyBVbmlvbiB0eXBlSWRzIGFyZSBub3QgbmVjZXNzYXJ5IDAtaW5kZXhlZFxuICAgICAgICAgICAgY29uc3QgbWF4Q2hpbGRUeXBlSWQgPSB0eXBlSWRzLnJlZHVjZSgoeCwgeSkgPT4gTWF0aC5tYXgoeCwgeSksIHR5cGVJZHNbMF0pO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRMZW5ndGhzID0gbmV3IEludDMyQXJyYXkobWF4Q2hpbGRUeXBlSWQgKyAxKTtcbiAgICAgICAgICAgIC8vIFNldCBhbGwgdG8gLTEgdG8gaW5kaWNhdGUgdGhhdCB3ZSBoYXZlbid0IG9ic2VydmVkIGEgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHBhcnRpY3VsYXIgY2hpbGQgeWV0XG4gICAgICAgICAgICBjb25zdCBjaGlsZE9mZnNldHMgPSBuZXcgSW50MzJBcnJheShtYXhDaGlsZFR5cGVJZCArIDEpLmZpbGwoLTEpO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRlZE9mZnNldHMgPSBuZXcgSW50MzJBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG5vbi16ZXJvIG9mZnNldCwgdGhlbiB0aGUgdmFsdWUgb2Zmc2V0cyBkbyBub3Qgc3RhcnQgYXRcbiAgICAgICAgICAgIC8vIHplcm8uIFdlIG11c3QgYSkgY3JlYXRlIGEgbmV3IG9mZnNldHMgYXJyYXkgd2l0aCBzaGlmdGVkIG9mZnNldHMgYW5kXG4gICAgICAgICAgICAvLyBiKSBzbGljZSB0aGUgdmFsdWVzIGFycmF5IGFjY29yZGluZ2x5XG4gICAgICAgICAgICBjb25zdCB1bnNoaWZ0ZWRPZmZzZXRzID0gcmViYXNlVmFsdWVPZmZzZXRzKC12YWx1ZU9mZnNldHNbMF0sIGxlbmd0aCwgdmFsdWVPZmZzZXRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGVJZCwgc2hpZnQsIGluZGV4ID0gLTE7ICsraW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaGlmdCA9IGNoaWxkT2Zmc2V0c1t0eXBlSWQgPSB0eXBlSWRzW2luZGV4XV0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IGNoaWxkT2Zmc2V0c1t0eXBlSWRdID0gdW5zaGlmdGVkT2Zmc2V0c1t0eXBlSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaGlmdGVkT2Zmc2V0c1tpbmRleF0gPSB1bnNoaWZ0ZWRPZmZzZXRzW2luZGV4XSAtIHNoaWZ0O1xuICAgICAgICAgICAgICAgICsrY2hpbGRMZW5ndGhzW3R5cGVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRCdWZmZXIuY2FsbCh0aGlzLCBzaGlmdGVkT2Zmc2V0cyk7XG4gICAgICAgICAgICAvLyBTbGljZSBhbmQgdmlzaXQgY2hpbGRyZW4gYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkOiBWZWN0b3IgfCBudWxsLCBjaGlsZEluZGV4ID0gLTEsIG51bUNoaWxkcmVuID0gdHlwZS5jaGlsZHJlbi5sZW5ndGg7ICsrY2hpbGRJbmRleCA8IG51bUNoaWxkcmVuOykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCA9IHZlY3Rvci5nZXRDaGlsZEF0KGNoaWxkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVJZCA9IHR5cGUudHlwZUlkc1tjaGlsZEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRMZW5ndGggPSBNYXRoLm1pbihsZW5ndGgsIGNoaWxkTGVuZ3Roc1t0eXBlSWRdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdChjaGlsZC5zbGljZShjaGlsZE9mZnNldHNbdHlwZUlkXSwgY2hpbGRMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBhc3NlbWJsZUJvb2xWZWN0b3I8VCBleHRlbmRzIEJvb2w+KHRoaXM6IFZlY3RvckFzc2VtYmxlciwgdmVjdG9yOiBWVHlwZTxUPikge1xuICAgIC8vIEJvb2wgdmVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlIG9mIEZsYXRWZWN0b3IsIGFzIGl0cyBkYXRhIGJ1ZmZlciBuZWVkcyB0byBzdGF5IHBhY2tlZFxuICAgIGxldCB2YWx1ZXM6IFVpbnQ4QXJyYXk7XG4gICAgaWYgKHZlY3Rvci5udWxsQ291bnQgPj0gdmVjdG9yLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiBhbGwgdmFsdWVzIGFyZSBudWxsLCBqdXN0IGluc2VydCBhIHBsYWNlaG9sZGVyIGVtcHR5IGRhdGEgYnVmZmVyIChmYXN0ZXN0IHBhdGgpXG4gICAgICAgIHJldHVybiBhZGRCdWZmZXIuY2FsbCh0aGlzLCBuZXcgVWludDhBcnJheSgwKSk7XG4gICAgfSBlbHNlIGlmICgodmFsdWVzID0gdmVjdG9yLnZhbHVlcykgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIElmIHZhbHVlcyBpcyBhbHJlYWR5IGEgVWludDhBcnJheSwgc2xpY2UgdGhlIGJpdG1hcCAoZmFzdCBwYXRoKVxuICAgICAgICByZXR1cm4gYWRkQnVmZmVyLmNhbGwodGhpcywgdHJ1bmNhdGVCaXRtYXAodmVjdG9yLm9mZnNldCwgdmVjdG9yLmxlbmd0aCwgdmFsdWVzKSk7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSBpZiB0aGUgdW5kZXJseWluZyBkYXRhICppc24ndCogYSBVaW50OEFycmF5LCBlbnVtZXJhdGUgdGhlXG4gICAgLy8gdmFsdWVzIGFzIGJvb2xzIGFuZCByZS1wYWNrIHRoZW0gaW50byBhIFVpbnQ4QXJyYXkuIFRoaXMgY29kZSBpc24ndFxuICAgIC8vIHJlYWNoYWJsZSB1bmxlc3MgeW91J3JlIHRyeWluZyB0byBtYW5pcHVsYXRlIHRoZSBEYXRhIGludGVybmFscyxcbiAgICAvLyB3ZSB3ZSdyZSBvbmx5IGRvaW5nIHRoaXMgZm9yIHNhZmV0eS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBhZGRCdWZmZXIuY2FsbCh0aGlzLCBwYWNrQm9vbHModmVjdG9yKSk7XG59XG5cbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBhc3NlbWJsZUZsYXRWZWN0b3I8VCBleHRlbmRzIEludCB8IEZsb2F0IHwgRml4ZWRTaXplQmluYXJ5IHwgRGF0ZV8gfCBUaW1lc3RhbXAgfCBUaW1lIHwgRGVjaW1hbCB8IEludGVydmFsPih0aGlzOiBWZWN0b3JBc3NlbWJsZXIsIHZlY3RvcjogVlR5cGU8VD4pIHtcbiAgICByZXR1cm4gYWRkQnVmZmVyLmNhbGwodGhpcywgdmVjdG9yLnZhbHVlcy5zdWJhcnJheSgwLCB2ZWN0b3IubGVuZ3RoICogdmVjdG9yLnN0cmlkZSkpO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYXNzZW1ibGVGbGF0TGlzdFZlY3RvcjxUIGV4dGVuZHMgVXRmOCB8IEJpbmFyeT4odGhpczogVmVjdG9yQXNzZW1ibGVyLCB2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgY29uc3QgeyBsZW5ndGgsIHZhbHVlcywgdmFsdWVPZmZzZXRzIH0gPSB2ZWN0b3I7XG4gICAgY29uc3QgZmlyc3RPZmZzZXQgPSB2YWx1ZU9mZnNldHNbMF07XG4gICAgY29uc3QgbGFzdE9mZnNldCA9IHZhbHVlT2Zmc2V0c1tsZW5ndGhdO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBNYXRoLm1pbihsYXN0T2Zmc2V0IC0gZmlyc3RPZmZzZXQsIHZhbHVlcy5ieXRlTGVuZ3RoIC0gZmlyc3RPZmZzZXQpO1xuICAgIC8vIFB1c2ggaW4gdGhlIG9yZGVyIEZsYXRMaXN0IHR5cGVzIHJlYWQgdGhlaXIgYnVmZmVyc1xuICAgIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHJlYmFzZVZhbHVlT2Zmc2V0cygtdmFsdWVPZmZzZXRzWzBdLCBsZW5ndGgsIHZhbHVlT2Zmc2V0cykpOyAvLyB2YWx1ZU9mZnNldHMgYnVmZmVyIGZpcnN0XG4gICAgYWRkQnVmZmVyLmNhbGwodGhpcywgdmFsdWVzLnN1YmFycmF5KGZpcnN0T2Zmc2V0LCBmaXJzdE9mZnNldCArIGJ5dGVMZW5ndGgpKTsgLy8gc2xpY2VkIHZhbHVlcyBidWZmZXIgc2Vjb25kXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBhc3NlbWJsZUxpc3RWZWN0b3I8VCBleHRlbmRzIExpc3QgfCBGaXhlZFNpemVMaXN0Pih0aGlzOiBWZWN0b3JBc3NlbWJsZXIsIHZlY3RvcjogVlR5cGU8VD4pIHtcbiAgICBjb25zdCB7IGxlbmd0aCwgdmFsdWVPZmZzZXRzIH0gPSB2ZWN0b3I7XG4gICAgLy8gSWYgd2UgaGF2ZSB2YWx1ZU9mZnNldHMgKExpc3RWZWN0b3IpLCBwdXNoIHRoYXQgYnVmZmVyIGZpcnN0XG4gICAgaWYgKHZhbHVlT2Zmc2V0cykge1xuICAgICAgICBhZGRCdWZmZXIuY2FsbCh0aGlzLCByZWJhc2VWYWx1ZU9mZnNldHModmFsdWVPZmZzZXRzWzBdLCBsZW5ndGgsIHZhbHVlT2Zmc2V0cykpO1xuICAgIH1cbiAgICAvLyBUaGVuIGluc2VydCB0aGUgTGlzdCdzIHZhbHVlcyBjaGlsZFxuICAgIHJldHVybiB0aGlzLnZpc2l0KHZlY3Rvci5nZXRDaGlsZEF0KDApISk7XG59XG5cbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBhc3NlbWJsZU5lc3RlZFZlY3RvcjxUIGV4dGVuZHMgU3RydWN0IHwgTWFwXyB8IFVuaW9uPih0aGlzOiBWZWN0b3JBc3NlbWJsZXIsIHZlY3RvcjogVlR5cGU8VD4pIHtcbiAgICByZXR1cm4gdGhpcy52aXNpdE1hbnkodmVjdG9yLnR5cGUuY2hpbGRyZW4ubWFwKChfLCBpKSA9PiB2ZWN0b3IuZ2V0Q2hpbGRBdChpKSEpLmZpbHRlcihCb29sZWFuKSlbMF07XG59XG5cblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRCb29sICAgICAgICAgICAgPSAgICAgYXNzZW1ibGVCb29sVmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdEludCAgICAgICAgICAgICA9ICAgICBhc3NlbWJsZUZsYXRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0RmxvYXQgICAgICAgICAgID0gICAgIGFzc2VtYmxlRmxhdFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRVdGY4ICAgICAgICAgICAgPSBhc3NlbWJsZUZsYXRMaXN0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdEJpbmFyeSAgICAgICAgICA9IGFzc2VtYmxlRmxhdExpc3RWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0Rml4ZWRTaXplQmluYXJ5ID0gICAgIGFzc2VtYmxlRmxhdFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXREYXRlICAgICAgICAgICAgPSAgICAgYXNzZW1ibGVGbGF0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdFRpbWVzdGFtcCAgICAgICA9ICAgICBhc3NlbWJsZUZsYXRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0VGltZSAgICAgICAgICAgID0gICAgIGFzc2VtYmxlRmxhdFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXREZWNpbWFsICAgICAgICAgPSAgICAgYXNzZW1ibGVGbGF0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdExpc3QgICAgICAgICAgICA9ICAgICBhc3NlbWJsZUxpc3RWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0U3RydWN0ICAgICAgICAgID0gICBhc3NlbWJsZU5lc3RlZFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRVbmlvbiAgICAgICAgICAgPSAgICAgICAgICBhc3NlbWJsZVVuaW9uO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdEludGVydmFsICAgICAgICA9ICAgICBhc3NlbWJsZUZsYXRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0Rml4ZWRTaXplTGlzdCAgID0gICAgIGFzc2VtYmxlTGlzdFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRNYXAgICAgICAgICAgICAgPSAgIGFzc2VtYmxlTmVzdGVkVmVjdG9yO1xuIl19
