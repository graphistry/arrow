"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const visitor_1 = require("../visitor");
const enum_1 = require("../enum");
const recordbatch_1 = require("../recordbatch");
const buffer_1 = require("../util/buffer");
const bit_1 = require("../util/bit");
const args_1 = require("../util/args");
const message_1 = require("../ipc/metadata/message");
const type_1 = require("../type");
class VectorAssembler extends visitor_1.Visitor {
    constructor() {
        super();
        this._byteLength = 0;
        this._nodes = [];
        this._buffers = [];
        this._bufferRegions = [];
    }
    /** @nocollapse */
    static assemble(...args) {
        const assembler = new VectorAssembler();
        const vectorChildren = args_1.selectVectorChildrenArgs(recordbatch_1.RecordBatch, args);
        const [assembleResult = assembler] = assembler.visitMany(vectorChildren);
        return assembleResult;
    }
    visit(vector) {
        if (!type_1.DataType.isDictionary(vector.type)) {
            const { data, length, nullCount } = vector;
            if (length > 2147483647) {
                /* istanbul ignore next */
                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');
            }
            addBuffer.call(this, nullCount <= 0
                ? new Uint8Array(0) // placeholder validity buffer
                : bit_1.truncateBitmap(data.offset, length, data.nullBitmap)).nodes.push(new message_1.FieldNode(length, nullCount));
        }
        return super.visit(vector);
    }
    visitNull(_nullV) { return this; }
    visitDictionary(vector) {
        // Assemble the indices here, Dictionary assembled separately.
        return this.visit(vector.indices);
    }
    get nodes() { return this._nodes; }
    get buffers() { return this._buffers; }
    get byteLength() { return this._byteLength; }
    get bufferRegions() { return this._bufferRegions; }
}
exports.VectorAssembler = VectorAssembler;
/** @ignore */
function addBuffer(values) {
    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8
    this.buffers.push(values);
    this.bufferRegions.push(new message_1.BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
}
/** @ignore */
function assembleUnion(vector) {
    const { type, length, typeIds, valueOffsets } = vector;
    // All Union Vectors have a typeIds buffer
    addBuffer.call(this, typeIds);
    // If this is a Sparse Union, treat it like all other Nested types
    if (type.mode === enum_1.UnionMode.Sparse) {
        return assembleNestedVector.call(this, vector);
    }
    else if (type.mode === enum_1.UnionMode.Dense) {
        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children
        if (vector.offset <= 0) {
            // If the Vector hasn't been sliced, write the existing valueOffsets
            addBuffer.call(this, valueOffsets);
            // We can treat this like all other Nested types
            return assembleNestedVector.call(this, vector);
        }
        else {
            // A sliced Dense Union is an unpleasant case. Because the offsets are different for
            // each child vector, we need to "rebase" the valueOffsets for each child
            // Union typeIds are not necessary 0-indexed
            const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);
            const childLengths = new Int32Array(maxChildTypeId + 1);
            // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet
            const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);
            const shiftedOffsets = new Int32Array(length);
            // If we have a non-zero offset, then the value offsets do not start at
            // zero. We must a) create a new offsets array with shifted offsets and
            // b) slice the values array accordingly
            const unshiftedOffsets = buffer_1.rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);
            for (let typeId, shift, index = -1; ++index < length;) {
                if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {
                    shift = childOffsets[typeId] = unshiftedOffsets[typeId];
                }
                shiftedOffsets[index] = unshiftedOffsets[index] - shift;
                ++childLengths[typeId];
            }
            addBuffer.call(this, shiftedOffsets);
            // Slice and visit children accordingly
            for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {
                if (child = vector.getChildAt(childIndex)) {
                    const typeId = type.typeIds[childIndex];
                    const childLength = Math.min(length, childLengths[typeId]);
                    this.visit(child.slice(childOffsets[typeId], childLength));
                }
            }
        }
    }
    return this;
}
/** @ignore */
function assembleBoolVector(vector) {
    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed
    let values;
    if (vector.nullCount >= vector.length) {
        // If all values are null, just insert a placeholder empty data buffer (fastest path)
        return addBuffer.call(this, new Uint8Array(0));
    }
    else if ((values = vector.values) instanceof Uint8Array) {
        // If values is already a Uint8Array, slice the bitmap (fast path)
        return addBuffer.call(this, bit_1.truncateBitmap(vector.offset, vector.length, values));
    }
    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the
    // values as bools and re-pack them into a Uint8Array. This code isn't
    // reachable unless you're trying to manipulate the Data internals,
    // we we're only doing this for safety.
    /* istanbul ignore next */
    return addBuffer.call(this, bit_1.packBools(vector));
}
/** @ignore */
function assembleFlatVector(vector) {
    return addBuffer.call(this, vector.values.subarray(0, vector.length * vector.stride));
}
/** @ignore */
function assembleFlatListVector(vector) {
    const { length, values, valueOffsets } = vector;
    const firstOffset = valueOffsets[0];
    const lastOffset = valueOffsets[length];
    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);
    // Push in the order FlatList types read their buffers
    addBuffer.call(this, buffer_1.rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first
    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second
    return this;
}
/** @ignore */
function assembleListVector(vector) {
    const { length, valueOffsets } = vector;
    // If we have valueOffsets (ListVector), push that buffer first
    if (valueOffsets) {
        addBuffer.call(this, buffer_1.rebaseValueOffsets(valueOffsets[0], length, valueOffsets));
    }
    // Then insert the List's values child
    return this.visit(vector.getChildAt(0));
}
/** @ignore */
function assembleNestedVector(vector) {
    return this.visitMany(vector.type.children.map((_, i) => vector.getChildAt(i)).filter(Boolean))[0];
}
VectorAssembler.prototype.visitBool = assembleBoolVector;
VectorAssembler.prototype.visitInt = assembleFlatVector;
VectorAssembler.prototype.visitFloat = assembleFlatVector;
VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitBinary = assembleFlatListVector;
VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
VectorAssembler.prototype.visitDate = assembleFlatVector;
VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
VectorAssembler.prototype.visitTime = assembleFlatVector;
VectorAssembler.prototype.visitDecimal = assembleFlatVector;
VectorAssembler.prototype.visitList = assembleListVector;
VectorAssembler.prototype.visitStruct = assembleNestedVector;
VectorAssembler.prototype.visitUnion = assembleUnion;
VectorAssembler.prototype.visitInterval = assembleFlatVector;
VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
VectorAssembler.prototype.visitMap = assembleNestedVector;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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LGVBQWUsQ0FBQyxTQUFTLENBQUMsY0FBYyxHQUFhLGtCQUFrQixDQUFDO0FBQ3hFLGVBQWUsQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFrQixrQkFBa0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBZSxrQkFBa0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBa0Isa0JBQWtCLENBQUM7QUFDeEUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQWMsb0JBQW9CLENBQUM7QUFDeEUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQXNCLGFBQWEsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBYyxrQkFBa0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLGtCQUFrQixHQUFTLGtCQUFrQixDQUFDO0FBQ3hFLGVBQWUsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFpQixvQkFBb0IsQ0FBQyIsImZpbGUiOiJ2aXNpdG9yL3ZlY3RvcmFzc2VtYmxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbi8vIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuLy8gZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbi8vIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbi8vIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbi8vIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuLy8gd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuLy8gc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4vLyBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbi8vIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbi8vIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhIH0gZnJvbSAnLi4vZGF0YSc7XG5pbXBvcnQgeyBWZWN0b3IgfSBmcm9tICcuLi92ZWN0b3InO1xuaW1wb3J0IHsgVmlzaXRvciB9IGZyb20gJy4uL3Zpc2l0b3InO1xuaW1wb3J0IHsgVHlwZSwgVW5pb25Nb2RlIH0gZnJvbSAnLi4vZW51bSc7XG5pbXBvcnQgeyBSZWNvcmRCYXRjaCB9IGZyb20gJy4uL3JlY29yZGJhdGNoJztcbmltcG9ydCB7IFZlY3RvciBhcyBWVHlwZSB9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgcmViYXNlVmFsdWVPZmZzZXRzIH0gZnJvbSAnLi4vdXRpbC9idWZmZXInO1xuaW1wb3J0IHsgcGFja0Jvb2xzLCB0cnVuY2F0ZUJpdG1hcCB9IGZyb20gJy4uL3V0aWwvYml0JztcbmltcG9ydCB7IHNlbGVjdFZlY3RvckNoaWxkcmVuQXJncyB9IGZyb20gJy4uL3V0aWwvYXJncyc7XG5pbXBvcnQgeyBCdWZmZXJSZWdpb24sIEZpZWxkTm9kZSB9IGZyb20gJy4uL2lwYy9tZXRhZGF0YS9tZXNzYWdlJztcbmltcG9ydCB7XG4gICAgRGF0YVR5cGUsIERpY3Rpb25hcnksXG4gICAgRmxvYXQsIEludCwgRGF0ZV8sIEludGVydmFsLCBUaW1lLCBUaW1lc3RhbXAsIFVuaW9uLFxuICAgIEJvb2wsIE51bGwsIFV0ZjgsIEJpbmFyeSwgRGVjaW1hbCwgRml4ZWRTaXplQmluYXJ5LCBMaXN0LCBGaXhlZFNpemVMaXN0LCBNYXBfLCBTdHJ1Y3QsXG59IGZyb20gJy4uL3R5cGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvckFzc2VtYmxlciBleHRlbmRzIFZpc2l0b3Ige1xuICAgIHZpc2l0PFQgZXh0ZW5kcyBWZWN0b3I+KG5vZGU6IFQpOiB0aGlzO1xuICAgIHZpc2l0TWFueTxUIGV4dGVuZHMgVmVjdG9yPihub2RlczogVFtdKTogdGhpc1tdO1xuICAgIGdldFZpc2l0Rm48VCBleHRlbmRzIFR5cGU+KG5vZGU6IFQpOiAodmVjdG9yOiBWVHlwZTxUPikgPT4gdGhpcztcbiAgICBnZXRWaXNpdEZuPFQgZXh0ZW5kcyBEYXRhVHlwZT4obm9kZTogVlR5cGU8VD4gfCBEYXRhPFQ+IHwgVCk6ICh2ZWN0b3I6IFZUeXBlPFQ+KSA9PiB0aGlzO1xuXG4gICAgdmlzaXRCb29sICAgICAgICAgICAgICAgICA8VCBleHRlbmRzIEJvb2w+ICAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0SW50ICAgICAgICAgICAgICAgICAgPFQgZXh0ZW5kcyBJbnQ+ICAgICAgICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdEZsb2F0ICAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgRmxvYXQ+ICAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRVdGY4ICAgICAgICAgICAgICAgICA8VCBleHRlbmRzIFV0Zjg+ICAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0QmluYXJ5ICAgICAgICAgICAgICAgPFQgZXh0ZW5kcyBCaW5hcnk+ICAgICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdEZpeGVkU2l6ZUJpbmFyeSAgICAgIDxUIGV4dGVuZHMgRml4ZWRTaXplQmluYXJ5PiAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXREYXRlICAgICAgICAgICAgICAgICA8VCBleHRlbmRzIERhdGVfPiAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0VGltZXN0YW1wICAgICAgICAgICAgPFQgZXh0ZW5kcyBUaW1lc3RhbXA+ICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdFRpbWUgICAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgVGltZT4gICAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXREZWNpbWFsICAgICAgICAgICAgICA8VCBleHRlbmRzIERlY2ltYWw+ICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0TGlzdCAgICAgICAgICAgICAgICAgPFQgZXh0ZW5kcyBMaXN0PiAgICAgICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdFN0cnVjdCAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgU3RydWN0PiAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRVbmlvbiAgICAgICAgICAgICAgICA8VCBleHRlbmRzIFVuaW9uPiAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0SW50ZXJ2YWwgICAgICAgICAgICAgPFQgZXh0ZW5kcyBJbnRlcnZhbD4gICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdEZpeGVkU2l6ZUxpc3QgICAgICAgIDxUIGV4dGVuZHMgRml4ZWRTaXplTGlzdD4gICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRNYXAgICAgICAgICAgICAgICAgICA8VCBleHRlbmRzIE1hcF8+ICAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xufVxuXG5leHBvcnQgY2xhc3MgVmVjdG9yQXNzZW1ibGVyIGV4dGVuZHMgVmlzaXRvciB7XG5cbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBwdWJsaWMgc3RhdGljIGFzc2VtYmxlPFQgZXh0ZW5kcyBWZWN0b3IgfCBSZWNvcmRCYXRjaD4oLi4uYXJnczogKFQgfCBUW10pW10pIHtcbiAgICAgICAgY29uc3QgYXNzZW1ibGVyID0gbmV3IFZlY3RvckFzc2VtYmxlcigpO1xuICAgICAgICBjb25zdCB2ZWN0b3JDaGlsZHJlbiA9IHNlbGVjdFZlY3RvckNoaWxkcmVuQXJncyhSZWNvcmRCYXRjaCwgYXJncyk7XG4gICAgICAgIGNvbnN0IFthc3NlbWJsZVJlc3VsdCA9IGFzc2VtYmxlcl0gPSBhc3NlbWJsZXIudmlzaXRNYW55KHZlY3RvckNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIGFzc2VtYmxlUmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7IHN1cGVyKCk7IH1cblxuICAgIHB1YmxpYyB2aXNpdDxUIGV4dGVuZHMgVmVjdG9yPih2ZWN0b3I6IFQpOiB0aGlzIHtcbiAgICAgICAgaWYgKCFEYXRhVHlwZS5pc0RpY3Rpb25hcnkodmVjdG9yLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGxlbmd0aCwgbnVsbENvdW50IH0gPSB2ZWN0b3I7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0Nhbm5vdCB3cml0ZSBhcnJheXMgbGFyZ2VyIHRoYW4gMl4zMSAtIDEgaW4gbGVuZ3RoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRCdWZmZXIuY2FsbCh0aGlzLCBudWxsQ291bnQgPD0gMFxuICAgICAgICAgICAgICAgID8gbmV3IFVpbnQ4QXJyYXkoMCkgLy8gcGxhY2Vob2xkZXIgdmFsaWRpdHkgYnVmZmVyXG4gICAgICAgICAgICAgICAgOiB0cnVuY2F0ZUJpdG1hcChkYXRhLm9mZnNldCwgbGVuZ3RoLCBkYXRhLm51bGxCaXRtYXApXG4gICAgICAgICAgICApLm5vZGVzLnB1c2gobmV3IEZpZWxkTm9kZShsZW5ndGgsIG51bGxDb3VudCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci52aXNpdCh2ZWN0b3IpO1xuICAgIH1cblxuICAgIHB1YmxpYyB2aXNpdE51bGw8VCBleHRlbmRzIE51bGw+KF9udWxsVjogVlR5cGU8VD4pIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBwdWJsaWMgdmlzaXREaWN0aW9uYXJ5PFQgZXh0ZW5kcyBEaWN0aW9uYXJ5Pih2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgICAgIC8vIEFzc2VtYmxlIHRoZSBpbmRpY2VzIGhlcmUsIERpY3Rpb25hcnkgYXNzZW1ibGVkIHNlcGFyYXRlbHkuXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0KHZlY3Rvci5pbmRpY2VzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG5vZGVzKCkgeyByZXR1cm4gdGhpcy5fbm9kZXM7IH1cbiAgICBwdWJsaWMgZ2V0IGJ1ZmZlcnMoKSB7IHJldHVybiB0aGlzLl9idWZmZXJzOyB9XG4gICAgcHVibGljIGdldCBieXRlTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5fYnl0ZUxlbmd0aDsgfVxuICAgIHB1YmxpYyBnZXQgYnVmZmVyUmVnaW9ucygpIHsgcmV0dXJuIHRoaXMuX2J1ZmZlclJlZ2lvbnM7IH1cblxuICAgIHByb3RlY3RlZCBfYnl0ZUxlbmd0aCA9IDA7XG4gICAgcHJvdGVjdGVkIF9ub2RlczogRmllbGROb2RlW10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgX2J1ZmZlcnM6IEFycmF5QnVmZmVyVmlld1tdID0gW107XG4gICAgcHJvdGVjdGVkIF9idWZmZXJSZWdpb25zOiBCdWZmZXJSZWdpb25bXSA9IFtdO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYWRkQnVmZmVyKHRoaXM6IFZlY3RvckFzc2VtYmxlciwgdmFsdWVzOiBBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gKHZhbHVlcy5ieXRlTGVuZ3RoICsgNykgJiB+NzsgLy8gUm91bmQgdXAgdG8gYSBtdWx0aXBsZSBvZiA4XG4gICAgdGhpcy5idWZmZXJzLnB1c2godmFsdWVzKTtcbiAgICB0aGlzLmJ1ZmZlclJlZ2lvbnMucHVzaChuZXcgQnVmZmVyUmVnaW9uKHRoaXMuX2J5dGVMZW5ndGgsIGJ5dGVMZW5ndGgpKTtcbiAgICB0aGlzLl9ieXRlTGVuZ3RoICs9IGJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBhc3NlbWJsZVVuaW9uPFQgZXh0ZW5kcyBVbmlvbj4odGhpczogVmVjdG9yQXNzZW1ibGVyLCB2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgY29uc3QgeyB0eXBlLCBsZW5ndGgsIHR5cGVJZHMsIHZhbHVlT2Zmc2V0cyB9ID0gdmVjdG9yO1xuICAgIC8vIEFsbCBVbmlvbiBWZWN0b3JzIGhhdmUgYSB0eXBlSWRzIGJ1ZmZlclxuICAgIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHR5cGVJZHMpO1xuICAgIC8vIElmIHRoaXMgaXMgYSBTcGFyc2UgVW5pb24sIHRyZWF0IGl0IGxpa2UgYWxsIG90aGVyIE5lc3RlZCB0eXBlc1xuICAgIGlmICh0eXBlLm1vZGUgPT09IFVuaW9uTW9kZS5TcGFyc2UpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VtYmxlTmVzdGVkVmVjdG9yLmNhbGwodGhpcywgdmVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUubW9kZSA9PT0gVW5pb25Nb2RlLkRlbnNlKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBEZW5zZSBVbmlvbiwgYWRkIHRoZSB2YWx1ZU9mZnNldHMgYnVmZmVyIGFuZCBwb3RlbnRpYWxseSBzbGljZSB0aGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKHZlY3Rvci5vZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIFZlY3RvciBoYXNuJ3QgYmVlbiBzbGljZWQsIHdyaXRlIHRoZSBleGlzdGluZyB2YWx1ZU9mZnNldHNcbiAgICAgICAgICAgIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHZhbHVlT2Zmc2V0cyk7XG4gICAgICAgICAgICAvLyBXZSBjYW4gdHJlYXQgdGhpcyBsaWtlIGFsbCBvdGhlciBOZXN0ZWQgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiBhc3NlbWJsZU5lc3RlZFZlY3Rvci5jYWxsKHRoaXMsIHZlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBIHNsaWNlZCBEZW5zZSBVbmlvbiBpcyBhbiB1bnBsZWFzYW50IGNhc2UuIEJlY2F1c2UgdGhlIG9mZnNldHMgYXJlIGRpZmZlcmVudCBmb3JcbiAgICAgICAgICAgIC8vIGVhY2ggY2hpbGQgdmVjdG9yLCB3ZSBuZWVkIHRvIFwicmViYXNlXCIgdGhlIHZhbHVlT2Zmc2V0cyBmb3IgZWFjaCBjaGlsZFxuICAgICAgICAgICAgLy8gVW5pb24gdHlwZUlkcyBhcmUgbm90IG5lY2Vzc2FyeSAwLWluZGV4ZWRcbiAgICAgICAgICAgIGNvbnN0IG1heENoaWxkVHlwZUlkID0gdHlwZUlkcy5yZWR1Y2UoKHgsIHkpID0+IE1hdGgubWF4KHgsIHkpLCB0eXBlSWRzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTGVuZ3RocyA9IG5ldyBJbnQzMkFycmF5KG1heENoaWxkVHlwZUlkICsgMSk7XG4gICAgICAgICAgICAvLyBTZXQgYWxsIHRvIC0xIHRvIGluZGljYXRlIHRoYXQgd2UgaGF2ZW4ndCBvYnNlcnZlZCBhIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIGNoaWxkIHlldFxuICAgICAgICAgICAgY29uc3QgY2hpbGRPZmZzZXRzID0gbmV3IEludDMyQXJyYXkobWF4Q2hpbGRUeXBlSWQgKyAxKS5maWxsKC0xKTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ZWRPZmZzZXRzID0gbmV3IEludDMyQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBub24temVybyBvZmZzZXQsIHRoZW4gdGhlIHZhbHVlIG9mZnNldHMgZG8gbm90IHN0YXJ0IGF0XG4gICAgICAgICAgICAvLyB6ZXJvLiBXZSBtdXN0IGEpIGNyZWF0ZSBhIG5ldyBvZmZzZXRzIGFycmF5IHdpdGggc2hpZnRlZCBvZmZzZXRzIGFuZFxuICAgICAgICAgICAgLy8gYikgc2xpY2UgdGhlIHZhbHVlcyBhcnJheSBhY2NvcmRpbmdseVxuICAgICAgICAgICAgY29uc3QgdW5zaGlmdGVkT2Zmc2V0cyA9IHJlYmFzZVZhbHVlT2Zmc2V0cygtdmFsdWVPZmZzZXRzWzBdLCBsZW5ndGgsIHZhbHVlT2Zmc2V0cyk7XG4gICAgICAgICAgICBmb3IgKGxldCB0eXBlSWQsIHNoaWZ0LCBpbmRleCA9IC0xOyArK2luZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIGlmICgoc2hpZnQgPSBjaGlsZE9mZnNldHNbdHlwZUlkID0gdHlwZUlkc1tpbmRleF1dKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBjaGlsZE9mZnNldHNbdHlwZUlkXSA9IHVuc2hpZnRlZE9mZnNldHNbdHlwZUlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2hpZnRlZE9mZnNldHNbaW5kZXhdID0gdW5zaGlmdGVkT2Zmc2V0c1tpbmRleF0gLSBzaGlmdDtcbiAgICAgICAgICAgICAgICArK2NoaWxkTGVuZ3Roc1t0eXBlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQnVmZmVyLmNhbGwodGhpcywgc2hpZnRlZE9mZnNldHMpO1xuICAgICAgICAgICAgLy8gU2xpY2UgYW5kIHZpc2l0IGNoaWxkcmVuIGFjY29yZGluZ2x5XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZDogVmVjdG9yIHwgbnVsbCwgY2hpbGRJbmRleCA9IC0xLCBudW1DaGlsZHJlbiA9IHR5cGUuY2hpbGRyZW4ubGVuZ3RoOyArK2NoaWxkSW5kZXggPCBudW1DaGlsZHJlbjspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPSB2ZWN0b3IuZ2V0Q2hpbGRBdChjaGlsZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlSWQgPSB0eXBlLnR5cGVJZHNbY2hpbGRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTGVuZ3RoID0gTWF0aC5taW4obGVuZ3RoLCBjaGlsZExlbmd0aHNbdHlwZUlkXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXQoY2hpbGQuc2xpY2UoY2hpbGRPZmZzZXRzW3R5cGVJZF0sIGNoaWxkTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYXNzZW1ibGVCb29sVmVjdG9yPFQgZXh0ZW5kcyBCb29sPih0aGlzOiBWZWN0b3JBc3NlbWJsZXIsIHZlY3RvcjogVlR5cGU8VD4pIHtcbiAgICAvLyBCb29sIHZlY3RvciBpcyBhIHNwZWNpYWwgY2FzZSBvZiBGbGF0VmVjdG9yLCBhcyBpdHMgZGF0YSBidWZmZXIgbmVlZHMgdG8gc3RheSBwYWNrZWRcbiAgICBsZXQgdmFsdWVzOiBVaW50OEFycmF5O1xuICAgIGlmICh2ZWN0b3IubnVsbENvdW50ID49IHZlY3Rvci5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgYWxsIHZhbHVlcyBhcmUgbnVsbCwganVzdCBpbnNlcnQgYSBwbGFjZWhvbGRlciBlbXB0eSBkYXRhIGJ1ZmZlciAoZmFzdGVzdCBwYXRoKVxuICAgICAgICByZXR1cm4gYWRkQnVmZmVyLmNhbGwodGhpcywgbmV3IFVpbnQ4QXJyYXkoMCkpO1xuICAgIH0gZWxzZSBpZiAoKHZhbHVlcyA9IHZlY3Rvci52YWx1ZXMpIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAvLyBJZiB2YWx1ZXMgaXMgYWxyZWFkeSBhIFVpbnQ4QXJyYXksIHNsaWNlIHRoZSBiaXRtYXAgKGZhc3QgcGF0aClcbiAgICAgICAgcmV0dXJuIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHRydW5jYXRlQml0bWFwKHZlY3Rvci5vZmZzZXQsIHZlY3Rvci5sZW5ndGgsIHZhbHVlcykpO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UgaWYgdGhlIHVuZGVybHlpbmcgZGF0YSAqaXNuJ3QqIGEgVWludDhBcnJheSwgZW51bWVyYXRlIHRoZVxuICAgIC8vIHZhbHVlcyBhcyBib29scyBhbmQgcmUtcGFjayB0aGVtIGludG8gYSBVaW50OEFycmF5LiBUaGlzIGNvZGUgaXNuJ3RcbiAgICAvLyByZWFjaGFibGUgdW5sZXNzIHlvdSdyZSB0cnlpbmcgdG8gbWFuaXB1bGF0ZSB0aGUgRGF0YSBpbnRlcm5hbHMsXG4gICAgLy8gd2Ugd2UncmUgb25seSBkb2luZyB0aGlzIGZvciBzYWZldHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gYWRkQnVmZmVyLmNhbGwodGhpcywgcGFja0Jvb2xzKHZlY3RvcikpO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYXNzZW1ibGVGbGF0VmVjdG9yPFQgZXh0ZW5kcyBJbnQgfCBGbG9hdCB8IEZpeGVkU2l6ZUJpbmFyeSB8IERhdGVfIHwgVGltZXN0YW1wIHwgVGltZSB8IERlY2ltYWwgfCBJbnRlcnZhbD4odGhpczogVmVjdG9yQXNzZW1ibGVyLCB2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgcmV0dXJuIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHZlY3Rvci52YWx1ZXMuc3ViYXJyYXkoMCwgdmVjdG9yLmxlbmd0aCAqIHZlY3Rvci5zdHJpZGUpKTtcbn1cblxuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGFzc2VtYmxlRmxhdExpc3RWZWN0b3I8VCBleHRlbmRzIFV0ZjggfCBCaW5hcnk+KHRoaXM6IFZlY3RvckFzc2VtYmxlciwgdmVjdG9yOiBWVHlwZTxUPikge1xuICAgIGNvbnN0IHsgbGVuZ3RoLCB2YWx1ZXMsIHZhbHVlT2Zmc2V0cyB9ID0gdmVjdG9yO1xuICAgIGNvbnN0IGZpcnN0T2Zmc2V0ID0gdmFsdWVPZmZzZXRzWzBdO1xuICAgIGNvbnN0IGxhc3RPZmZzZXQgPSB2YWx1ZU9mZnNldHNbbGVuZ3RoXTtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gTWF0aC5taW4obGFzdE9mZnNldCAtIGZpcnN0T2Zmc2V0LCB2YWx1ZXMuYnl0ZUxlbmd0aCAtIGZpcnN0T2Zmc2V0KTtcbiAgICAvLyBQdXNoIGluIHRoZSBvcmRlciBGbGF0TGlzdCB0eXBlcyByZWFkIHRoZWlyIGJ1ZmZlcnNcbiAgICBhZGRCdWZmZXIuY2FsbCh0aGlzLCByZWJhc2VWYWx1ZU9mZnNldHMoLXZhbHVlT2Zmc2V0c1swXSwgbGVuZ3RoLCB2YWx1ZU9mZnNldHMpKTsgLy8gdmFsdWVPZmZzZXRzIGJ1ZmZlciBmaXJzdFxuICAgIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHZhbHVlcy5zdWJhcnJheShmaXJzdE9mZnNldCwgZmlyc3RPZmZzZXQgKyBieXRlTGVuZ3RoKSk7IC8vIHNsaWNlZCB2YWx1ZXMgYnVmZmVyIHNlY29uZFxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYXNzZW1ibGVMaXN0VmVjdG9yPFQgZXh0ZW5kcyBMaXN0IHwgRml4ZWRTaXplTGlzdD4odGhpczogVmVjdG9yQXNzZW1ibGVyLCB2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgY29uc3QgeyBsZW5ndGgsIHZhbHVlT2Zmc2V0cyB9ID0gdmVjdG9yO1xuICAgIC8vIElmIHdlIGhhdmUgdmFsdWVPZmZzZXRzIChMaXN0VmVjdG9yKSwgcHVzaCB0aGF0IGJ1ZmZlciBmaXJzdFxuICAgIGlmICh2YWx1ZU9mZnNldHMpIHtcbiAgICAgICAgYWRkQnVmZmVyLmNhbGwodGhpcywgcmViYXNlVmFsdWVPZmZzZXRzKHZhbHVlT2Zmc2V0c1swXSwgbGVuZ3RoLCB2YWx1ZU9mZnNldHMpKTtcbiAgICB9XG4gICAgLy8gVGhlbiBpbnNlcnQgdGhlIExpc3QncyB2YWx1ZXMgY2hpbGRcbiAgICByZXR1cm4gdGhpcy52aXNpdCh2ZWN0b3IuZ2V0Q2hpbGRBdCgwKSEpO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYXNzZW1ibGVOZXN0ZWRWZWN0b3I8VCBleHRlbmRzIFN0cnVjdCB8IE1hcF8gfCBVbmlvbj4odGhpczogVmVjdG9yQXNzZW1ibGVyLCB2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaXRNYW55KHZlY3Rvci50eXBlLmNoaWxkcmVuLm1hcCgoXywgaSkgPT4gdmVjdG9yLmdldENoaWxkQXQoaSkhKS5maWx0ZXIoQm9vbGVhbikpWzBdO1xufVxuXG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0Qm9vbCAgICAgICAgICAgID0gICAgIGFzc2VtYmxlQm9vbFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRJbnQgICAgICAgICAgICAgPSAgICAgYXNzZW1ibGVGbGF0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdEZsb2F0ICAgICAgICAgICA9ICAgICBhc3NlbWJsZUZsYXRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0VXRmOCAgICAgICAgICAgID0gYXNzZW1ibGVGbGF0TGlzdFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRCaW5hcnkgICAgICAgICAgPSBhc3NlbWJsZUZsYXRMaXN0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdEZpeGVkU2l6ZUJpbmFyeSA9ICAgICBhc3NlbWJsZUZsYXRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0RGF0ZSAgICAgICAgICAgID0gICAgIGFzc2VtYmxlRmxhdFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRUaW1lc3RhbXAgICAgICAgPSAgICAgYXNzZW1ibGVGbGF0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdFRpbWUgICAgICAgICAgICA9ICAgICBhc3NlbWJsZUZsYXRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0RGVjaW1hbCAgICAgICAgID0gICAgIGFzc2VtYmxlRmxhdFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRMaXN0ICAgICAgICAgICAgPSAgICAgYXNzZW1ibGVMaXN0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdFN0cnVjdCAgICAgICAgICA9ICAgYXNzZW1ibGVOZXN0ZWRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0VW5pb24gICAgICAgICAgID0gICAgICAgICAgYXNzZW1ibGVVbmlvbjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRJbnRlcnZhbCAgICAgICAgPSAgICAgYXNzZW1ibGVGbGF0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdEZpeGVkU2l6ZUxpc3QgICA9ICAgICBhc3NlbWJsZUxpc3RWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0TWFwICAgICAgICAgICAgID0gICBhc3NlbWJsZU5lc3RlZFZlY3RvcjtcbiJdfQ==
