"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const visitor_1 = require("../visitor");
const enum_1 = require("../enum");
const recordbatch_1 = require("../recordbatch");
const buffer_1 = require("../util/buffer");
const bit_1 = require("../util/bit");
const args_1 = require("../util/args");
const message_1 = require("../ipc/metadata/message");
const type_1 = require("../type");
class VectorAssembler extends visitor_1.Visitor {
    constructor() {
        super();
        this._byteLength = 0;
        this._nodes = [];
        this._buffers = [];
        this._bufferRegions = [];
    }
    /** @nocollapse */
    static assemble(...args) {
        const assembler = new VectorAssembler();
        const vectorChildren = args_1.selectVectorChildrenArgs(recordbatch_1.RecordBatch, args);
        const [assembleResult = assembler] = assembler.visitMany(vectorChildren);
        return assembleResult;
    }
    visit(vector) {
        if (!type_1.DataType.isDictionary(vector.type)) {
            const { data, length, nullCount } = vector;
            if (length > 2147483647) {
                /* istanbul ignore next */
                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');
            }
            addBuffer.call(this, nullCount <= 0
                ? new Uint8Array(0) // placeholder validity buffer
                : bit_1.truncateBitmap(data.offset, length, data.nullBitmap)).nodes.push(new message_1.FieldNode(length, nullCount));
        }
        return super.visit(vector);
    }
    visitNull(_nullV) {
        return addBuffer.call(this, new Uint8Array(0));
    }
    visitDictionary(vector) {
        // Assemble the indices here, Dictionary assembled separately.
        return this.visit(vector.indices);
    }
    get nodes() { return this._nodes; }
    get buffers() { return this._buffers; }
    get byteLength() { return this._byteLength; }
    get bufferRegions() { return this._bufferRegions; }
}
exports.VectorAssembler = VectorAssembler;
/** @ignore */
function addBuffer(values) {
    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8
    this.buffers.push(values);
    this.bufferRegions.push(new message_1.BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
}
/** @ignore */
function assembleUnion(vector) {
    const { type, length, typeIds, valueOffsets } = vector;
    // All Union Vectors have a typeIds buffer
    addBuffer.call(this, typeIds);
    // If this is a Sparse Union, treat it like all other Nested types
    if (type.mode === enum_1.UnionMode.Sparse) {
        return assembleNestedVector.call(this, vector);
    }
    else if (type.mode === enum_1.UnionMode.Dense) {
        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children
        if (vector.offset <= 0) {
            // If the Vector hasn't been sliced, write the existing valueOffsets
            addBuffer.call(this, valueOffsets);
            // We can treat this like all other Nested types
            return assembleNestedVector.call(this, vector);
        }
        else {
            // A sliced Dense Union is an unpleasant case. Because the offsets are different for
            // each child vector, we need to "rebase" the valueOffsets for each child
            // Union typeIds are not necessary 0-indexed
            const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);
            const childLengths = new Int32Array(maxChildTypeId + 1);
            // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet
            const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);
            const shiftedOffsets = new Int32Array(length);
            // If we have a non-zero offset, then the value offsets do not start at
            // zero. We must a) create a new offsets array with shifted offsets and
            // b) slice the values array accordingly
            const unshiftedOffsets = buffer_1.rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);
            for (let typeId, shift, index = -1; ++index < length;) {
                if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {
                    shift = childOffsets[typeId] = unshiftedOffsets[typeId];
                }
                shiftedOffsets[index] = unshiftedOffsets[index] - shift;
                ++childLengths[typeId];
            }
            addBuffer.call(this, shiftedOffsets);
            // Slice and visit children accordingly
            for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {
                if (child = vector.getChildAt(childIndex)) {
                    const typeId = type.typeIds[childIndex];
                    const childLength = Math.min(length, childLengths[typeId]);
                    this.visit(child.slice(childOffsets[typeId], childLength));
                }
            }
        }
    }
    return this;
}
/** @ignore */
function assembleBoolVector(vector) {
    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed
    let values;
    if (vector.nullCount >= vector.length) {
        // If all values are null, just insert a placeholder empty data buffer (fastest path)
        return addBuffer.call(this, new Uint8Array(0));
    }
    else if ((values = vector.values) instanceof Uint8Array) {
        // If values is already a Uint8Array, slice the bitmap (fast path)
        return addBuffer.call(this, bit_1.truncateBitmap(vector.offset, vector.length, values));
    }
    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the
    // values as bools and re-pack them into a Uint8Array. This code isn't
    // reachable unless you're trying to manipulate the Data internals,
    // we we're only doing this for safety.
    /* istanbul ignore next */
    return addBuffer.call(this, bit_1.packBools(vector));
}
/** @ignore */
function assembleFlatVector(vector) {
    return addBuffer.call(this, vector.values.subarray(0, vector.length * vector.stride));
}
/** @ignore */
function assembleFlatListVector(vector) {
    const { length, values, valueOffsets } = vector;
    const firstOffset = valueOffsets[0];
    const lastOffset = valueOffsets[length];
    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);
    // Push in the order FlatList types read their buffers
    addBuffer.call(this, buffer_1.rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first
    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second
    return this;
}
/** @ignore */
function assembleListVector(vector) {
    const { length, valueOffsets } = vector;
    // If we have valueOffsets (ListVector), push that buffer first
    if (valueOffsets) {
        addBuffer.call(this, buffer_1.rebaseValueOffsets(valueOffsets[0], length, valueOffsets));
    }
    // Then insert the List's values child
    return this.visit(vector.getChildAt(0));
}
/** @ignore */
function assembleNestedVector(vector) {
    return this.visitMany(vector.type.children.map((_, i) => vector.getChildAt(i)).filter(Boolean))[0];
}
VectorAssembler.prototype.visitBool = assembleBoolVector;
VectorAssembler.prototype.visitInt = assembleFlatVector;
VectorAssembler.prototype.visitFloat = assembleFlatVector;
VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitBinary = assembleFlatListVector;
VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
VectorAssembler.prototype.visitDate = assembleFlatVector;
VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
VectorAssembler.prototype.visitTime = assembleFlatVector;
VectorAssembler.prototype.visitDecimal = assembleFlatVector;
VectorAssembler.prototype.visitList = assembleListVector;
VectorAssembler.prototype.visitStruct = assembleNestedVector;
VectorAssembler.prototype.visitUnion = assembleUnion;
VectorAssembler.prototype.visitInterval = assembleFlatVector;
VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
VectorAssembler.prototype.visitMap = assembleNestedVector;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBa0Isa0JBQWtCLENBQUM7QUFDeEUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEdBQWEsa0JBQWtCLENBQUM7QUFDeEUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQWtCLGtCQUFrQixDQUFDO0FBQ3hFLGVBQWUsQ0FBQyxTQUFTLENBQUMsWUFBWSxHQUFlLGtCQUFrQixDQUFDO0FBQ3hFLGVBQWUsQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFrQixrQkFBa0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBYyxvQkFBb0IsQ0FBQztBQUN4RSxlQUFlLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBc0IsYUFBYSxDQUFDO0FBQ3hFLGVBQWUsQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFjLGtCQUFrQixDQUFDO0FBQ3hFLGVBQWUsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEdBQVMsa0JBQWtCLENBQUM7QUFDeEUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQWlCLG9CQUFvQixDQUFDIiwiZmlsZSI6InZpc2l0b3IvdmVjdG9yYXNzZW1ibGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuLy8gb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4vLyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuLy8gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuLy8gdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuLy8gXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4vLyB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4vLyBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbi8vIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuLy8gc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuLy8gdW5kZXIgdGhlIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGEgfSBmcm9tICcuLi9kYXRhJztcbmltcG9ydCB7IFZlY3RvciB9IGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQgeyBWaXNpdG9yIH0gZnJvbSAnLi4vdmlzaXRvcic7XG5pbXBvcnQgeyBUeXBlLCBVbmlvbk1vZGUgfSBmcm9tICcuLi9lbnVtJztcbmltcG9ydCB7IFJlY29yZEJhdGNoIH0gZnJvbSAnLi4vcmVjb3JkYmF0Y2gnO1xuaW1wb3J0IHsgVmVjdG9yIGFzIFZUeXBlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyByZWJhc2VWYWx1ZU9mZnNldHMgfSBmcm9tICcuLi91dGlsL2J1ZmZlcic7XG5pbXBvcnQgeyBwYWNrQm9vbHMsIHRydW5jYXRlQml0bWFwIH0gZnJvbSAnLi4vdXRpbC9iaXQnO1xuaW1wb3J0IHsgc2VsZWN0VmVjdG9yQ2hpbGRyZW5BcmdzIH0gZnJvbSAnLi4vdXRpbC9hcmdzJztcbmltcG9ydCB7IEJ1ZmZlclJlZ2lvbiwgRmllbGROb2RlIH0gZnJvbSAnLi4vaXBjL21ldGFkYXRhL21lc3NhZ2UnO1xuaW1wb3J0IHtcbiAgICBEYXRhVHlwZSwgRGljdGlvbmFyeSxcbiAgICBGbG9hdCwgSW50LCBEYXRlXywgSW50ZXJ2YWwsIFRpbWUsIFRpbWVzdGFtcCwgVW5pb24sXG4gICAgQm9vbCwgTnVsbCwgVXRmOCwgQmluYXJ5LCBEZWNpbWFsLCBGaXhlZFNpemVCaW5hcnksIExpc3QsIEZpeGVkU2l6ZUxpc3QsIE1hcF8sIFN0cnVjdCxcbn0gZnJvbSAnLi4vdHlwZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yQXNzZW1ibGVyIGV4dGVuZHMgVmlzaXRvciB7XG4gICAgdmlzaXQ8VCBleHRlbmRzIFZlY3Rvcj4obm9kZTogVCk6IHRoaXM7XG4gICAgdmlzaXRNYW55PFQgZXh0ZW5kcyBWZWN0b3I+KG5vZGVzOiBUW10pOiB0aGlzW107XG4gICAgZ2V0VmlzaXRGbjxUIGV4dGVuZHMgVHlwZT4obm9kZTogVCk6ICh2ZWN0b3I6IFZUeXBlPFQ+KSA9PiB0aGlzO1xuICAgIGdldFZpc2l0Rm48VCBleHRlbmRzIERhdGFUeXBlPihub2RlOiBWVHlwZTxUPiB8IERhdGE8VD4gfCBUKTogKHZlY3RvcjogVlR5cGU8VD4pID0+IHRoaXM7XG5cbiAgICB2aXNpdEJvb2wgICAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgQm9vbD4gICAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRJbnQgICAgICAgICAgICAgICAgICA8VCBleHRlbmRzIEludD4gICAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0RmxvYXQgICAgICAgICAgICAgICAgPFQgZXh0ZW5kcyBGbG9hdD4gICAgICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdFV0ZjggICAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgVXRmOD4gICAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRCaW5hcnkgICAgICAgICAgICAgICA8VCBleHRlbmRzIEJpbmFyeT4gICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0Rml4ZWRTaXplQmluYXJ5ICAgICAgPFQgZXh0ZW5kcyBGaXhlZFNpemVCaW5hcnk+ICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdERhdGUgICAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgRGF0ZV8+ICAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRUaW1lc3RhbXAgICAgICAgICAgICA8VCBleHRlbmRzIFRpbWVzdGFtcD4gICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0VGltZSAgICAgICAgICAgICAgICAgPFQgZXh0ZW5kcyBUaW1lPiAgICAgICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdERlY2ltYWwgICAgICAgICAgICAgIDxUIGV4dGVuZHMgRGVjaW1hbD4gICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRMaXN0ICAgICAgICAgICAgICAgICA8VCBleHRlbmRzIExpc3Q+ICAgICAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0U3RydWN0ICAgICAgICAgICAgICAgPFQgZXh0ZW5kcyBTdHJ1Y3Q+ICAgICAgICAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdFVuaW9uICAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgVW5pb24+ICAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG4gICAgdmlzaXRJbnRlcnZhbCAgICAgICAgICAgICA8VCBleHRlbmRzIEludGVydmFsPiAgICAgICAgKHZlY3RvcjogVlR5cGU8VD4pOiB0aGlzO1xuICAgIHZpc2l0Rml4ZWRTaXplTGlzdCAgICAgICAgPFQgZXh0ZW5kcyBGaXhlZFNpemVMaXN0PiAgICh2ZWN0b3I6IFZUeXBlPFQ+KTogdGhpcztcbiAgICB2aXNpdE1hcCAgICAgICAgICAgICAgICAgIDxUIGV4dGVuZHMgTWFwXz4gICAgICAgICAgICAodmVjdG9yOiBWVHlwZTxUPik6IHRoaXM7XG59XG5cbmV4cG9ydCBjbGFzcyBWZWN0b3JBc3NlbWJsZXIgZXh0ZW5kcyBWaXNpdG9yIHtcblxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYXNzZW1ibGU8VCBleHRlbmRzIFZlY3RvciB8IFJlY29yZEJhdGNoPiguLi5hcmdzOiAoVCB8IFRbXSlbXSkge1xuICAgICAgICBjb25zdCBhc3NlbWJsZXIgPSBuZXcgVmVjdG9yQXNzZW1ibGVyKCk7XG4gICAgICAgIGNvbnN0IHZlY3RvckNoaWxkcmVuID0gc2VsZWN0VmVjdG9yQ2hpbGRyZW5BcmdzKFJlY29yZEJhdGNoLCBhcmdzKTtcbiAgICAgICAgY29uc3QgW2Fzc2VtYmxlUmVzdWx0ID0gYXNzZW1ibGVyXSA9IGFzc2VtYmxlci52aXNpdE1hbnkodmVjdG9yQ2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gYXNzZW1ibGVSZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoKTsgfVxuXG4gICAgcHVibGljIHZpc2l0PFQgZXh0ZW5kcyBWZWN0b3I+KHZlY3RvcjogVCk6IHRoaXMge1xuICAgICAgICBpZiAoIURhdGFUeXBlLmlzRGljdGlvbmFyeSh2ZWN0b3IudHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgbGVuZ3RoLCBudWxsQ291bnQgfSA9IHZlY3RvcjtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2Fubm90IHdyaXRlIGFycmF5cyBsYXJnZXIgdGhhbiAyXjMxIC0gMSBpbiBsZW5ndGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIG51bGxDb3VudCA8PSAwXG4gICAgICAgICAgICAgICAgPyBuZXcgVWludDhBcnJheSgwKSAvLyBwbGFjZWhvbGRlciB2YWxpZGl0eSBidWZmZXJcbiAgICAgICAgICAgICAgICA6IHRydW5jYXRlQml0bWFwKGRhdGEub2Zmc2V0LCBsZW5ndGgsIGRhdGEubnVsbEJpdG1hcClcbiAgICAgICAgICAgICkubm9kZXMucHVzaChuZXcgRmllbGROb2RlKGxlbmd0aCwgbnVsbENvdW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0KHZlY3Rvcik7XG4gICAgfVxuXG4gICAgcHVibGljIHZpc2l0TnVsbDxUIGV4dGVuZHMgTnVsbD4oX251bGxWOiBWVHlwZTxUPikge1xuICAgICAgICByZXR1cm4gYWRkQnVmZmVyLmNhbGwodGhpcywgbmV3IFVpbnQ4QXJyYXkoMCkpO1xuICAgIH1cbiAgICBwdWJsaWMgdmlzaXREaWN0aW9uYXJ5PFQgZXh0ZW5kcyBEaWN0aW9uYXJ5Pih2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgICAgIC8vIEFzc2VtYmxlIHRoZSBpbmRpY2VzIGhlcmUsIERpY3Rpb25hcnkgYXNzZW1ibGVkIHNlcGFyYXRlbHkuXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0KHZlY3Rvci5pbmRpY2VzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG5vZGVzKCkgeyByZXR1cm4gdGhpcy5fbm9kZXM7IH1cbiAgICBwdWJsaWMgZ2V0IGJ1ZmZlcnMoKSB7IHJldHVybiB0aGlzLl9idWZmZXJzOyB9XG4gICAgcHVibGljIGdldCBieXRlTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5fYnl0ZUxlbmd0aDsgfVxuICAgIHB1YmxpYyBnZXQgYnVmZmVyUmVnaW9ucygpIHsgcmV0dXJuIHRoaXMuX2J1ZmZlclJlZ2lvbnM7IH1cblxuICAgIHByb3RlY3RlZCBfYnl0ZUxlbmd0aCA9IDA7XG4gICAgcHJvdGVjdGVkIF9ub2RlczogRmllbGROb2RlW10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgX2J1ZmZlcnM6IEFycmF5QnVmZmVyVmlld1tdID0gW107XG4gICAgcHJvdGVjdGVkIF9idWZmZXJSZWdpb25zOiBCdWZmZXJSZWdpb25bXSA9IFtdO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYWRkQnVmZmVyKHRoaXM6IFZlY3RvckFzc2VtYmxlciwgdmFsdWVzOiBBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gKHZhbHVlcy5ieXRlTGVuZ3RoICsgNykgJiB+NzsgLy8gUm91bmQgdXAgdG8gYSBtdWx0aXBsZSBvZiA4XG4gICAgdGhpcy5idWZmZXJzLnB1c2godmFsdWVzKTtcbiAgICB0aGlzLmJ1ZmZlclJlZ2lvbnMucHVzaChuZXcgQnVmZmVyUmVnaW9uKHRoaXMuX2J5dGVMZW5ndGgsIGJ5dGVMZW5ndGgpKTtcbiAgICB0aGlzLl9ieXRlTGVuZ3RoICs9IGJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBhc3NlbWJsZVVuaW9uPFQgZXh0ZW5kcyBVbmlvbj4odGhpczogVmVjdG9yQXNzZW1ibGVyLCB2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgY29uc3QgeyB0eXBlLCBsZW5ndGgsIHR5cGVJZHMsIHZhbHVlT2Zmc2V0cyB9ID0gdmVjdG9yO1xuICAgIC8vIEFsbCBVbmlvbiBWZWN0b3JzIGhhdmUgYSB0eXBlSWRzIGJ1ZmZlclxuICAgIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHR5cGVJZHMpO1xuICAgIC8vIElmIHRoaXMgaXMgYSBTcGFyc2UgVW5pb24sIHRyZWF0IGl0IGxpa2UgYWxsIG90aGVyIE5lc3RlZCB0eXBlc1xuICAgIGlmICh0eXBlLm1vZGUgPT09IFVuaW9uTW9kZS5TcGFyc2UpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VtYmxlTmVzdGVkVmVjdG9yLmNhbGwodGhpcywgdmVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUubW9kZSA9PT0gVW5pb25Nb2RlLkRlbnNlKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBEZW5zZSBVbmlvbiwgYWRkIHRoZSB2YWx1ZU9mZnNldHMgYnVmZmVyIGFuZCBwb3RlbnRpYWxseSBzbGljZSB0aGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKHZlY3Rvci5vZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIFZlY3RvciBoYXNuJ3QgYmVlbiBzbGljZWQsIHdyaXRlIHRoZSBleGlzdGluZyB2YWx1ZU9mZnNldHNcbiAgICAgICAgICAgIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHZhbHVlT2Zmc2V0cyk7XG4gICAgICAgICAgICAvLyBXZSBjYW4gdHJlYXQgdGhpcyBsaWtlIGFsbCBvdGhlciBOZXN0ZWQgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiBhc3NlbWJsZU5lc3RlZFZlY3Rvci5jYWxsKHRoaXMsIHZlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBIHNsaWNlZCBEZW5zZSBVbmlvbiBpcyBhbiB1bnBsZWFzYW50IGNhc2UuIEJlY2F1c2UgdGhlIG9mZnNldHMgYXJlIGRpZmZlcmVudCBmb3JcbiAgICAgICAgICAgIC8vIGVhY2ggY2hpbGQgdmVjdG9yLCB3ZSBuZWVkIHRvIFwicmViYXNlXCIgdGhlIHZhbHVlT2Zmc2V0cyBmb3IgZWFjaCBjaGlsZFxuICAgICAgICAgICAgLy8gVW5pb24gdHlwZUlkcyBhcmUgbm90IG5lY2Vzc2FyeSAwLWluZGV4ZWRcbiAgICAgICAgICAgIGNvbnN0IG1heENoaWxkVHlwZUlkID0gdHlwZUlkcy5yZWR1Y2UoKHgsIHkpID0+IE1hdGgubWF4KHgsIHkpLCB0eXBlSWRzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTGVuZ3RocyA9IG5ldyBJbnQzMkFycmF5KG1heENoaWxkVHlwZUlkICsgMSk7XG4gICAgICAgICAgICAvLyBTZXQgYWxsIHRvIC0xIHRvIGluZGljYXRlIHRoYXQgd2UgaGF2ZW4ndCBvYnNlcnZlZCBhIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIGNoaWxkIHlldFxuICAgICAgICAgICAgY29uc3QgY2hpbGRPZmZzZXRzID0gbmV3IEludDMyQXJyYXkobWF4Q2hpbGRUeXBlSWQgKyAxKS5maWxsKC0xKTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ZWRPZmZzZXRzID0gbmV3IEludDMyQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBub24temVybyBvZmZzZXQsIHRoZW4gdGhlIHZhbHVlIG9mZnNldHMgZG8gbm90IHN0YXJ0IGF0XG4gICAgICAgICAgICAvLyB6ZXJvLiBXZSBtdXN0IGEpIGNyZWF0ZSBhIG5ldyBvZmZzZXRzIGFycmF5IHdpdGggc2hpZnRlZCBvZmZzZXRzIGFuZFxuICAgICAgICAgICAgLy8gYikgc2xpY2UgdGhlIHZhbHVlcyBhcnJheSBhY2NvcmRpbmdseVxuICAgICAgICAgICAgY29uc3QgdW5zaGlmdGVkT2Zmc2V0cyA9IHJlYmFzZVZhbHVlT2Zmc2V0cygtdmFsdWVPZmZzZXRzWzBdLCBsZW5ndGgsIHZhbHVlT2Zmc2V0cyk7XG4gICAgICAgICAgICBmb3IgKGxldCB0eXBlSWQsIHNoaWZ0LCBpbmRleCA9IC0xOyArK2luZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIGlmICgoc2hpZnQgPSBjaGlsZE9mZnNldHNbdHlwZUlkID0gdHlwZUlkc1tpbmRleF1dKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBjaGlsZE9mZnNldHNbdHlwZUlkXSA9IHVuc2hpZnRlZE9mZnNldHNbdHlwZUlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2hpZnRlZE9mZnNldHNbaW5kZXhdID0gdW5zaGlmdGVkT2Zmc2V0c1tpbmRleF0gLSBzaGlmdDtcbiAgICAgICAgICAgICAgICArK2NoaWxkTGVuZ3Roc1t0eXBlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQnVmZmVyLmNhbGwodGhpcywgc2hpZnRlZE9mZnNldHMpO1xuICAgICAgICAgICAgLy8gU2xpY2UgYW5kIHZpc2l0IGNoaWxkcmVuIGFjY29yZGluZ2x5XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZDogVmVjdG9yIHwgbnVsbCwgY2hpbGRJbmRleCA9IC0xLCBudW1DaGlsZHJlbiA9IHR5cGUuY2hpbGRyZW4ubGVuZ3RoOyArK2NoaWxkSW5kZXggPCBudW1DaGlsZHJlbjspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPSB2ZWN0b3IuZ2V0Q2hpbGRBdChjaGlsZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlSWQgPSB0eXBlLnR5cGVJZHNbY2hpbGRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTGVuZ3RoID0gTWF0aC5taW4obGVuZ3RoLCBjaGlsZExlbmd0aHNbdHlwZUlkXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXQoY2hpbGQuc2xpY2UoY2hpbGRPZmZzZXRzW3R5cGVJZF0sIGNoaWxkTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYXNzZW1ibGVCb29sVmVjdG9yPFQgZXh0ZW5kcyBCb29sPih0aGlzOiBWZWN0b3JBc3NlbWJsZXIsIHZlY3RvcjogVlR5cGU8VD4pIHtcbiAgICAvLyBCb29sIHZlY3RvciBpcyBhIHNwZWNpYWwgY2FzZSBvZiBGbGF0VmVjdG9yLCBhcyBpdHMgZGF0YSBidWZmZXIgbmVlZHMgdG8gc3RheSBwYWNrZWRcbiAgICBsZXQgdmFsdWVzOiBVaW50OEFycmF5O1xuICAgIGlmICh2ZWN0b3IubnVsbENvdW50ID49IHZlY3Rvci5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgYWxsIHZhbHVlcyBhcmUgbnVsbCwganVzdCBpbnNlcnQgYSBwbGFjZWhvbGRlciBlbXB0eSBkYXRhIGJ1ZmZlciAoZmFzdGVzdCBwYXRoKVxuICAgICAgICByZXR1cm4gYWRkQnVmZmVyLmNhbGwodGhpcywgbmV3IFVpbnQ4QXJyYXkoMCkpO1xuICAgIH0gZWxzZSBpZiAoKHZhbHVlcyA9IHZlY3Rvci52YWx1ZXMpIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAvLyBJZiB2YWx1ZXMgaXMgYWxyZWFkeSBhIFVpbnQ4QXJyYXksIHNsaWNlIHRoZSBiaXRtYXAgKGZhc3QgcGF0aClcbiAgICAgICAgcmV0dXJuIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHRydW5jYXRlQml0bWFwKHZlY3Rvci5vZmZzZXQsIHZlY3Rvci5sZW5ndGgsIHZhbHVlcykpO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UgaWYgdGhlIHVuZGVybHlpbmcgZGF0YSAqaXNuJ3QqIGEgVWludDhBcnJheSwgZW51bWVyYXRlIHRoZVxuICAgIC8vIHZhbHVlcyBhcyBib29scyBhbmQgcmUtcGFjayB0aGVtIGludG8gYSBVaW50OEFycmF5LiBUaGlzIGNvZGUgaXNuJ3RcbiAgICAvLyByZWFjaGFibGUgdW5sZXNzIHlvdSdyZSB0cnlpbmcgdG8gbWFuaXB1bGF0ZSB0aGUgRGF0YSBpbnRlcm5hbHMsXG4gICAgLy8gd2Ugd2UncmUgb25seSBkb2luZyB0aGlzIGZvciBzYWZldHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gYWRkQnVmZmVyLmNhbGwodGhpcywgcGFja0Jvb2xzKHZlY3RvcikpO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYXNzZW1ibGVGbGF0VmVjdG9yPFQgZXh0ZW5kcyBJbnQgfCBGbG9hdCB8IEZpeGVkU2l6ZUJpbmFyeSB8IERhdGVfIHwgVGltZXN0YW1wIHwgVGltZSB8IERlY2ltYWwgfCBJbnRlcnZhbD4odGhpczogVmVjdG9yQXNzZW1ibGVyLCB2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgcmV0dXJuIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHZlY3Rvci52YWx1ZXMuc3ViYXJyYXkoMCwgdmVjdG9yLmxlbmd0aCAqIHZlY3Rvci5zdHJpZGUpKTtcbn1cblxuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGFzc2VtYmxlRmxhdExpc3RWZWN0b3I8VCBleHRlbmRzIFV0ZjggfCBCaW5hcnk+KHRoaXM6IFZlY3RvckFzc2VtYmxlciwgdmVjdG9yOiBWVHlwZTxUPikge1xuICAgIGNvbnN0IHsgbGVuZ3RoLCB2YWx1ZXMsIHZhbHVlT2Zmc2V0cyB9ID0gdmVjdG9yO1xuICAgIGNvbnN0IGZpcnN0T2Zmc2V0ID0gdmFsdWVPZmZzZXRzWzBdO1xuICAgIGNvbnN0IGxhc3RPZmZzZXQgPSB2YWx1ZU9mZnNldHNbbGVuZ3RoXTtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gTWF0aC5taW4obGFzdE9mZnNldCAtIGZpcnN0T2Zmc2V0LCB2YWx1ZXMuYnl0ZUxlbmd0aCAtIGZpcnN0T2Zmc2V0KTtcbiAgICAvLyBQdXNoIGluIHRoZSBvcmRlciBGbGF0TGlzdCB0eXBlcyByZWFkIHRoZWlyIGJ1ZmZlcnNcbiAgICBhZGRCdWZmZXIuY2FsbCh0aGlzLCByZWJhc2VWYWx1ZU9mZnNldHMoLXZhbHVlT2Zmc2V0c1swXSwgbGVuZ3RoLCB2YWx1ZU9mZnNldHMpKTsgLy8gdmFsdWVPZmZzZXRzIGJ1ZmZlciBmaXJzdFxuICAgIGFkZEJ1ZmZlci5jYWxsKHRoaXMsIHZhbHVlcy5zdWJhcnJheShmaXJzdE9mZnNldCwgZmlyc3RPZmZzZXQgKyBieXRlTGVuZ3RoKSk7IC8vIHNsaWNlZCB2YWx1ZXMgYnVmZmVyIHNlY29uZFxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYXNzZW1ibGVMaXN0VmVjdG9yPFQgZXh0ZW5kcyBMaXN0IHwgRml4ZWRTaXplTGlzdD4odGhpczogVmVjdG9yQXNzZW1ibGVyLCB2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgY29uc3QgeyBsZW5ndGgsIHZhbHVlT2Zmc2V0cyB9ID0gdmVjdG9yO1xuICAgIC8vIElmIHdlIGhhdmUgdmFsdWVPZmZzZXRzIChMaXN0VmVjdG9yKSwgcHVzaCB0aGF0IGJ1ZmZlciBmaXJzdFxuICAgIGlmICh2YWx1ZU9mZnNldHMpIHtcbiAgICAgICAgYWRkQnVmZmVyLmNhbGwodGhpcywgcmViYXNlVmFsdWVPZmZzZXRzKHZhbHVlT2Zmc2V0c1swXSwgbGVuZ3RoLCB2YWx1ZU9mZnNldHMpKTtcbiAgICB9XG4gICAgLy8gVGhlbiBpbnNlcnQgdGhlIExpc3QncyB2YWx1ZXMgY2hpbGRcbiAgICByZXR1cm4gdGhpcy52aXNpdCh2ZWN0b3IuZ2V0Q2hpbGRBdCgwKSEpO1xufVxuXG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gYXNzZW1ibGVOZXN0ZWRWZWN0b3I8VCBleHRlbmRzIFN0cnVjdCB8IE1hcF8gfCBVbmlvbj4odGhpczogVmVjdG9yQXNzZW1ibGVyLCB2ZWN0b3I6IFZUeXBlPFQ+KSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaXRNYW55KHZlY3Rvci50eXBlLmNoaWxkcmVuLm1hcCgoXywgaSkgPT4gdmVjdG9yLmdldENoaWxkQXQoaSkhKS5maWx0ZXIoQm9vbGVhbikpWzBdO1xufVxuXG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0Qm9vbCAgICAgICAgICAgID0gICAgIGFzc2VtYmxlQm9vbFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRJbnQgICAgICAgICAgICAgPSAgICAgYXNzZW1ibGVGbGF0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdEZsb2F0ICAgICAgICAgICA9ICAgICBhc3NlbWJsZUZsYXRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0VXRmOCAgICAgICAgICAgID0gYXNzZW1ibGVGbGF0TGlzdFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRCaW5hcnkgICAgICAgICAgPSBhc3NlbWJsZUZsYXRMaXN0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdEZpeGVkU2l6ZUJpbmFyeSA9ICAgICBhc3NlbWJsZUZsYXRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0RGF0ZSAgICAgICAgICAgID0gICAgIGFzc2VtYmxlRmxhdFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRUaW1lc3RhbXAgICAgICAgPSAgICAgYXNzZW1ibGVGbGF0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdFRpbWUgICAgICAgICAgICA9ICAgICBhc3NlbWJsZUZsYXRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0RGVjaW1hbCAgICAgICAgID0gICAgIGFzc2VtYmxlRmxhdFZlY3RvcjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRMaXN0ICAgICAgICAgICAgPSAgICAgYXNzZW1ibGVMaXN0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdFN0cnVjdCAgICAgICAgICA9ICAgYXNzZW1ibGVOZXN0ZWRWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0VW5pb24gICAgICAgICAgID0gICAgICAgICAgYXNzZW1ibGVVbmlvbjtcblZlY3RvckFzc2VtYmxlci5wcm90b3R5cGUudmlzaXRJbnRlcnZhbCAgICAgICAgPSAgICAgYXNzZW1ibGVGbGF0VmVjdG9yO1xuVmVjdG9yQXNzZW1ibGVyLnByb3RvdHlwZS52aXNpdEZpeGVkU2l6ZUxpc3QgICA9ICAgICBhc3NlbWJsZUxpc3RWZWN0b3I7XG5WZWN0b3JBc3NlbWJsZXIucHJvdG90eXBlLnZpc2l0TWFwICAgICAgICAgICAgID0gICBhc3NlbWJsZU5lc3RlZFZlY3RvcjtcbiJdfQ==
