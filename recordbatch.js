"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const type_1 = require("./type");
const vector_1 = require("./vector");
const data_1 = require("./data");
const node_1 = require("./util/node");
const pretty_1 = require("./util/pretty");
class RecordBatch extends vector_1.StructVector {
    static from(vectors) {
        return new RecordBatch(type_1.Schema.from(vectors), Math.max(...vectors.map((v) => v.length)), vectors);
    }
    constructor(...args) {
        if (typeof args[1] !== 'number') {
            const data = args[1];
            super(data, args[2]);
            this.schema = args[0];
            this.length = data.length;
        }
        else {
            const [schema, numRows, cols] = args;
            const childData = new Array(cols.length);
            for (let index = -1, length = cols.length; ++index < length;) {
                const col = cols[index];
                childData[index] = col instanceof vector_1.Vector ? col.data : col;
            }
            super(new data_1.NestedData(new type_1.Struct(schema.fields), numRows, null, childData));
            this.schema = schema;
            this.length = numRows;
        }
        this.numCols = this.schema.fields.length;
    }
    clone(data, view = this.view.clone(data)) {
        return new RecordBatch(this.schema, data, view);
    }
    getChildAt(index) {
        return index < 0 || index >= this.numCols ? null : super.getChildAt(index);
    }
    select(...columnNames) {
        const fields = this.schema.fields;
        const namesToKeep = columnNames.reduce((xs, x) => (xs[x] = true) && xs, Object.create(null));
        return new RecordBatch(this.schema.select(...columnNames), this.length, this.childData.filter((_, i) => namesToKeep[fields[i].name]));
    }
    rowsToString(separator = ' | ', rowOffset = 0, maxColumnWidths = []) {
        return new node_1.PipeIterator(recordBatchRowsToString(this, separator, rowOffset, maxColumnWidths), 'utf8');
    }
}
exports.RecordBatch = RecordBatch;
function* recordBatchRowsToString(recordBatch, separator = ' | ', rowOffset = 0, maxColumnWidths = []) {
    const fields = recordBatch.schema.fields;
    const header = ['row_id', ...fields.map((f) => `${f}`)].map(pretty_1.valueToString);
    header.forEach((x, i) => {
        maxColumnWidths[i] = Math.max(maxColumnWidths[i] || 0, x.length);
    });
    // Pass one to convert to strings and count max column widths
    for (let i = -1, n = recordBatch.length - 1; ++i < n;) {
        let val, row = [rowOffset + i, ...recordBatch.get(i)];
        for (let j = -1, k = row.length; ++j < k;) {
            val = pretty_1.valueToString(row[j]);
            maxColumnWidths[j] = Math.max(maxColumnWidths[j] || 0, val.length);
        }
    }
    for (let i = -1; ++i < recordBatch.length;) {
        if ((rowOffset + i) % 1000 === 0) {
            yield header.map((x, j) => pretty_1.leftPad(x, ' ', maxColumnWidths[j])).join(separator);
        }
        yield [rowOffset + i, ...recordBatch.get(i)]
            .map((x) => pretty_1.valueToString(x))
            .map((x, j) => pretty_1.leftPad(x, ' ', maxColumnWidths[j]))
            .join(separator);
    }
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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OUIsTUFBTSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsZ0JBQU8sQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ25GO1FBQ0QsTUFBTSxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBcUIsQ0FBQzthQUMzRCxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLHNCQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDNUIsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsZ0JBQU8sQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2xELElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUN4QjtBQUNMLENBQUMiLCJmaWxlIjoicmVjb3JkYmF0Y2guanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4vLyBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbi8vIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4vLyByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4vLyB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4vLyBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbi8vIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbi8vIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuLy8gS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4vLyBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4vLyB1bmRlciB0aGUgTGljZW5zZS5cblxuaW1wb3J0IHsgU2NoZW1hLCBTdHJ1Y3QsIERhdGFUeXBlIH0gZnJvbSAnLi90eXBlJztcbmltcG9ydCB7IGZsYXRidWZmZXJzIH0gZnJvbSAnZmxhdGJ1ZmZlcnMnO1xuaW1wb3J0IHsgVmlldywgVmVjdG9yLCBTdHJ1Y3RWZWN0b3IgfSBmcm9tICcuL3ZlY3Rvcic7XG5pbXBvcnQgeyBEYXRhLCBOZXN0ZWREYXRhIH0gZnJvbSAnLi9kYXRhJztcbmltcG9ydCB7IFBpcGVJdGVyYXRvciB9IGZyb20gJy4vdXRpbC9ub2RlJztcbmltcG9ydCB7IHZhbHVlVG9TdHJpbmcsIGxlZnRQYWQgfSBmcm9tICcuL3V0aWwvcHJldHR5JztcblxuaW1wb3J0IExvbmcgPSBmbGF0YnVmZmVycy5Mb25nO1xuXG5leHBvcnQgY2xhc3MgUmVjb3JkQmF0Y2ggZXh0ZW5kcyBTdHJ1Y3RWZWN0b3Ige1xuICAgIHB1YmxpYyBzdGF0aWMgZnJvbSh2ZWN0b3JzOiBWZWN0b3JbXSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY29yZEJhdGNoKFNjaGVtYS5mcm9tKHZlY3RvcnMpLFxuICAgICAgICAgICAgTWF0aC5tYXgoLi4udmVjdG9ycy5tYXAoKHYpID0+IHYubGVuZ3RoKSksXG4gICAgICAgICAgICB2ZWN0b3JzXG4gICAgICAgICk7XG4gICAgfVxuICAgIHB1YmxpYyByZWFkb25seSBzY2hlbWE6IFNjaGVtYTtcbiAgICBwdWJsaWMgcmVhZG9ubHkgbGVuZ3RoOiBudW1iZXI7XG4gICAgcHVibGljIHJlYWRvbmx5IG51bUNvbHM6IG51bWJlcjtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWE6IFNjaGVtYSwgZGF0YTogRGF0YTxTdHJ1Y3Q+LCB2aWV3OiBWaWV3PFN0cnVjdD4pO1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYTogU2NoZW1hLCBudW1Sb3dzOiBMb25nIHwgbnVtYmVyLCBjb2xzOiBEYXRhPGFueT4gfCBWZWN0b3JbXSk7XG4gICAgY29uc3RydWN0b3IoLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGFyZ3NbMV0gYXMgRGF0YTxTdHJ1Y3Q+O1xuICAgICAgICAgICAgc3VwZXIoZGF0YSwgYXJnc1syXSk7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IGFyZ3NbMF07XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgW3NjaGVtYSwgbnVtUm93cywgY29sc10gPSBhcmdzO1xuICAgICAgICAgICAgY29uc3QgY2hpbGREYXRhOiBEYXRhPGFueT5bXSA9IG5ldyBBcnJheShjb2xzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IC0xLCBsZW5ndGggPSBjb2xzLmxlbmd0aDsgKytpbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2w6IERhdGE8YW55PiB8IFZlY3RvciA9IGNvbHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNoaWxkRGF0YVtpbmRleF0gPSBjb2wgaW5zdGFuY2VvZiBWZWN0b3IgPyBjb2wuZGF0YSA6IGNvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1cGVyKG5ldyBOZXN0ZWREYXRhKG5ldyBTdHJ1Y3Qoc2NoZW1hLmZpZWxkcyksIG51bVJvd3MsIG51bGwsIGNoaWxkRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG51bVJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5udW1Db2xzID0gdGhpcy5zY2hlbWEuZmllbGRzLmxlbmd0aDtcbiAgICB9XG4gICAgcHVibGljIGNsb25lPFIgZXh0ZW5kcyBTdHJ1Y3Q+KGRhdGE6IERhdGE8Uj4sIHZpZXc6IFZpZXc8Uj4gPSB0aGlzLnZpZXcuY2xvbmUoZGF0YSkpOiB0aGlzIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWNvcmRCYXRjaCh0aGlzLnNjaGVtYSwgZGF0YSBhcyBhbnksIHZpZXcpIGFzIGFueTtcbiAgICB9XG4gICAgcHVibGljIGdldENoaWxkQXQ8UiBleHRlbmRzIERhdGFUeXBlID0gRGF0YVR5cGU+KGluZGV4OiBudW1iZXIpOiBWZWN0b3I8Uj4gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLm51bUNvbHMgPyBudWxsIDogc3VwZXIuZ2V0Q2hpbGRBdDxSPihpbmRleCk7XG4gICAgfVxuICAgIHB1YmxpYyBzZWxlY3QoLi4uY29sdW1uTmFtZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuc2NoZW1hLmZpZWxkcztcbiAgICAgICAgY29uc3QgbmFtZXNUb0tlZXAgPSBjb2x1bW5OYW1lcy5yZWR1Y2UoKHhzLCB4KSA9PiAoeHNbeF0gPSB0cnVlKSAmJiB4cywgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVjb3JkQmF0Y2goXG4gICAgICAgICAgICB0aGlzLnNjaGVtYS5zZWxlY3QoLi4uY29sdW1uTmFtZXMpLCB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgIHRoaXMuY2hpbGREYXRhLmZpbHRlcigoXywgaSkgPT4gbmFtZXNUb0tlZXBbZmllbGRzW2ldLm5hbWVdKVxuICAgICAgICApO1xuICAgIH1cbiAgICBwdWJsaWMgcm93c1RvU3RyaW5nKHNlcGFyYXRvciA9ICcgfCAnLCByb3dPZmZzZXQgPSAwLCBtYXhDb2x1bW5XaWR0aHM6IG51bWJlcltdID0gW10pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQaXBlSXRlcmF0b3IocmVjb3JkQmF0Y2hSb3dzVG9TdHJpbmcodGhpcywgc2VwYXJhdG9yLCByb3dPZmZzZXQsIG1heENvbHVtbldpZHRocyksICd1dGY4Jyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiogcmVjb3JkQmF0Y2hSb3dzVG9TdHJpbmcocmVjb3JkQmF0Y2g6IFJlY29yZEJhdGNoLCBzZXBhcmF0b3IgPSAnIHwgJywgcm93T2Zmc2V0ID0gMCwgbWF4Q29sdW1uV2lkdGhzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgY29uc3QgZmllbGRzID0gcmVjb3JkQmF0Y2guc2NoZW1hLmZpZWxkcztcbiAgICBjb25zdCBoZWFkZXIgPSBbJ3Jvd19pZCcsIC4uLmZpZWxkcy5tYXAoKGYpID0+IGAke2Z9YCldLm1hcCh2YWx1ZVRvU3RyaW5nKTtcbiAgICBoZWFkZXIuZm9yRWFjaCgoeCwgaSkgPT4ge1xuICAgICAgICBtYXhDb2x1bW5XaWR0aHNbaV0gPSBNYXRoLm1heChtYXhDb2x1bW5XaWR0aHNbaV0gfHwgMCwgeC5sZW5ndGgpO1xuICAgIH0pO1xuICAgIC8vIFBhc3Mgb25lIHRvIGNvbnZlcnQgdG8gc3RyaW5ncyBhbmQgY291bnQgbWF4IGNvbHVtbiB3aWR0aHNcbiAgICBmb3IgKGxldCBpID0gLTEsIG4gPSByZWNvcmRCYXRjaC5sZW5ndGggLSAxOyArK2kgPCBuOykge1xuICAgICAgICBsZXQgdmFsLCByb3cgPSBbcm93T2Zmc2V0ICsgaSwgLi4ucmVjb3JkQmF0Y2guZ2V0KGkpIGFzIFN0cnVjdFsnVFZhbHVlJ11dO1xuICAgICAgICBmb3IgKGxldCBqID0gLTEsIGsgPSByb3cubGVuZ3RoOyArK2ogPCBrOyApIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbHVlVG9TdHJpbmcocm93W2pdKTtcbiAgICAgICAgICAgIG1heENvbHVtbldpZHRoc1tqXSA9IE1hdGgubWF4KG1heENvbHVtbldpZHRoc1tqXSB8fCAwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gLTE7ICsraSA8IHJlY29yZEJhdGNoLmxlbmd0aDspIHtcbiAgICAgICAgaWYgKChyb3dPZmZzZXQgKyBpKSAlIDEwMDAgPT09IDApIHtcbiAgICAgICAgICAgIHlpZWxkIGhlYWRlci5tYXAoKHgsIGopID0+IGxlZnRQYWQoeCwgJyAnLCBtYXhDb2x1bW5XaWR0aHNbal0pKS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgW3Jvd09mZnNldCArIGksIC4uLnJlY29yZEJhdGNoLmdldChpKSBhcyBTdHJ1Y3RbJ1RWYWx1ZSddXVxuICAgICAgICAgICAgLm1hcCgoeCkgPT4gdmFsdWVUb1N0cmluZyh4KSlcbiAgICAgICAgICAgIC5tYXAoKHgsIGopID0+IGxlZnRQYWQoeCwgJyAnLCBtYXhDb2x1bW5XaWR0aHNbal0pKVxuICAgICAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9XG59XG4iXX0=
